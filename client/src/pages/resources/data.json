{"C Programming Language":[{"title":"Arrays","description":"In the C language, an array is a list of values, with a fixed length.\n\nBeing able to store multiple pieces of related information in the same structure is very useful when writing C programs.\n\nDeclaring an Array\n\nThe syntax for declaring an array is first specify the data type, then a descriptive array name, followed by square brackets surrounding the array’s length (number of items):\n\ntype name[length];\n\nTo declare an int array named grades with a length of 6:\n\nint grades[6]; // An array to hold six integers\n\nAlternatively, the length can be omitted and the array’s initial values can be assigned to it instead. Values are assigned inside of the curly brackets and separated by commas.\n\nint grades[] = {96, 90, 78, 84, 88, 92};\nAccessing Values with Indexes\n\nThe values in arrays are accessed using their index, or their position in the array. They can either be assigned or used this way.\n\nchar vowels[] = {'a', 'e', 'i', 'o', 'u'};\n\nNote that in C, an array’s indexes start at 0 instead of 1:\n\n      +-------------------------+\nValue | 'a'  'e'  'i'  'o'  'u' |\n      +-------------------------+\nIndex |  0    1    2    3    4  |\n      +-------------------------+\n\nAn element can be accessed by referring to the array name and the element’s index number:\n\nvowels[0] will give the value 'a'\nvowels[1] will give the value 'e'\nvowels[2] will give the value 'i'\nvowels[3] will give the value 'o'\nvowels[4] will give the value 'u'\nchar vowels[] = {'a', 'e', 'i', 'o', 'u'};\n\n\nputchar(vowels[3]);\n// Output: o\nExample\n\nCreating an array that holds the snowfall measurements (in the nearest inch) from the past 7 days:\n\n#include <stdio.h>\n\n\nint main() {\n  int snowfall[] = {10, 13, 14, 11, 9, 8, 6};\n  printf(\"%d\\n\", snowfall[0]);\n\n\n  snowfall[2] = 16; // Update an element\n  printf(\"%d\\n\", snowfall[2]);\n\n\n  return 0;\n}\n\nThe output would be:\n\n10\n16"},{"title":"Basic Output","description":"In the C language, basic console output is achieved using functions from the “standard input output” header file (stdio.h).\n\nHeader File\n\nC itself has no ability to output any information. In order to so, the stdio.h header file must be included in the program, which typically happens at the top of the file:\n\n#include <stdio.h>\n\nOnce this is done, the functions included in it can be used.\n\nPrint Character with putchar()\n\nThe putchar() function, or “put character” function, takes a single char as an argument and prints it to the stdout file, normally the console.\n\n#include <stdio.h>\n\n\nint main(void) {\n  putchar('a');\n  return 0;\n}\n\nThe output would be:\n\na\nPrint String with puts()\n\nThe puts() function, or “put string” function, takes a string as an argument and prints it to the stdout file, followed by a newline character.\n\n#include <stdio.h>\n\n\nint main(void) {\n  puts(\"Hello World!\");\n  return 0;\n}\n\nThe output would be:\n\nHello World!\nPrint Formatted with printf()\n\nWhile the puts() function can only accept and print a single string, the printf() function can print variables within a string. So more flexibility!\n\nThe printf() function, or “print formatted” function, takes a string with variable placeholders, also known as format specifiers, followed by the values to format in the string.\n\n#include <stdio.h>\n\n\nint main(void) {\n  printf(\"%d is a number\\n\", 5);\n  printf(\"%d is after %d\\n\", 2, 1);\n  return 0;\n}\n\nThe output would be:\n\n5 is a number\n2 is after 1\nFormat Specifiers\n\nAs seen above, the string given contains a % character followed by a letter to indicate what type of value will be formatted there. Some common ones are shown below:\n\nFormat Specifier\tType\n%c\tchar\n%d\tdouble\n%i\tinteger\n%p\tpointer\n%s\tstring\nDecimal Precision\n\nWhen using format specifiers for decimal numbers, the number of decimal places to be printed can be specified.\n\nTo print 2 digits after the decimal place, 0.2f can be used in printf():\n\n#include <stdio.h>\n\n\nint main() {\n  float pi = 3.14159;\n\n\n  // Print 2 digits after the decimal place\n  printf(\"%0.2f\", pi);\n\n\n  return 0;\n}\n\nThe output would be:\n\n3.14"},{"title":"Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.\n\nSingle-line Comments\n\nSingle-line comments are created using two consecutive forward slashes. The compiler ignores any text after // on the same line.\n\n// This line will denote a comment in C\nMulti-line Comments\n\nMulti-line comments are created using /* to begin the comment, and */ to end the comment. The compiler ignores any text in between.\n\n/*\nThis is all commented out.\nNone of it is going to run!\n*/\nHeader Comment\n\nMulti-line comments can be used to create a header comment at the top of the file. File header comments are used to identify the author of the code, the date the code was written, a description of the program, etc. This is a common convention in the C language.\n\n/***************************************************************\n* FILENAME: hello.c\n* DESCRIPTION: This program prints a message to the screen.\n* AUTHOR: Gilfoyle\n* DATE: 04/20/2023\n* MODIFICATION: Dinesh\n* CHANGES: N/A\n****************************************************************/\nExample\n\nHere’s a program with a multi-line comment and three single-line comments:\n\n/* Tip Calculator\nWritten by Sonny */\n\n\n#include <stdio.h>\n\n\nint main() {\n  // Calculate the tip\n  double total = 18.75;\n  double tip = total * 0.2;\n\n\n  // Display the tip\n  printf(\"The tip is $%.2f\\n\", tip); // Show two decimal places\n\n\n  return 0;\n}"},{"title":"Compiling","description":"A compiler translates the C program (source code) into machine language (machine code) which it stores on the disk as a file.\n\nThis process of converting the source code into machine code is known as compilation.\n\nStages of Compiling a C Program\n\nThere are 4 stages in the process of compilation of a C Program.\n\n1. Preprocessing\n\nPreprocessing is the first stage in the process of compilation. In this stage:\n\nPreprocessor commands that begin with # are interpreted.\nComments are removed from the source code.\nMacros are expanded.\n2. Compiling\n\nIn this stage, the preprocessed code is translated into assembly code and syntax errors are checked by the compiler.\n\n3. Assembly\n\nIn this stage, an assembler is used to translate the assembly code into object code (machine code).\n\n4. Linking\n\nLinking is the final stage in the process of compilation. In this stage, all the object code from multiple modules is merged (linked) together and creates an executable image which is also saved on the disk, usually as a file with the file name without any extension (e.g. hello), so that it can finally be executed by the processor.\n\nCompile Command\ngcc –Wall hello.c\n\nThis compiles a file named hello.c and the output file will be named a.out.\n\ngcc –Wall hello.c –o hello\n\nThis compiles a file named hello.c and specifies the output file name as hello. The option -o is used to name the output file.\n\nExecute Command\n./hello\n\nThe executable file hello is loaded from the disk to memory and the computer’s CPU (Central Processing Unit) executes the program one instruction at a time.\n\n(xkcd: Compiling)"},{"title":"Functions","description":"Functions are blocks of code that can be reused within a program. They are stored under a name similar to a variable and can be called using this name.\n\nSyntax\nreturn_type name(parameters) {\n  // Code goes here\n}\n\nFunctions are declared with the following pieces:\n\nA return_type that denotes the specific type of data output.\nThe name of the functions.\nThe parameters are used for processing data in the function body, and the code for it to run in curly brackets.\n\nA function named greet() that prints a greeting to the console can be declared like this:\n\nvoid greet(void) {\n  puts(\"Howdy!\");\n}\n\nThe greet() function uses a void type to indicate that no output is returned after execution.\n\nCalling a Function\n\nAfter a function is declared, it can be called in the program. The syntax for this is the variables name followed by parenthesis.\n\n#include <stdio.h>\n\n\n// Declaring the function\n\n\nvoid greet(void) {\n  puts(\"Howdy!\");\n}\n\n\n// Calling the function inside main()\n\n\nint main() {\n  greet();\n}\n\nThe output would be:\n\nHowdy!\nArguments\n\nThe values passed to a function are known as arguments. They represent the actual input values that can be used within the function.\n\n#include <stdio.h>\n\n\nvoid max(int x, int y) {\n  if (x > y)\n    printf(\"%d is the bigger number\\n\", x);\n  else\n    printf(\"%d is the bigger number\\n\", y);\n}\n\n\nint main() {\n  int a = 20;\n  int b = 30;\n\n\n  max(a, b);\n\n\n  return 0;\n}\n\nHere’s another example:\n\n#include <stdio.h>\n\n\nvoid greet(char* name) {\n  printf(\"Howdy %s!\\n\")\n}\n\n\nint main() {\n  greet(\"John Doe\"); // Output: Howdy John Doe!\n  return 0;\n}\nReturning Values\n\nA function is also capable of returning a value back to were it was called using the return keyword. This is useful for computing values within a function. Notice that the word proceeding the function name indicates the type of value returned.\n\n#include <stdio.h>\n\n\nint add(int a, int b) {\n  return a + b;\n}\n\n\nint main(void) {\n  int num = add(1, 1);\n  printf(\"%d\\n\", num);\n}\n\nHere, the add() function has a return value of int."},{"title":"Memory Management","description":"Computer memory is a limited resource and we have to manage it efficiently. The process by which computer programs are assigned with physical or virtual memory space is called memory allocation.\n\nThe memory allocation can be done either before or at the time of program implementation. There are two techniques for memory allocation: static memory allocation and dynamic memory allocation.\n\nStatic Memory Allocation\n\nIn this type of allocation, the compiler allocates a fixed amount of memory during compile time and the operating system internally uses a data structure known as stack to manage the memory.\n\nExact memory requirements must be known in advance as once memory is allocated it can not be changed.\n\nint days; // Needs to be initialized or assigned some value at run time\nint snowfall = 0; // Normal variable\nconst int maxScore = 10; // Constant, can not be changed\nDynamic Memory Allocation\n\nIn this type of allocation system memory is managed at runtime. Dynamic memory management in C programming language is performed using four functions named malloc(), calloc(), realloc(), and free(). These four functions are defined in the C standard library header file <stdlib.h>. It uses the heap space of the system memory.\n\nmalloc()\n\nThe malloc() function is used to allocate a block of memory in the heap. It allocates the user a specified number of bytes but does not initialize. Once allocated, the program accesses this block of memory via a pointer that malloc() returns.\n\nThe default pointer returned by malloc() is of the type void but can be cast into a pointer of any data type. However, if the space is insufficient for the amount of memory requested by malloc(), then the allocation fails and a NULL pointer is returned.\n\nint *ptr;\n\n\n// The pointer ptr holds the address of the first byte in the allocated memory\nptr = (int*) malloc(5 * sizeof(int));\n\nSince the size of int is 4 bytes, the above statement will allocate 20 bytes (4 * 5) of memory.\n\ncalloc()\n\nThe calloc() function is used to dynamically allocate the specified number of blocks of memory of the specified type. It is very much similar to malloc() but the difference is that it initializes each block with a default value 0 and it has two parameters as compared to malloc() which only has one parameter.\n\nint *ptr;\n\n\n// The pointer ptr holds the address of the first byte in the allocated memory\nptr = (int*) calloc(5, sizeof(int));\n\nThe above statement allocates contiguous space in memory for 5 elements each with the size of the int.\n\nrealloc()\n\nThe realloc() function is used to dynamically change the memory which was previously allocated. It means that if the memory that was previously allocated using the malloc() or calloc() function is not sufficient, so it can be reallocated using the realloc() function.\n\nint *ptr;\n\n\n// Memory allocated using malloc() function\nptr = (int*) malloc(5 * sizeof(int));\n\n\n// ptr is reallocated with 40 bytes (4 * 10) of memory\nptr = realloc(ptr, 10 * sizeof(int));\nfree()\n\nThe free() function is used to dynamically de-allocate the memory. The memory allocated using functions malloc() and calloc() must be de-allocated manually by the user using the free() function when not in use. It helps to reduce the wastage of memory by freeing it.\n\nint *ptr;\n\n\n// Memory allocated using malloc() function\nptr = (int*) malloc(5 * sizeof(int));\n\n\n// Memory de-allocated using free() function\nfree(ptr);"},{"title":"Preprocessors","description":"Preprocessors in C scan the source code before it is compiled and transform it with tools like macros.\n\nPreprocessor commands and macros are included in the source code file and are interpreted before the source code is passed to the compiler.\n\nThe preprocessor can modify the final code that is compiled or provide messages to the developer during preprocessing.\n\nCommon Uses of Preprocessor Commands\nIncluding Additional Files\n\nOne of the most common preprocessor commands is #include which is used to include the text contents of some other file into the one being compiled.\n\n#include <stdio.h>\n\nThe preprocessor will replace #include <stdio.h> with the text contents of the file stdio.h.\n\nConditional Compilation\n\nThe preprocessor includes several statements used for conditional compilation:\n\n#if\n#elif\n#else\n#endif\n#ifdef: shorthand for #if defined(...)\n#ifndef: shorthand for #if !defined(...)\n#if HELLO > 0\n  printf(\"Hello world!\");\n#endif\n\nIf the macro HELLO is greater than zero, then the printf(\"Hello world!\") command will be compiled. If not, then the command will be omitted from the final code being compiled.\n\n#ifdef _WIN32\n  // Compile for 32-bit Windows system\n#elif defined(_WIN64)\n  // Compile for a 64-bit Windows system\n#else\n  // Compile for something else\n#endif\n\nThe example above will compile different code for different operating systems based on if the macros _WIN32 or _WIN64 exist.\n\nDefining Macros\n\nWhen the preprocessor encounters a macro in the source code, it will replace the macro with the value it has been assigned. Macros are defined by using #define and can be undefined using #undef.\n\n#define PI 3.1416\n\nAfter this line, every time the preprocessor encounters the macro PI, it will replace it with 3.1416 in the source code.\n\n#undef PI\n\nAfter this line, trying to use the macro PI will result in a compilation error."},{"title":"Pointers","description":"A pointer is a variable that stores a memory address, which typically represents the location of another variable. Pointers are useful because they allow the efficient creation and manipulation of complex data structures.\n\nUnderstanding Pointers\n\nData is stored in a computer’s memory. A variable represents a specific location within that memory and consists of three parts:\n\nAn identifier (name)\nA value\nAn address\n\nThe address is a value that describes where in memory a variable is located.\n\nTo understand pointers, it may be helpful to think of variables as boxes on a shelf. Each box has a label (the identifier), a unique serial number that allows one to locate it (the address), and possibly something inside of it (the value).\n\nFollowing this analogy, a pointer can be described as a box that contains the serial number of another box within it.\n\nDeclaring and Assigning a Pointer\n\nA pointer is declared similarly to how a variable is — by specifying its type, identifier, and value. However, an asterisk character * is inserted in front of the identifier.\n\ntype *name = value;\n\nIn order to obtain the address of a variable, the identifier is prefixed with an ampersand symbol &. This is known as the address operator.\n\nint year = 1986;\nint *pointer_to_year = &year;\n\nThe left-hand side of this declaration may be read in reverse order — “pointer_to_year is a pointer to an integer.”\n\nIf the value of year were to be printed, the output would read “1986”. However, if the value of pointer_to_year were to be printed, the output would be an address such as 0x2aba1c0cf890.\n\nThe dereference operator (also known as the indirection operator), represented by an asterisk (*), allows one to access the value of the variable that a pointer points to.\n\nint year = 1986;                            // Value of year: 1986\n\n\nint *pointer_to_year = &year;               // Value of pointer_to_year: 0x2aba1c0cf890\n\n\nint another_year = *(pointer_to_year) - 33; // Value of another_year: 1953\n\n\n*(pointer_to_year) = 2019;                  // This sets the value of year to 2019\nFunctions and Pointers\n\nLike other data types, pointers can be passed to and returned from functions. One scenario in which this might be useful is “returning” two values from a function.\n\nbool divide(int a, int b, bool *d) {\n  int c = a / b;\n\n\n  if (c * b == a) {\n    *(d) = true;\n  } else {\n    *(d) = false;\n  }\n  return c;\n}\n\n\nint numerator = 10;\nint denominator = 5;\nbool divisible;\n\n\nint result = divide(numerator, denominator, divisible);\n\nIn the example above, the divide() function returns the result of a / b and sets the variable that d points at to represent whether or not a is divisible by b. When this function is called on the last line, result is assigned a value of 2 and divisible becomes true."},{"title":"User Input","description":"The scanf() function, which stands for “scan format”, reads a formatted string from the standard input stream, which is usually the user keyboard.\n\nSyntax\nscanf(\"formatted string\", &variable);\n\nHere, the user can enter a value in the terminal, press Enter, and that number will get stored in the pinNumber variable.\n\nscanf(\"%d\", &pinNumber);\n\nNote: There’s an ampersand & before the variable names in the arguments. The program will crash if there’s a missing & sign.\n\nExample\n\nIn this example, the program will prompt the user to enter a number with \"Add tip amount: \". Then the user can enter a number in the terminal, press Enter, and the number will get stored in the variable tip.\n\n#include <stdio.h>\n\n\nint main() {\n  float tip = 0.0;\n\n\n  printf(\"Add tip amount: \");\n  scanf(\"%f\", &tip);\n\n\n  printf(\"You gave a tip of $%.2f\", tip);\n\n\n  return 0;\n}"},{"title":"Strings","description":"Strings are arrays of characters followed by a null character '\\0'.\n\nDeclaring and Initializing a String\n\nTo declare a string in C, the type of the string, char, is first specified, followed by the name of the string, the size, and the characters themselves.\n\nchar name[size] = {'a', 'b', 'c', 'd', '\\0'};\n\nThe following declaration and initialization create a string of \"Howdy\":\n\nchar message[6] = {'H', 'o', 'w', 'd', 'y', '\\0'};\n\nEven though \"Howdy\" has only 5 characters, message has 6 characters due to the null character at the end of the message array.\n\nThe above statement can be rewritten as:\n\nchar message[] = \"Howdy\";\n\nThis is the more common string declaration out in the wild.\n\nMemory\n\nHere’s the memory presentation:\n\nCharacter |   'H'    'o'    'w'    'd'    'y'   '\\0'\nIndex     |    0      1      2      3      4      5\nAddress   |  23451  23452  23453  23454  23455  23456\nDisplaying a String\n\nTo display a string in C, the printf() function from the stdio.h header file can be used along with the %s character to format strings, followed by the string name.\n\nExample\n#include <stdio.h>\n\n\nint main() {\n  char message[] = \"Hi y'all!\";\n  printf(\"Bot: %s\\n\", message);\n\n\n  return 0;\n}\n\n\n\nThe output would be:\n\nBot: Hi y'all!\nString Functions\n\nThe string.h header defines a handful of string functions for manipulating arrays of characters."},{"title":"Variables","description":"A variable is a location in computer memory used to store data, usually for use in a program.\n\nDeclaring and Assigning a Variable\n\nTo declare a variable in C, the type of variable is first included, followed by the name, and the value.\n\ntype name = value;\n\nThough if a variable does not yet need a value assigned to it, this can be ommitted and assigned later.\n\nint num;\nnum = 5;\n\nVariables are statically typed in C, meaning a variable can only ever have one type. A variable declared as an int can only hold an integer value.\n\nDisplaying a Variable\n\nTo display a variable in C, the printf() function from the stdio.h header file can be used along with the % character to format values, followed by the variable name.\n\n#include <stdio.h>\n\n\nint main(void) {\n  int number = 5;\n  char letter = 'a';\n\n\n  printf(\"%d\\n\", number);\n  printf(\"%c\\n\", letter);\n\n\n  return 0;\n}\n\nThe output would be:\n\n5\na"}],"C++":[{"title":"Arrays","description":"Like a vector, an array is a data structure used in C++ to store a sequential collection of elements. Unlike vectors, its size cannot be changed.\n\nBeing able to store multiple pieces of related information in the same structure is very useful when writing C++ programs.\n\nCreating an Array\n\nWhen creating an array, you have to keep two pieces of information in mind:\n\nThe type of data you want to store inside it.\nHow many items you want it to be able to hold (its size).\n\nWe can create an array a lot like we create normal variables, by specifying the data type, giving it a descriptive name, and also specifying its size:\n\nint favoriteNums[4];\n\nIn the above code example, we’ve created an array with a size of 4, meaning it can hold four integers (all four elements will initially have the default int value of 0).\n\nIn many cases, you won’t know what data needs to go in the array until after you’ve created it, but if you do happen to know the contents of the array ahead of time, you can initialize it with custom values upfront:\n\nint favoriteNums[] = {7, 9, 15, 16};\n\nThis array would also have a size of 4, but we don’t need to explicitly specify that when we initialize it in this way.\n\nArray Indices\n\nLike vectors, each element in an array is assigned a specific index starting at zero. To access or modify an element in the array you may simply refer to it by its index and operate on it accordingly.\n\nchar vowels[] = {'a', 'e', 'i', 'o', 'u'};\n//      indexes:  0    1    2    3    4\n\n\nstd::cout << vowels[0]; // Output: a\n\n\nvowels[0] = 'r';\n\n\nstd::cout << vowels[0]; // Output: r\n\nIn the case above, we initialized an array of chars with all the vowels, and then printed out the first element in the array at index 0. We then modified the element at index 0 by assigning it a new value of 'r', which got printed out below.\n\nArrays in C++ have a set size, meaning you can’t add or remove elements once the array has been created. You may only modify existing elements without changing the total size or shape of the structure."},{"title":"Bitwise Operators","description":"C++ supports different types of bitwise operators that can perform operations on integers at bit-level. Supported types of bitwise operators include:\n\n& Bitwise AND\n| Bitwise OR\n<< Bitwise Left Shift\n>> Bitwise Right Shift\n~ Bitwise Complement\n^ Bitwise XOR\n& Bitwise AND\n\nThe bitwise AND operator, &:\n\nReturns 1 if both the bits are 1 (1, 1).\nElse ((1, 0), (0, 1), (0, 0)), it returns 0.\n\nFor example:\n\n4 = 100 (base-2 binary system)\n5 = 101 (base-2 binary system)\n\n    100\n    101\n    ___\n    100, which is equal to 4 in the base-10 decimal system\n#include <iostream>\n\n\nint main() {\n  std::cout << (4 & 5) << \"\\n\";\n\n\n  return 0;\n}\n// Output: 100 (base-2 binary system) = 4\n| Bitwise OR\n\nThe Bitwise OR operator returns either of the following:\n\n1 if at least one of the bits is 1.\n0 if both of them are 0.\n\nFor example:\n\n4 = 100 (base-2 binary system)\n5 = 101 (base-2 binary system)\n\n    100\n    101\n    ___\n    101, which is equal to 5 in the base-10 decimal system.\n#include <iostream>\n\n\nint main() {\n  std::cout << (4 | 5) << std::endl;\n\n\n  return 0;\n}\n// Output: 101 (base-2 binary system) = 5\n<< Bitwise Left Shift\n\nThe left shift operator shifts all the bits towards the left side according to the number of bits specified and adds trailing 0’s to the right side.\n\nFor example:\n\n4 = 100 (base-2 binary system)\n\n4 << 1\n100 << 1\n100 + 0\n1000 which is equal to 8 in the base-10 decimal system\n\n4 << 2\n100 << 2\n100 + 00\n10000 which is equal to 16 in the base-10 decimal system\n#include <iostream>\n\n\nint main() {\n  std::cout << (4 << 1) << \"\\n\"; // Output: 1000 = 8\n  std::cout << (4 << 2) << \"\\n\"; // Output: 10000 = 16\n\n\n  return 0;\n}\n>> Bitwise Right Shift\n\nThe right shift operator shifts all the bits towards the right side by the number of bits specified and discards the right most bits.\n\nFor example:\n\n4 = 100 (base-2 binary system)\n\n4 >> 1\n0 + 100 - 0\n\nIn the example above, 0 is added to the left side of 4 (100 in base-2). Then, the rightmost bit is removed, which yields 10 (base-2) or 2 (base-10).\n\n4 << 2\n00 + 100 + 00\n\nIn the example above, 00 is added to the left side of 4 (100 in base-2). Then, the two rightmost bits are removed, which yields 1 (base-2) or 1 (base-10).\n\n#include <iostream>\n\n\nint main() {\n  std::cout << (4 >> 1) << \"\\n\"; // Output: 10 = 2\n  std::cout << (4 >> 2) << \"\\n\"; // Output: 1 = 1\n\n\n  return 0;\n}\n~ Bitwise Complement\n\nThe complement operator flips the binary digits, that is from 0 to 1 and from 1 to 0.\n\nFor example:\n\n5 = 0000000000000101 in base-2 binary system\n\n~5 = 1111111111111010 in base-2 binary system\n  => -6 in base-10 binary system.\n\nunsigned(5) = 00000000000000000000000000000101 in base-2 binary system\n\n~5 = 11111111111111111111111111111010 in base-2 binary system\n  => 4294967290 in base-10 binary system\n\nThe first bit of a signed integer is used to determine whether the result is positive or negative. Therefore, a signed 5 and an unsigned 5 yield different results.\n\n#include <iostream>\n\n\nint main() {\n  std::cout << (~(int)5) << \"\\n\"; // Output: 1111111111111010 = -6\n  std::cout << (~(unsigned int)5) << \"\\n\"; // Output: 11111111111111111111111111111010 = 4294967290\n\n\n  return 0;\n}\n^ Bitwise XOR\n\nThe exclusive or (XOR) operator returns 1 if both the operands are different and returns 0 if both of them are the same (1, 1 or 0, 0)\n\n12 = 1100 (base-2 binary system)\n10 = 1010 (base-2 binary system)\n\n     1100\n     1010\n     ____\n     0110 which is 6 in base-10 binary system.\n#include <iostream>\n\n\nint main() {\n  std::cout << (12 ^ 10) << \"\\n\";\n\n\n  return 0;\n}\n// Output: 6"},{"title":"Classes","description":"A C++ class is a user-defined data type that encapsulates information and behavior about an object. It serves as a blueprint for future inherited classes.\n\nclass Person {\n\n\n};\nClass Members\n\nA class is comprised of class members:\n\nAttributes, also known as member data, consist of information about an instance of the class.\nMethods, also known as member functions, are functions that can be used with an instance of the class.\nclass City {\n\n\n  // Attribute\n  int population;\n\n\npublic:\n  // Method\n  void add_resident() {\n    population++;\n  }\n\n\n};\nAccess Control Operators\n\nC++ classes have access control operators that designate the scope of class members:\n\npublic members are accessible everywhere.\nprivate members can only be accessed from within the same instance of the class or from friends classes.\nclass City {\n\n\n  int population;\n\n\npublic:\n  void add_resident() {\n    population++;\n  }\n\n\nprivate:\n  bool is_capital;\n\n\n};"},{"title":"Conditionals","description":"Conditionals take an expression, which is code that evaluates to determine a value, and checks if it is true or false. If it’s true, we can tell our program to do one thing — we can even account for false to do another.\n\nAs we write more complex programs, conditionals allow us to address multiple scenarios and make our programs more robust.\n\nIf Statement\n\nAn if statement is used to test an expression for truth.\n\nIf the condition evaluates to true, then the code within the block is executed; otherwise, it will be skipped.\n\nif (a == 10) {\n  // Code goes here\n}\nElse Clause\n\nAn else clause can be added to an if statement:\n\nIf the condition evaluates to true, code in the if part is executed.\nIf the condition evaluates to false, code in the else part is executed.\nif (year == 1991) {\n  // This runs if it is true\n}\nelse {\n  // This runs if it is false\n}\nElse If Statement\n\nOne or more else if statements can be added in between the if and else to provide additional condition(s) to check.\n\nif (apple > 8) {\n  // Some code here\n}\nelse if (apple > 6) {\n  // Some code here\n}\nelse {\n  // Some code here\n}\nCodebyte Example\nSwitch Statement\n\nA switch statement provides a means of checking an expression against various cases. If there is a match, the code within starts to execute. The break keyword can be used to terminate a case.\n\ndefault is executed when no case matches.\n\nswitch (grade) {\n  case 9:\n    std::cout << \"Freshman\\n\";\n    break;\n  case 10:\n    std::cout << \"Sophomore\\n\";\n    break;\n  case 11:\n    std::cout << \"Junior\\n\";\n    break;\n  case 12:\n    std::cout << \"Senior\\n\";\n    break;\n  default:\n    std::cout << \"Invalid\\n\";\n    break;\n}"},{"title":"Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.\n\nSingle-line Comments\n\nSingle-line comments are created using two consecutive forward slashes. The compiler ignores any text after // on the same line.\n\n// This line will denote a comment in C++\nMulti-line Comments\n\nMulti-line comments are created using /* to begin the comment, and */ to end the comment. The compiler ignores any text in between.\n\n/*\nThis is all commented out.\nNone of it is going to run!\n*/\nCodebyte Example\n\nHere’s a program with a multi-line comment and two single-line comments:"},{"title":"Data Types","description":"C++ provides a rather large number of types. However, you can write perfectly good programs using only five of those:\n\nInt\n\nint is a type for storing integer (whole) numbers. An integer typically requires 4 bytes of memory space and ranges from -2³¹ to 2³¹.\n\nint year = 1991;\nint age = 28;\nDouble\n\ndouble is a type for storing floating point (decimal) numbers. Double variables typically require 8 bytes of memory space.\n\ndouble price = 8.99;\ndouble pi = 3.14159;\nBool\n\nbool is a type for storing true or false boolean values. Booleans typically require 1 byte of memory space.\n\nbool organ_donor = true;\nbool late_to_work = false;\nChar\n\nchar is a type for storing individual characters. Characters are wrapped in single quotes ‘. Characters typically require 1 byte of memory space and range from -128 to 127.\n\nchar grade = 'A';\nchar punctuation = '?';\nString\n\nstd::string is a type for storing text strings. Strings are wrapped in double quotes \".\n\nstd::string message = \"good nite\";\nstd::string user = \"@sonnynomnom\";\nDatatype Modifiers\n\nAs the name implies, datatype modifiers are used with built-in data types to modify the length of data that a particular data type can hold. Data type modifiers in C++ are:\n\nsigned\nunsigned\nshort\nlong\nConst\n\nconst (constant) variables cannot be changed by your program during execution.\n\nconst double quarter = 0.25;\n\n\n// and now variable quarter can only be 0.25\n\nSimply add the keyword const before the data type during declaration to make the variable not modifiable.\n\nType Conversion\n\nA type cast is basically a conversion from one type to another.\n\nThe notation (type) value means “convert value to type“. So for example:\n\ndouble weight1;\nint weight2;\n\n\nweight1 = 154.49;\nweight2 = (int) weight1;\n\n\n// weight2 is now 154\n\nNote: Going from a double to an int simply removes the decimal. There’s no rounding involved.\n\nMemory Size\n\nAs noted above, the data type of a variable also specifies the size of the information that it can hold:\n\nData Type\tMemory Size\nbool\t1 byte\nchar\t1 byte\nint\t4 bytes\nfloat\t4 bytes\ndouble\t8 bytes\nstd::string\t24 bytes"},{"title":"Constructors","description":"A constructor is a specially defined method in a C++ class that is automatically called when an instance of that class is created. It is typically used for tasks such as initializing class attributes in a new object. Like with functions, a constructor can take arguments that can aid in the initialization. The arguments are passed to the constructor method when a new object is created.\n\nSyntax and Examples\n\nA constructor method is defined within a class by using the class name followed by parenthesis:\n\nclass MyClass {\n  public:\n    MyClass() {  // This defines a constructor that outputs a message\n      std::cout << \"The constructor was executed!\";\n    }\n};\n\n\nint main() {\n  MyClass myObj;  // This calls the constructor\n  return 0;\n}\n\nUsing arguments in a constructor:\n\nclass Circle {\n  public:\n    int X;\n    int Y;\n    int radius;\n    Circle (int a, int b, int c) {\n      X = a;\n      Y = b;\n      radius = c;\n    }\n};\n\n\nint main() {\n  // Call the constructor using arguments\n  Circle myCircle1(5,5,10);\n  Circle myCircle2(0,0,5);\n\n\n  // Print out the attribute values set for each object\n  std::cout << \"X=\" << myCircle1.X << \", Y=\" << myCircle1.Y << \", radius=\" << myCircle1.radius << \"\\n\";\n  std::cout << \"X=\" << myCircle2.X << \", Y=\" << myCircle2.Y << \", radius=\" << myCircle2.radius << \"\\n\";\n\n\n  return 0;\n}\n\n\n// Output:\n// X=5, Y=5, radius=10\n// X=0, Y=0, radius=5\n\nLike member functions, once declared in the class, the constructor can be defined outside the class:\n\nclass Circle {\n  public:\n    int X;\n    int Y;\n    int radius;\n    // Declare the constructor\n    Circle (int a, int b, int c);\n};\n\n\n// Define constructor outside the class\nCircle::Circle (int a, int b, int c) {\n  X = a;\n  Y = b;\n  radius = c;\n};"},{"title":"Encapsulation","description":"Encapsulation is a way of organizing data members (attributes) and function members (methods) by wrapping them together in a single class. By bundling them together in a single unit, the code is cleaner, more readable, and more maintainable.\n\nclass Example {\n  // Some attributes\n  // Some methods\n}\n\nHere’s a Rectangle class with length and width attributes and a .Area() method:\n\nclass Rectangle {\n  public:\n    int length;\n    int width;\n\n\n    int Area() {\n      return length * width;\n    }\n};\nData Hiding\n\nEncapsulation led to the important OOP concept of data hiding or abstraction.\n\nAccess specifiers are C++ keywords that determine the scope of class components:\n\npublic: Public class members are accessible from anywhere in the program.\nprivate: Private class members are only accessible from inside the class.\n\nData hiding is achieved by declaring class attributes as private:\n\n#include <iostream>\n\n\nclass Encapsulation {\n  private:\n    // Data hidden from outside world\n    int num;\n\n\n  public:\n    // Function to set value of num\n    void setNum(int x) {\n      num = x;\n    }\n\n\n    // Function to return value of num\n    int getNum() {\n      return num;\n    }\n};\n\n\nint main() {\n  Encapsulation obj;\n\n\n  obj.setNum(10);\n\n\n  std::cout << obj.getNum() << \"\\n\"; // Output: 10\n\n\n  return 0;\n}\n\nIn the example above, the num attribute and .setNum() and .getNum() methods are wrapped together into one class called Encapsulation.\n\nnum can only be accessed by either the .setNum() or .getNum() method.\n.setNum() is used to set the value of num.\n.getNum() is used to return the value of num."},{"title":"Enums","description":"In C++, an enumeration (enum) is a user defined type where we specify a set of values for a variable and the variable can only take one out of a small set of possible values.\n\nSyntax\n\nThe keyword enum is used to define an enumeration.\n\nenum name {const1, const2, ...};\n\nHere’s an example:\n\nenum day {sun, mon, tue, wed, thu, fri, sat};\nsun would have the value 0\nmon would have the value 1\ntue would have the value 2\nwed would have the value 3\nthu would have the value 4\nfri would have the value 5\nsat would have the value 6\n\nHere’a another example where one of the constants is assigned a value:\n\nenum grade {freshman=9, sophomore, junior, senior};\n\nThe enumerator freshman is assigned the value 9. Subsequent enumerators, if they are not given an explicit value, receive the value of the previous enumerator plus one.\n\nSo here:\n\nfreshman would have the value 9\nsophomore would have the value 10\njunior would have the value 11\nsenior would have the value 12\nCodebyte Example"},{"title":"Errors","description":"In C++, error messages and their different types help detect and debug issues in the code. Errors can be detected before, during, or after the code has been compiled and executed. Since there are many different errors that could occur, they are classified into groups.\n\nSyntax Errors\n\nSyntax errors occur when there is a syntactical error somewhere in the code, like in the example shown below:\n\nint num = 28 // Error: missing ';'\nLink-Time Errors\n\nA link-time, or linker, error, occurs when the executable for the program cannot be created. This happens when the linker can’t combine all the object files into an executable program.\n\nAn example of this is shown below, where the function peopleReadingThis() is declared but not defined, and calling it generates an error. This is a common ocurrence of the link-time error:\n\nint person = 1;\n\n\nstring peopleReadingThis(int);\n\n\npeopleReadingThis(person); // Error: expecting a definition\n\nAlthough the person variable is a valid argument for peopleReadingThis(), the function’s body was never defined and so calling it causes the error.\n\nRun-Time Errors\n\nAn error that occurs after successful execution of the program is called a run-time error. This can happen when excessive memory is used.\n\nint people = 293049858920384839904; // Error: overflow\n\nOr, when trying to divide by 0:\n\nint divideByZero = 22/0; // Error: division by zero\nLogic Error\n\nWhen a program doesn’t yield expected results, it is often due to a logic error. These kind of errors can only be found by the programmer or code reviewer.\n\nThe following example should print Someone is reading this when person is set to one or greater. Otherwise, it should print Not a single person is reading this:\n\nint person = 1;\nif (person > 1) {\n  std::cout << \"Someone is reading this\";\n}\nelse {\n  std::cout << \"Not a single person is reading this\";\n}\n\nOutput:\n\nNot a single person is reading this\n\nThe example above does not generate any errors. But, it doesn’t give the correct answer. In order for this to yield the correct result, the > symbol needs to be a `>=’ symbol."},{"title":"Files","description":"Computers use file systems to store and retrieve data. Each file is an individual container of related information.\n\nThe fstream library, short for “file stream”, allows us to work with files in C++. To use the fstream library in the C++ program, include both the standard <iostream> and the <fstream> header files in the C++ program:\n\n#include <iostream>\n#include <fstream>\n\nThere are three classes included in the fstream library, which are used to create, write or read files:\n\nofstream (“output file stream”): Create files and write to files.\nifstream (“input file stream”): Read from files.\nfstream: A combination of ofstream and ifstream (create, read, and write to files).\nCreate and Write to a File\n\nTo create a file, use either the ofstream or fstream class, and specify the name of the file.\n\nTo write to the file, use the insertion operator (<<). For example:\n\n#include <iostream>\n#include <fstream>\n\n\nint main() {\n  // Create and open a text file\n  std::ofstream MyFile(\"journal.txt\");\n\n\n  // Write to the file\n  MyFile << \"Today is the greatest\\n\";\n  MyFile << \"Day I've ever known\";\n\n\n  // Close the file\n  MyFile.close();\n}\n\nIn the same folder, there should be a new text file called journal.txt. There should be two lines of text inside:\n\nToday is the greatest\nDay I've ever known\nRead a File\n\nTo read from a file, use either the ifstream or fstream class, and the name of the file.\n\nNote that we also use a while loop together with the getline() function (which belongs to the ifstream class) to read the file line by line, and to print the content of the file:\n\n#include <iostream>\n#include <fstream>\n\n\nint main() {\n  // Create a text string, which is used to output the text file\n  std::string myText;\n\n\n  // Read from the text file\n  std::ifstream MyReadFile(\"journal.txt\");\n\n\n  // Output the file line by line\n  while (getline (MyReadFile, myText)) {\n    std::cout << myText << \"\\n\";\n  }\n\n\n  // Close the file\n  MyReadFile.close();\n}\n\nThe output would be:\n\nToday is the greatest\nDay I've ever known"},{"title":"Exceptions","description":"In C++, an exception is the computer’s response to a problem that occurs while executing a program’s code. The computer will create an exception, and if the code does not have a way to handle it, then the program will stop executing due to the error.\n\nCatching an Exception\n\nThe function getString() as defined below will throw an exception if you try to access an index outside the allowable bounds.\n\nErrors, when uncaught, will cause your program to immediately stop. This behavior can be prevented by wrapping the code which might emit an error in a try block, and providing at least one catch block to execute if the code throws the error. Look at the improvement below:\n\nThe parenthesized ellipsis above indicate that the catch should try to catch any and all errors. It is possible be more specific by replacing the ellipsis with the error type that would be thrown for common inputs:\n\ncatch (std::length_error) would catch the specific error that will be thrown\ncatch (std::length_error errorName) would not only catch the same error, but give us access to the error object inside the catch block with the variable errorName\n\nIt is possible to catch multiple types of exception by specifying multiple catch blocks:\n\nint main() {\n  try {\n    // Code goes here\n  }\n  catch (int intErrorVariable) {\n    // The thrown error was of type int\n  }\n  catch (std::exception exceptionVariable) {\n    // The thrown error was of type exception\n    std::cout << exceptionVariable.what();\n  }\n  catch (...) {\n    // The ellipsis\n  }\n}\n\nThis example also names the exceptions so that you might access the exception during the catch block. If the exception is of type std::exception (or one of the classes which inherit from it), you can call .what() on the caught exception to read the error message.\n\nThrowing an Exception\n\nWhile one side of the exceptional coin is catching exceptions, the other side is throwing them. Since user input is often unpredictable, it is important to handle bad data with grace.\n\nThe sqrt() funciton provided by the math.h library calculates square roots, however it will return nan for the square root of negative numbers. The example below creates a custom mySqrt() function so that an execption is thrown when a negative number is passed in as a parameter. This allows us to catch it in our main block rather than testing if the returned valued is equal to nan.\n\nWhile it is possible to use throw with many data types, it is common to throw a runtime error. The syntax can be seen in the example below:\n\nThis program will run, and output the following:\n\nSquare root of 4.41 is 2.1\nERROR: Negative numbers not allowed"},{"title":"Functions","description":"A function is a set of statements that are executed together when the function is called. Every function has a name, which is used to call the respective function.\n\nBuilt-in Functions\n\nC++ has many built-in functions. In order to use them, we have to import the required library using #include.\n\nHere we are getting a function named sqrt() from the <cmath> library:\n\n#include <iostream>\n#include <cmath>\n\n\nint main() {\n  std::cout << sqrt(10);\n  // Output: 3.16228\n}\nFunction Declaration & Definition\n\nA C++ function has two parts:\n\nFunction declaration\nFunction definition\n\nThe declaration includes the function’s name, return type, and any parameters.\n\nThe definition is the actual body of the function which executes when a function is called. The body of a function is typically enclosed in curly braces.\n\n#include <iostream>\n\n\n// Function declaration\nvoid blah();\n\n\n// Main function\nint main() {\n  blah();\n}\n\n\n// Function definition\nvoid blah() {\n  std::cout << \"Blah blah\";\n}\nVoid Functions\n\nIn C++, if we declare the type of a function as void, it does not return a value. These functions are useful for a set of statements that do not require returning a value.\n\n#include <iostream>\n\n\nvoid print() {\n  std::cout << \"Hello World!\";\n}\n\n\nint main() {\n  print();\n}\nReturn Values\n\nA function that returns a value must have a return statement. The data type of the return value also must match the method’s declared return type.\n\nOn the other hand, a void function (one that does not return anything) does not require a return statement.\n\n#include <iostream>\n\n\nint sum(int a, int b);\n\n\nint main() {\n  int r = sum(10, 20);\n  std::cout << r;\n}\n\n\nint sum(int a, int b) {\n  return(a + b);\n}\nFunction Declarations in Header File\n\nC++ functions typically have two parts: declaration and definition.\n\nFunction declarations are generally stored in a header file (.hpp or .h) and function definitions (body of the function that defines how it is implemented) are written in the .cpp file.\n\nmain.cpp\n#include <iostream>\n#include \"functions.hpp\"\n\n\nint main() {\n\n\n  std::cout << say_hi(\"Sabaa\");\n\n\n}\nfunctions.hpp\n// Function declaration\nstd::string say_hi(std::string name);\nfunctions.cpp\n#include <string>\n#include \"functions.hpp\"\n\n\n// Function defintion\nstd::string say_hi(std::string name) {\n\n\n  return \"Hey there, \" + name + \"!\\n\";\n\n\n}\nFunction Arguments\n\nIn C++, the values passed to a function are known as arguments. They represent the actual input values.\n\n#include <iostream>\n\n\nvoid print(int);\n\n\nint main() {\n  print(10);\n  // The argument 10 is received as input value\n}\n\n\n// Parameter a is defined for the function print\nvoid print(int a) {\n  std::cout << a;\n}"},{"title":"Inheritance","description":"Inheritance is the ability to create a new class based on an existing class, starting out with the same existing properties and methods. It is generally used when it’s necessary to implement a number of different objects that are all of the same type and share several common characteristics.\n\nSyntax\n\nThe class that inherits these properties and methods is called the derived class or sub-class. The class that the sub-class inherits from is called the base class.\n\nclass BaseClass {\n  accessModifier:\n    dataType property1;\n    dataType property2;\n};\n\nclass SubClass: public BaseClass {\n  accessModifier:\n    dataType subProp1;\n    dataType subProp2;\n};\nAccess Specifiers\npublic members of the base class are public in the derived class.\nprotected members of the base class are accessible by the derived class, but not outside the class.\nprivate members of the base class aren’t accessible to the derived class.\nExample\n\nA good example is a Shape class that might include:\n\nA center property with (x, y) coordinates.\nA weight property that defines a line width.\nA color property that would define a fill color.\nA translate method that relocates the center property.\n\nSome possible sub-classes derived from this base class might be:\n\nA Rectangle class which would have height and width properties. It could also have its own perimeter method.\nA Circle class that would have a radius property. It could also have its own circumference method.\n\nBoth the Circle and Rectangle classes would share the properties and methods of their base class, Shape, in addition to properties and methods unique to their own class definition.\n\n// Create the base Shape class\nclass Shape {\n  public:\n    int center[2];\n    int weight;\n    int color;\n\n\n    void translate(int deltaX, int deltaY) {\n      center[0] += deltaX;\n      center[1] += deltaY;\n    }\n};\n\n\n// Create sub-class Rectangle\nclass Rectangle: public Shape {\n  public:\n    int height;\n    int width;\n\n\n    int perimeter() {\n      return (height + width) * 2;\n    }\n};\n\n\n// Create sub-class Circle\nclass Circle: public Shape {\n  public:\n    int radius;\n\n\n    float circumference() {\n      return 2.0 * 3.1416 * float (radius);\n    }\n};"},{"title":"Loops","description":"A loop can execute a statement or group of statements multiple times and the following is the general from of a loop statement in most programming languages.\n\nWhile Loop\n\nA while loop statement repeatedly executes the code block within as long as the condition is true. The moment the condition becomes false, the program will exit the loop.\n\nNote that the while loop might not ever run. If the condition is false initially, the code block will be skipped.\n\nwhile (password != 1234) {\n\n\n  std::cout << \"Try again: \";\n  std::cin >> password;\n\n\n}\nFor Loop\n\nA for loop executes a code block a specific number of times. It has three parts:\n\nThe initialization of a counter\nThe continue condition\nThe increment/decrement of the counter\n\nThis example prints 0 to 9 on the screen:\n\nfor (int i = 0; i < 10; i++) {\n\n\n  std::cout << i << \"\\n\";\n\n\n}"},{"title":"Math Functions","description":"C++ has many functions that allows you to perform mathematical tasks on numbers.\n\nHeader <cmath> declares a set of functions to compute common mathematical operations and transformations:\n\n// Include the cmath library\n#include <cmath>\n\n\nstd::cout << sqrt(64);    // Return the square root of 64\nstd::cout << log(2);      // Return the log of 2\nstd::cout << round(2.6);  // Round 2.6\n\nA list of other popular math functions from the <cmath> library can be found in the table below:"},{"title":"Methods","description":"C++ class methods are user-defined functions that can be used within an instance of the class. We use a dot notation . before method names to distinguish them from regular functions.\n\nClass Methods\n\nA class method can be defined in two ways:\n\nInside the class definition\nOutside the class definition\nInside the Class\nclass Person {\n  string name;\n\n\n  public:\n  // Defines the method\n  void get_name() {\n    return name;\n  }\n}\n\n\nint main() {\n  Person robert;\n\n\n  // Calls the method\n  robert.get_name();\n\n\n  return 0;\n}\nOutside the Class\nclass Person {\n  string name;\n\n\n  public:\n    void get_name();\n}\n\n\n// Defines the method\nvoid Person::get_name() {\n  return name;\n}\n\n\nint main() {\n  Person robert;\n\n\n  // Calls the method\n  robert.get_name();\n\n\n  return 0;\n}\n\nParameters can also be added to class methods:\n\nclass Person{\n  string name;\n\n\n  public:\n\n\n  // Defines the method\n  void set_name(string newName){\n    name = newName;\n  }\n\n\n  void get_name() {\n    return name;\n  }\n}\n\n\nint main() {\n  Person robert;\n\n\n  // Sets the name class memeber\n  robert.set_name(\"Robert\");\n\n\n  // Prints \"Robert\"\n  std::cout << robert.get_name();\n\n\n  return 0;\n}"},{"title":"Objects","description":"In C++, an object is an instance of a class that encapsulates data and functionality pertaining to that data.\n\nSuppose we have already created a class named MyClass, so now we can use it to create objects.\n\nTo create an object of MyClass, specify the class name, followed by the object name.\n\nCity nyc;      // Used the City class to create an object named nyc\nCity shanghai; // Used the City class to create an object named shanghai\n\nTo access the class attributes, use the dot syntax (.) on the object:\n\nCreate an object called myObj and access the attributes:\n\nclass MyClass {\n  public:\n    int myNum;\n    std::string myString;\n};\n\n\nint main() {\n  // Create an object of MyClass\n  MyClass myObj;\n\n\n  // Access attributes and set values\n  myObj.myNum = 15;\n  myObj.myString = \"Some text\";\n\n\n  // Print attribute values\n  std::cout << myObj.myNum << \"\\n\";\n  std::cout << myObj.myString;\n\n\n  return 0;\n}\nCodebyte Example"},{"title":"Pointers","description":"A pointer is a special type of variable that stores the address of another variable in it.\n\nDeclaration and Initialization of Pointer variable\n\nA pointer variable points to the same data type and is created with the * operator. Then the address of another variable is stored in it.\n\nstd::string game = \"Cricket\";\n\n\n// A pointer with the name ptr, that stores the address of game\nstd::string* ptr = &game;\n\n\nstd::cout << game << \"\\n\";   // Output: Cricket\nstd::cout << &game << \"\\n\";  // Output of game memory address: 0x6dfed4\nstd::cout << ptr << \"\\n\";    // Output of pointer to game: 0x6dfed4\nPointer Dereferencing\n\nDereferencing a pointer means getting the value that a pointer variable is pointing at.\n\nThe dereference operator * is used to get the value stored in the memory location pointed by the pointer:\n\nstd::string game = \"Cricket\";  // Variable declaration\nstd::string* ptr = &game;    // Pointer declaration\n\n\nstd::cout << *ptr << \"\\n\"; // Output of value dereferenced from ptr: Cricket"},{"title":"Operators","description":"Arithmetic Operators\n\nC++ supports different types of arithmetic operators that can perform common mathematical operations:\n\n+ addition\n- subtraction\n* multiplication\n/ division\n% modulo (yields the remainder)\nint x = 0;\n\n\nx = 4 + 2;  // x is now 6\nx = 4 - 2;  // x is now 2\nx = 4 * 2;  // x is now 8\nx = 4 / 2;  // x is now 2\nx = 4 % 2;  // x is now 0\nRelational Operators\n\nRelational operators are used to compare two values and return true or false depending on the comparison:\n\n== equal to\n!= not equal to\n> greater than\n< less than\n>= greater than or equal to\n<= less than or equal to\nif (a > 10) {\n   // ☝️ means greater than\n}\nLogical Operators\n\nLogical operators can be used to combine two different conditions.\n\n&& requires both to be true (and)\n|| requires either to be true (or)\n! negates the result (not)\nif (coffee > 0 && donut > 1) {\n  // Code runs if both are true\n}\n\n\nif (coffee > 0 || donut > 1) {\n  // Code runs if either is true\n}\n\n\nif (!tired) {\n  // Code runs if tired is false\n}"},{"title":"Random","description":"C++ has a std::rand() function from cstdlib library that generates a random number.\n\nFor example, if we add #include <cstdlib>, we can use the std::rand() function:\n\nstd::cout << std::rand() << \"\\n\";\nstd::cout << std::rand() << \"\\n\";\nstd::cout << std::rand() << \"\\n\";\n\nIt would output something like:\n\n1804289383\n846930886\n1681692777\nUsing Modulo\n\nA lot of the times, we don’t just want any random number. Suppose We want a random number from 0-9.\n\nint answer = std::rand() % 10;\n\nThe % is the modulo symbol that returns the remainder.\n\nSeeding the Random Number Generator\n\nFor our program to work, we need to get a different random number for each execution.\n\nTo do so, we need to add this line of code before the declaration of answer:\n\nsrand(time(NULL));\n\nThis sets the “seed” of the random number generator.\n\nCodebyte Example"},{"title":"Polymorphism","description":"Polymorphism is an important concept in object-oriented programming. It means “more than one form” — the same entity (function or operator) can operate differently under different situations.\n\nThere are two types of polymorphism in C++:\n\nCompile-time polymorphism: This is also called static (or early) binding.\nRuntime polymorphism: This is also called dynamic (or late) binding.\nCompile-time Polymorphism\n\nCompile-time polymorphism is perfect for function overloading as well as operator overloading.\n\nIn the example below, there are two functions with the same name, sum(), but a different number of arguments.\n\nThe number of parameters we pass during function invocation (function calling) determines which function to be called. This is why it is considered as an example of polymorphism because the output is different in different conditions. Since the call is determined during compile time, it is called compile-time polymorphism.\n\n#include <iostream>\n\n\nclass Add {\n  public:\n    // sum() with 2 parameters\n    int sum(int num1, int num2) {\n      return num1 + num2;\n    }\n\n\n    // sum() with 3 parameters\n    int sum(int num1, int num2, int num3) {\n      return num1 + num2 + num3;\n    }\n};\n\n\nint main() {\n  // Create object of Add class\n  Add obj;\n\n\n  // This will call the first variant of the sum() function\n  std::cout << \"Output: \" << obj.sum(10, 20) << \"\\n\";\n\n\n  // This will call the second variant of the sum() function\n  std::cout << \"Output: \" << obj.sum(11, 22, 33) << \"\\n\";\n\n\n  return 0;\n}\n\nThe output would look like:\n\nOutput: 30\nOutput: 66\nRuntime Polymorphism\n\nFunction overriding is an example of runtime polymorphism.\n\nWhen a child class declares a method that is already present in the parent class, it is called function overriding because the child class overrides the parent class.\n\nIn the case of function overriding, we have two definitions of the same function, one in the parent class and one in the child class. Since the call to the function is determined at runtime to decide which definition of the function is to be called, it is called runtime polymorphism.\n\n#include <iostream>\n\n\nclass A {\n  public:\n    void print() {\n      std::cout << \"Output: Parent Class Function\" << \"\\n\";\n    }\n};\n\n\nclass B: public A {\n  public:\n    void print() {\n      std::cout << \"Output: Child Class Function\" << \"\\n\";\n    }\n};\n\n\nint main() {\n  // Parent class object\n  A obj1;\n  obj1.print();\n\n\n  // Child class object\n  B obj2;\n  obj2.print();\n\n\n  return 0;\n}\n\nThe output would look like:\n\nOutput: Parent Class Function\nOutput: Child Class Function"},{"title":"Sets","description":"Sets are associative containers which store unique elements that can be referenced by an element’s value. The value, which is itself the key to access an element in the set, is constant. Once assigned it cannot be changed. However, existing values can be removed or new values can be added.\n\nSyntax\nstd::set<dataType> setName;\n\nA set can be created by using the set keyword and declaring a data type and name.\n\nExample\n\nThe example below initiates a set, inserts values into it using the .insert() method, and then prints out the set:\n\n#include <iostream>\n#include <set>\n\n\nint main(){\n  // Initiate set\n  std::set<int> numSet;\n\n\n  // Insert values into set\n  numSet.insert(25);\n  numSet.insert(42);\n  numSet.insert(10);\n  numSet.insert(19);\n\n\n  // Print out set\n  std::set<int> :: iterator iter;\n  for(iter = numSet.begin(); iter != numSet.end(); iter++)\n  {\n  std::cout<< *iter << \" \";\n  }\n}\n\nThis outputs the following:\n\n10 19 25 42\n\nBy default, values of the set are sorted in ascending order.\n\nSetting a Different Comparison Function\n\nThe comparison function can be changed from the default to std::greater<dataType> in order to sort the values in descending order.\n\nSyntax\nstd::set<dataType, std::greater<dataType> > setName;\n\nThe dataType for the comparison function must match the data type of the set.\n\nCodebyte Example\n\nSetting the previous example’s comparison function to std::greater<int>:"},{"title":"References","description":"A reference variable is an alias for another object. It is created using the & sign.\n\nTwo things to note:\n\nAnything done to the reference also happens to the original.\nAliases cannot be changed to alias something else.\nSyntax\nint &sonny = songqiao;\nPass-By-Reference\n\nIn C++, pass-by-reference refers to passing parameters to a function by using references.\n\nIt allows the ability to:\n\nModify the value of the function arguments.\nAvoid making copies of a variable/object for performance reasons.\n\n\nvoid swap_num(int &i, int &j) {\n  int temp = i;\n  i = j;\n  j = temp;\n}\n\n\nint main() {\n  int a = 100;\n  int b = 200;\n\n\n  swap_num(a, b);\n\n\n  std::cout << \"A is \" << a << \"\\n\";\n  std::cout << \"B is \" << b << \"\\n\";\n}\nconst Reference\n\nIn C++, pass-by-reference with const can be used for a function where the parameter(s) won’t change inside the function.\n\nThis saves the computational cost of making a copy of the argument.\n\nint triple(int const &i) {\n  return i * 3;\n}"},{"title":"Strings","description":"Strings are objects that represent sequences of characters. In C++, there are two ways to create strings: string class or using C-style character strings.\n\nString Class\n\nThe standard string class provides support for strings in C++.\n\nstd::string welcome = \"Hi\";\nstd::string user_name = \"@sonny\";\nstd::string message = \"Good nite! 😇\";\nC-Style Character Strings\n\nThe C-style character string originated from the C language and continues to be supported within C++.\n\nIn C, the string is actually an array of characters, followed by a null character '\\0'.\n\nchar message[] = \"Howdy\";\n\nSo here’s the memory presentation:\n\nCharacter |   'H'    'o'    'w'    'd'    'y'   '\\0'\nIndex     |    0      1      2      3      4      5\nAddress   |  23451  23452  23453  23454  23455  23456"},{"title":"Smart Pointers","description":"A smart pointer is a class that holds and manages a pointer through a popular C++ technique called “Resource Acquisiton is Initialization” (RAII). It allows developers to not worry about freeing a pointer, and it also allows pointers to be exception-safe.\n\nOwnership\n\nWhen refering to memory, ownership answers the question: “Who is in charge of freeing the given resource?”\n\nThere are three standard smart pointers defined in the <memory> header file:\n\nstd::unique_ptr<T> A unique pointer does not share ownership, and will free the resource at the end of the scope.\nstd::shared_ptr<T> A shared pointer does share ownership, and will only free the resource when there are no other owners counted and it has reached the end of the scope.\nstd::weak_ptr<T> A weak pointer is used with a shared pointer, but it does not add to the reference counter like a shared pointer does.\n\nBoth unique_ptr and shared_ptr have a corresponding function to create their respective pointers:\n\nstd::make_unique<T>(value) for unique_ptr\nstd::make_shared<T>(value) for shared_ptr\nUnique Pointers\nint main() {\n  auto ptr = std::make_unique<int>(10);\n} // The ptr reaches end of scope, no memory leaks\nShared Pointers\nint main() {\n  auto ptr = std::make_shared<int>(10);\n\n\n  std::cout << ptr.use_count() << \"\\n\"; // Prints the reference count (1)\n  {\n    auto ptr2 = ptr1; // Reference count is now 2\n    std::cout << ptr2.use_count() << '\\n'; // Prints the reference count (2)\n  } // The ptr2 reaches end of scope, reference count is 1 so resource not freed\n\n\n  std::cout<< *ptr << \"\\n\";\n} // The ptr reaches end of scope, reference count is 0 so resource is freed\nException Safety\nvoid unsafe_pointer() {\n  int* ptr = new int(10);\n  if (*ptr == 10) {\n    throw;\n  }\n  delete ptr; // The ptr not freed because the function throws beforehand\n}\n\n\nvoid safe_pointer() {\n  auto ptr = std::make_unique<int>(10);\n  if (*ptr == 10) {\n    throw;\n  }\n} // The ptr freed because destructors are called automatically when leaving scope"},{"title":"Structures","description":"A structure in C++ stores together data elements under a single name. The data elements, also called data memebers, can be of different data types.\n\nSyntax\n\nA structure is defined with:\n\nThe struct keyword in the beginning.\nCurly brackets { } to define the body.\nA semicolon ; at the end.\nstruct name {\n  member1_type member1_name;\n  member2_type member2_name;\n  member3_type member3_name;\n};\nExample\n\nThe example below is a struct with the name coder:\n\nstruct coder {\n  long id;\n  char name[30];\n  char username[15];\n};\n\nThis structure contains three members:\n\nid\nname\nusername\nDeclaring and Initializing Structure Variables\n\nThe members of a structure can be initialized inside the structure definition in C++11 and higher.\n\nAn example of declaring and initializing a structure variable:\n\n#include <iostream>\n\n\nstruct coordinates {\n  int x;\n  int y;\n};\n\n\nint main() {\n\n\n  // Declaring variable c1\n  struct coordinates c1;\n\n\n  c1.x = 2;\n  c1.y = 2;\n\n\n  // Declaring and initializing variable c2\n  struct coordinates c2 = { 0, 1 };\n\n\n  std::cout << \"x1 = \" << c1.x << \", y1 = \" << c1.y << \"\\n\"; // For variable c1\n  std::cout << \"x2 = \" << c2.x << \", y2 = \" << c2.y << \"\\n\"; // For variable c2\n\n\n  return 0;\n}\n\nThe output will look like this:\n\nx1 = 2, y1 = 2\nx2 = 0, y2 = 1\nArray of Structure\n\nLike other primitive data types, we can create an array of structures.\n\nAn example of array of structure:\n\n#include <iostream>\n\n\nstruct coordinates {\n  int x;\n  int y;\n};\n\n\nint main() {\n  struct coordinates c[4];\n  int i;\n\n\n  for (i = 0; i < 4; i++)\n    std::cin >> c[i].x >> c[i].y;\n\n\n  for (i = 0; i < 4; i++) {\n    std::cout << \"x\" << i+1 << \"=\" << c[i].x << \"\\t\";\n    std::cout << \"y\" << i+1 << \"=\" << c[i].y << \"\\n\";\n  }\n\n\n  return 0;\n}\n\nInput:\n\n1 0\n1 2\n1 1\n0 2\n\nOutput:\n\nx1 = 1  y1 = 0\nx2 = 1  y2 = 2\nx3 = 1  y3 = 1\nx4 = 0  y4 = 2\nNested Structure\n\nA structure’s variable can also be a member of, or nested in, another structure.\n\nIn the example below, a DOB structure is nested in a coder structure:\n\nstruct coder {\n  long id;\n  char name[30];\n  char username[15];\n  struct DOB {\n    int month;\n    int day;\n    int year;\n  } d;\n} bjarne;\n\nThe d is the structure’s variable for struct DOB and bjarne is the structure variable for struct coder.\n\nMembers of a nested structure can be accessed using var1.var2.member1.\n\nInitializing a member of the structure DOB from the example above:\n\nbjarne.d.day = 10;"},{"title":"Switch","description":"A switch statement provides a means of checking an expression against various case statements. If there is a match, the code within starts to execute. The break keyword can be used to terminate a case.\n\nThere’s also an optional default statement marking code that executes if none of the case statements are true.\n\nSyntax\n\nA switch statement looks like:\n\nswitch (grade) {\n  case 9:\n    std::cout << \"Freshman\\n\";\n    break;\n  case 10:\n    std::cout << \"Sophomore\\n\";\n    break;\n  case 11:\n    std::cout << \"Junior\\n\";\n    break;\n  case 12:\n    std::cout << \"Senior\\n\";\n    break;\n  default:\n    std::cout << \"Invalid\\n\";\n    break;\n}\nThe switch keyword initiates the statement and is followed by (), which contains the value that each case will compare. In the example, the value or expression of the switch statement is grade. One restriction on this expression is that it must evaluate to an integral type (int, char, short, long, long long, or enum).\nInside the block, {}, there are multiple cases.\nThe case keyword checks if the expression matches the specified value that comes after it. The value following the first case is 9. If the value of grade is equal to 9, then the code that follows the : would run.\nThe break keyword tells the computer to exit the block and not execute any more code or check any other cases inside the code block.\nAt the end of each switch statement, there is a default statement. If none of the cases are true, then the code in the default statement will run.\n\nIn the code above, suppose grade is equal to 10, then the output would be “Sophomore”.\n\nNote: Without the break keyword at the end of each case, the program would execute the code for the first matching case and all subsequent cases, including the default code. This behavior is different from if/else conditional statements which execute only one block of code.\n\nCodebyte Example"},{"title":"Variables","description":"A variable refers to a storage location in the computer’s memory that one can set aside to save, retrieve, and manipulate data.\n\nDeclare a Variable\n\nTo create a variable, you must specify the type and assign it a value:\n\ntype name = value;\n\nSo to create a variable called score of type int and assign it the value 0:\n\nint score = 0;\nDisplay Variables\n\nThe std::cout object is used together with the << operator to display variables.\n\nTo combine both text and a variable, separate them with the << operator:\n\nint myAge = 30;\n\n\nstd::cout << \"I am \" << myAge << \" years old.\";\n\nThe output would be:\n\nI am 30 years old.\nCodebyte Example"},{"title":"User Input","description":"std::cin, which stands for “character input”, reads user input from the keyboard.\n\nSyntax\nstd::cin >> variable;\n\nHere, the user can enter a value in the terminal, press enter, and that number will get stored in the variable.\n\nExample\n\nIn this example, the program will prompt the user to enter a number with \"Enter amount: \". Then the user can enter a number, press enter, and that number will get stored in the variable tip.\n\n#include <iostream>\n\n\nint main() {\n\n\n  int tip = 0;\n\n\n  std::cout << \"Enter amount: \";\n  std::cin >> tip;\n\n\n  std::cout << \"You gave a tip of $\" << tip << \"\\n\";\n\n\n}"},{"title":"Vectors","description":"A vector is a dynamic list of items, that can shrink and grow in size. It can only store values of the same type.\n\nDifferent Ways to Create a Vector\n\nTo use vectors, it is necessary to #include the vector library.\n\n#include <vector>\n\nDuring the creation of a C++ vector, the data type of its elements must be specified. Once the vector is created, the type cannot be changed.\n\nstd::vector<type> name;\nCreate a Vector with Size\nstd::vector<int> grades(10);\nCreate and Intitialize a Vector\nstd::vector<double> order = {3.99, 12.99, 2.49};\nIndex\n\nAn index refers to an element’s position within an ordered list, like a vector or an array. The first element has an index of 0.\n\nA specific element in a vector or an array can be accessed using its index, like name[index].\n\nstd::vector<double> order = {3.99, 12.99, 2.49};\n\n\n// What's the first element?\nstd::cout << order[0];\n\n\n// What's the last element?\nstd::cout << order[2];\nAdding Elements\n\nThere are two different ways to insert elements into the vector.\n\n.push_back()\n\nThis method pushes elements to the back of a vector.\n\nstd::vector<int> v = {1,2,3,4};\n\n\nv.push_back(5);\n\n\nint n = v.size();\n\n\nstd::cout << \"The last element is: \" << v[n - 1];\n// Output: The last element is: 5\n.insert()\n\nThis method inserts new elements before the element at the specified position.\n\nstd::vector<int> v = {1,2,3,4};\n\n\n// Insert at beginning\nv.insert(v.begin(), 0);\n\n\n// Insert at end\nv.insert(v.end(),6);\n\n\nstd::cout << \"The first element is: \" << v[0] << \"\\n\";\n// Output: The first element is: 0\nstd::cout << \"The last element is: \" << v[5] << \"\\n\";\n// Output: The last element is: 6\nCodebyte Example\n\nTo create a vector named grade with 3 items and then insert elements to the last of the vector using .push_back() and .insert() functions :"}],"CSS":[{"title":"Anatomy","description":"The anatomy of CSS style syntax applies to the two methods of incorporating CSS into a web-page:\n\nRulesets: A ruleset is defined within either the HTML document itself, or in one or more separate files (known as stylesheets) that use the .css extension.\n\nInline styles: An inline style is set in a style attribute and applies to individual HTML elements directly.\n\nWhile inline styles are directly applied to a single element, rulesets can define multiple styles across multiple elements. Another key difference between the two is that a ruleset can utilize id and class selectors to identify targeted elements, as well as designating children of specific parent-elements.\n\nInline styles are commonly used for situations such as the following:\n\nThe style being applied in the markup is unique and won’t be repeated.\nThe HTML markup is dynamically generated and the CSS stylesheet is static.\nOther situations where it isn’t advisable (or possible) to edit the stylesheet(s) for a page.\nSyntax\n\nRulesets use the following syntax for selecting and styling any and every instance of an existing element:\n\n/* Start of Ruleset */\nselector:pseudo-class::pseudo-element {\n\n  /* Declaration */\n  property: value-or-keyword;\n\n}\n/* End of Ruleset */\n\nConversely, inline styles apply a visually-similar syntax to a single element:\n\n<element style=\"property:value;\">Hello World!</element>\nAnatomy\n\nThere are several parts to the CSS in both the ruleset and the inline-style:\n\nIn the ruleset example above, the initial p is a selector that can be applied to any and every valid instance of that element. Selectors possess a wide range of specificity, including:\n\nGeneral selection by HTML element name.\nSpecific class and id selectors for elements.\nPseudo-class and pseudo-element selectors.\nReserved keyword rules like !important and @media.\n\nNext in the ruleset syntax is the block of declarations between the two braces {...}. This is the block of code that defines the style that will be applied. This is equivalent to the style attribute value in the inline-style example.\n\nThe declaration block, or attribute value, is made up of one or more declarations. In the examples, color:blue; is a declaration. A declaration is made up of a CSS property name, followed by a colon (color:) then a value, followed by a semicolon, (blue;).\n\nFor either syntax, there can be an arbitrary number of declarations. While whitespace has no effect, ruleset declarations are usually set on their own lines while inline style declarations are all placed on the same line."},{"title":"Animations","description":"A CSS animation lets an HTML element gradually change from one style to another, without using JavaScript. Any number of CSS properties can be changed, for any amount of times.\n\nTo use CSS animation, some keyframes for the animation must be specified.\n\n@keyframes Rule\n\nKeyframes hold what CSS styles the element will have at certain times. When specifying styles inside the @keyframes rule, the animation will gradually change from the current style(s) to the new style(s).\n\nTo get an animation to work, the animation must be bound to an element and the animation-duration should be defined. In this example code, the <h1> element will load as purple and gradually change to yellow over the course of 5 seconds.\n\n/* The animation */\n@keyframes color-change {\n  from {\n    color: purple;\n  }\n  25% {\n    color: orange;\n  }\n  50% {\n    color: red;\n  }\n  75% {\n    color: blue;\n  }\n  to {\n    color: yellow;\n  }\n}\n\n\n/* The element */\nh1 {\n  color: purple;\n  animation-name: color-change;\n  animation-duration: 5s;\n}"},{"title":"Borders","description":"A border is a line that surrounds an element, like a frame around a painting.\n\nBorders can be set with a specific width, style, and color:\n\nwidth: The thickness of the border. A border’s thickness can be set in pixels or with one of the following keywords: thin, medium, or thick.\nstyle: The design of the border. Web browsers can render any of 10 different styles. Some of these styles include: none, dotted, and solid.\ncolor: The color of the border. Web browsers can render colors using a few different formats, including 140 built-in color keywords.\np {\n  border: 3px solid coral;\n}\n\nIn the example above, the border has a width of 3 pixels, a style of solid, and a color of coral. All three properties are set in one line of code.\n\nThe default border is medium none color, where color is the current color of the element. If width, style, or color are not set in the CSS file, the web browser assigns the default value for that property.\n\np.content-header {\n  height: 80px;\n  width: 240px;\n  border: solid coral;\n}\n\nIn this example, the border style is set to solid and the color is set to coral. The width is not set, so it defaults to medium."},{"title":"Background","description":"The CSS background properties are used to add background wallpaper visuals for HTML elements."},{"title":"Box Model","description":"The Box Model is a CSS layout mechanism that the web browser uses to render content organized by box-shaped elements. Each element is made of four specific areas:\n\nwidth and height: The width and height of the content area.\npadding: The amount of space between the content area and the border.\nborder: The thickness and style of the border surrounding the content area and padding.\nmargin: The amount of space between the border and the outside edge of the element.\n\nContent Area\n\nThis area contains the actual content of an element, including text and images. It also sometimes has a background-color or background-image.\n\nPadding Area\n\nThis area is located between the content and border areas. It can be changed on the top, right, bottom and left sides.\n\nBorder Area\n\nThis area is located between the margin and padding areas. Their thickness and style can be changed.\n\nMargin Area\n\nThis is the outermost area in the Box Model. It borders with the margin areas of neighboring elements. It can be changed on the top, right, bottom and left sides."},{"title":"Box Sizing","description":"The box-sizing property allows us to include the padding and boarder in the calculation of an element’s height and width. This is a slightly more advanced so no need to use it if you are just getting started to code.\n\nSyntax\nbox-sizing: <value>;\n\nThe box-sizing property has two values.\n\nborder-box: Any assigned padding or border is included in the calculation of an elements height or width. If an elements width is set to 100px and padding is set to 30px, the padding will be included in the elements set width resulting in the total width still being 100px.\ncontent-box: Default CSS behavior, the assigned height or width of an element plus any padding will be the total height or weight. If an elements width is set to 100px and padding is set to 50px, the total width for the element will be 150px.\nExample 1\n\nSetting a div elements box-sizing to border-box.\n\n.div {\n  box-sizing: border-box;\n}\nExample 2\n\nSetting a div elements box-sizing to content-box.\n\n.div {\n  box-sizing: content-box;\n}"},{"title":"Comments","description":"A comment is a piece of text within a style sheet that is not interpreted by the browser. It can be used to provide additional information to aid in understanding the code. By design, comments have no effect on the layout or styling of a document.\n\nSyntax\n\nComments, are created by an opening /* and closing */. Everything in between is commented out.\n\nThey can be used on a single line, or across multiple lines:\n\n/* A one-line comment */\n\n\n/*\nA comment\nwhich stretches\nover several lines\n*/\n\nHere is an example use case:\n\n/* The comment below is used to\n   disable specific styling */\n\n\nspan {\n  color: aqua;\n  font-size: 1.5em;\n}\n\nNote: In CSS, comments cannot be nested. A /* */ comment syntax cannot have another /* */ comment syntax inside. The first closing */ ends the comment."},{"title":"Colors","description":"The CSS color property sets the text color:\n\nh1 {\n  color: aqua;\n}\n\nIt can be set with one of the following:\n\nName keywords: aqua\nHexadecimal: #00ffff\nRGB value: rgb(0, 255, 255)\nHSL value: hsl(180, 100%, 100%)\n\nColor name keywords can be used to set color property values for elements in CSS. All browsers support the following:\n\nKeyword\tHexadecimal\naliceblue\t #f0f8ff\nantiquewhite\t #faebd7\naqua\t #00ffff\naquamarine\t #7fffd4\nazure\t #f0ffff\nbeige\t #f5f5dc\nbisque\t #ffe4c4\nblack\t #000000\nblanchedalmond\t #ffebcd\nblue\t #0000ff\nblueviolet\t #8a2be2\nbrown\t #a52a2a\nburlywood\t #deb887\ncadetblue\t #5f9ea0\nchartreuse\t #7fff00\nchocolate\t #d2691e\ncoral\t #ff7f50\ncornflowerblue\t #6495ed\ncornsilk\t #fff8dc\ncrimson\t #dc143c\ncyan\t #00ffff\ndarkblue\t #00008b\ndarkcyan\t #008b8b\ndarkgoldenrod\t #b8860b\ndarkgray\t #a9a9a9\ndarkgrey\t #a9a9a9\ndarkgreen\t #006400\ndarkkhaki\t #bdb76b\ndarkmagenta\t #8b008b\ndarkolivegreen\t #556b2f\ndarkorgange\t #ff8c00\ndarkorchid\t #9932cc\ndarkred\t #8b0000\ndarksalmon\t #e9967a\ndarkseagreen\t #8fbc8f\ndarkslateblue\t #483d8b\ndarkslategray\t #2f4f4f\ndarkslategrey\t #2f4f4f\ndarkturquoise\t #00ced1\ndarkviolet\t #9400d3\ndeeppink\t #ff1493\ndeepskyblue\t #00bfff\ndimgray\t #696969\ndimgrey\t #696969\ndodgerblue\t #1e90ff\nfirebrick\t #b22222\nfloralwhite\t #fffaf0\nforestgreen\t #228b22\nfuschsia\t #ff00ff\ngainsboro\t #dcdcdc\nghostwhite\t #f8f8ff\ngold\t #ffd700\ngoldenrod\t #daa520\ngray\t #808080\ngrey\t #808080\ngreen\t #00800\ngreenyellow\t #adff2f\nhoneydew\t #f0fff0\nhotpink\t #ff69b4\nindianred\t #cd5c5c\nindigo\t #4b0082\nivory\t #fffff0\nkhaki\t #f0e68c\nlavender\t #e6e6fa\nlavenderblush\t #fff0f5\nlawngreen\t #7cfc00\nlemonchiffon\t #fffacd\nlightblue\t #add8e6\nlightcoral\t #f08080\nlightcyan\t #e0ffff\nlightgoldenrodyellow\t #fafad2\nlightgray\t #d3d3d3\nlightgrey\t #d3d3d3\nlightgreen\t #90ee90\nlightpink\t #ffb6c1\nlightsalmon\t #ffa07a\nlightseagreen\t #20b2aa\nlightskyblue\t #87cefa\nlightslategray\t #778899\nlightslategrey\t #778899\nlightsteelblue\t #b0c4de\nlightyellow\t #ffffe0\nlime\t #00ff00\nlimegreen\t #32cd32\nlinen\t #faf0e6\nmagenta\t #ff00ff\nmaroon\t #800000\nmediumaquamarine\t #66cdaa\nmediumblue\t #0000cd\nmediumorchid\t #ba55d3\nmediumpurple\t #9370db\nmediumseagreen\t #3cb371\nmediumslateblue\t #7b68ee\nmediumspringgreen\t #00fa9a\nmediumturquoise\t #48d1cc\nmediumvioletred\t #c71585\nmidnightblue\t #191970\nmintcream\t #f5fffa\nmistyrose\t #ffe4e1\nmoccasin\t #ffe4b5\nnavajowhite\t #ffdead\nnavy\t #000080\noldlace\t #fdf5e6\nolive\t #808000\nolivedrab\t #6b8e23\norange\t #ffa500\norangered\t #ff4500\norchid\t #da70d6\npalegoldenrod\t #eee8aa\npalegreen\t #98fb98\npaleturquoise\t #afeeee\npalevioletred\t #db7093\npapayawhip\t #ffefd5\npeachpuff\t #ffdab9\nperu\t #cd853f\npink\t #ffc0cb\nplum\t #dda0dd\npowerderblue\t #b0e0e6\npurple\t #800080\nrebeccapurple\t #663399\nred\t #ff0000\nrosybrown\t #bc8f8f\nroyalblue\t #4169e1\nsaddlebrown\t #8b4513\nsalmon\t #fa8072\nsandybrown\t #f4a460\nseagreen\t #2e8b57\nseashell\t #fff5ee\nsienna\t #a0522d\nsilver\t #c0c0c0\nskyblue\t #87ceeb\nslateblue\t #6a5acd\nslategray\t #708090\nslategrey\t #708090\nsnow\t #fffafa\nspringgreen\t #00ff7f\nsteelblue\t #4682b4\ntan\t #d2b48c\nteal\t #008080\nthistle\t #d8bfd8\ntomato\t #ff6347\nturquoise\t #40e0d0\nviolet\t #ee82ee\nwheat\t #f5deb3\nwhite\t #ffffff\nwhitesmoke\t #f5f5f5\nyellow\t #ffff00\nyellowgreen\t #9acd32"},{"title":"cursor","description":"The cursor property sets the appearance of the mouse cursor when hovering over an element. The appearance can be set by specifying the type of cursor, or by loading a specific icon. When using an icon, fallback images can be used, ending with a mandatory keyword fallback.\n\nSyntax\n\nThe cursor property can be set a specific keyword value:\n\ncursor: keyword;\n\nIt can also accept one or more URLs:\n\ncursor: url(cursor_image), url(fallback_cursor_image), keyword;\n\nIf the primary cursor_image fails to load, an optional fallback_cursor_image can be applied instead. However, in case all the image URLs fail to load, the mandatory keyword will be used as a last resort.\n\nThese are some common keywords used to specify the type of cursor to display:\n\nKeyword\tExample Cursor\tDescription\nauto\t\tDetermines the cursor to display based on context.\nnone\t\tNo cursor is displayed.\ndefault\t\tThe default system cursor, usually an arrow.\ncontext-menu\t\tIndicates a context menu is available.\nhelp\t\tIndicates help information is available.\npointer\t\tIndicates a link.\nprogress\t\tSystem is busy in the background but interaction is allowed.\nwait\t\tSystem is busy and interaction is not allowed.\ncell\t\tIndicates a table cell or cells can be selected.\ncrosshair\t\tUsed to mark selections in an image.\ntext\t\tUsed to indicate editable text.\nvertical-text\t\tUsed to indicate editable vertical text.\nExample\n\nIn the example below, a pointer hand will appear whenever the cursor hovers over the paragraph:\n\n<p style=\"cursor: pointer;\">The cursor is pointing at this paragraph!</p>"},{"title":"Filter Functions","description":"The CSS filter property applies graphical effects like blur to an element. It is commonly used to adjust the rendering of images, backgrounds, and sometimes even borders."},{"title":"Flexbox","description":"The Flexible Box Layout, commonly known as Flexbox, is a new layout model that allows responsive elements within a container to be automatically arranged depending upon the screen size.\n\ndiv {\n  display: flex;\n}\nMain Axis\n\nWhen working with flexbox, there are two axes:\n\nThe main axis\nThe cross axis"},{"title":"Floats","description":"The float property moves an element to the left or right within its containing element, outside of the default positioning.\n\nSyntax\n\nThe float property primarily uses the following three values:\n\nThe left value that makes the element float on the left of its container.\nThe right value that makes the element float on the right of its container.\nThe none value that causes the element not to float.\n.item_x {\n  float: none;\n}\n\n.item_y {\n  float: left;\n}\n\n.item_z {\n  float: right;\n}\nExample\n<section>\n  <div class=\"item_1\">\n    <p>This is the first item and I will float left.</p>\n  </div>\n  <div class=\"item_2\">\n    <p>This is the second item and I will float right.</p>\n  </div>\n  <br />\n  <br />\n  <br />\n  <p>This example shows CSS floats and I wont float at all.</p>\n</section>\n\nIn the above snippet, the elements with the class item_1 and item_2 can be set to float in an external style sheet.\n\n.item_1 {\n  float: left;\n}\n\n\n.item_2 {\n  float: right;\n}\n\n\ndiv {\n  border: thick double black;\n}\n\n\nsection > p {\n  margin: auto;\n  text-align: center;\n  width: 50%;\n}\n\nThe <div> tags with the .item_1 and .item_2 classes will float to the left and right of the “CSS floats” text, respectively."},{"title":"Grids","description":"CSS Grid is a two-dimensional grid-based layout system that uses rows, columns, and gaps to organize content on a web page. This system helps with creating a responsive layout for web pages without having to use positioning, floats, or flexbox.\n\nGrid Elements\n\nA grid layout consists of a parent element, with one or more child elements.\n\n<div class=\"grid-container\">\n  <div class=\"grid-item\">1</div>\n  <div class=\"grid-item\">2</div>\n  <div class=\"grid-item\">3</div>\n  <div class=\"grid-item\">4</div>\n</div>\n\nAn HTML element becomes a grid container when its display property is set to grid or inline-grid:\n\n.grid-container {\n  display: grid;\n}\n\nAll the nested elements inside the grid container element are called grid items. In the example above, each item is given a class of grid-item to further emphasize this point.\n\nThe difference between the values inline-grid and grid is that the inline-grid will make the element inline while grid will make it a block-level element.\n\nGrid columns are the verticle lines of the grid items.\nGrid rows are the horizontal lines of grid items.\nGrid gaps are the spaces between each column/row."},{"title":"Inheritance","description":"CSS inheritance describes how certain styles are initialized or computed depending on the CSS property and whether a value was set. Some properties are inherited with an initial, default value. Other properties are non-inherited and set to the computed value of its containing element by default.\n\nInherited properties\n\nInherited properties apply to the element and its children.\n\nProperty\tDescription\ncolor\tSets the text color of an element.\ncursor\tThe cursor property sets the appearance of the mouse cursor when hovering over an element.\nfont\tSets an element’s font properties in a single declaration.\nfont-family\tSpecifies a font typeface in a ruleset.\nfont-size\tSets the font size of an element’s text.\nfont-style\tTo set the font style in which text will appear.\nfont-weight\tTo set the text to be thicker or thinner.\nletter-spacing\tSet the horizontal spacing between the individual characters in an element.\nline-height\tSet the vertical spacing between lines of text.\ntext-align\tTo set the text alignment of inline contents.\ntext-indent\tIndents (leaves empty space) the first line in a text-block.\ntext-justify\tSets the justifcation method of text when text-align: justify; is applied to an element.\ntext-shadow\tAdds shadow to text.\ntext-transform\tSpecifies how to capitalize an element’s text.\nvisibility\tHides or reveals an element without affecting its placement within the page.\nword-spacing\tSet space between words.\nNon-inherited properties\n\nNon-inherited properties are not inherited by its children.\n\nProperty\tDescription\nAll background properties\tAdds wallpaper visuals for HTML elements.\nAll border properties\tDefines the border styles of an element.\nbox-sizing\tIncludes padding and border in the calculation of an element’s height and width.\nAll Flexbox properties\tArranges elements responsively and according to screen size.\nfloat\tRepositions an element to the left or right side of its containing element.\nAll Grid properties\tUses rows, columns, and gaps to organize content on a web page.\nAll margin properties\tSets the spacing beyond the border of an element.\nAll overflow properties\tManages content that spills outside of its box.\nAll padding properties\tSets the spacing between the content and margin of an element.\nAll position properties\tDefines the placement of an element on a web page.\nAll sizing properties\tDefines the height and width values of an element.\ntext-decoration\tStyles the text of an element with line decorations.\ntext-overflow\tSpecifies how hidden content is signaled to the user.\ntransform\tAllows us to rotate, scale, skew or translate an element.\ntransform-origin\tSets the position of a transformed element relative to its origin.\ntransform-style\tConfirms whether an element’s children are flattened or positioned in a 3D space.\nAll transition properties\tControls the animation speed and timing of property changes in an element."},{"title":"Margins","description":"Margin refers to the space directly outside of the box. The margin property is used to specify the size of this space.\n\np {\n  border: 1px solid aquamarine;\n  margin: 20px;\n}\n\nHere, the code will place 20 pixels of space on the outside of the paragraph’s box on all four sides. This means that other HTML elements on the page cannot come within 20 pixels of the paragraph’s border.\n\nIf you want to be even more specific about the amount of margin on each side of a box, you can use the following properties:"},{"title":"Math Functions","description":"Performing dynamic mathematical calculations to set property values might sound difficult, but the calc() function makes handling mathematical expressions simple and if we want to create responsive elements, the min() and max() functions are great solutions for setting case-specific design constraints."},{"title":"Overflow","description":"The overflow property controls what happens to content that spills, or overflows, outside its box.\n\nThe most commonly used values are:\n\nhidden When set to this value, any content that overflows will be hidden from view.\nscroll: When set to this value, a scrollbar will be added to the element’s box so that the rest of the content can be viewed by scrolling.\nvisible: When set to this value, the overflow content will be displayed outside of the containing element. Note, this is the default value.\np {\n  overflow: scroll;\n}\n\nHere, if any of the paragraph content overflows (perhaps a user resizes their browser window), a scrollbar will appear so that users can view the rest of the content."},{"title":"Padding","description":"The space between the contents of a box and the borders of a box is known as padding. Padding is like the space between a picture and the frame surrounding it.\n\nSyntax\n\nIn CSS, you can modify this space with the padding property.\n\np.content-header {\n  border: 3px solid coral;\n  padding: 10px;\n}\n\nHere, the code added 10 pixels of space between the content of the paragraph (the text) and the borders, on all four sides.\n\nThe padding property is often used to expand the background color and make the content look less cramped.\n\nIf you want to be more specific about the amount of padding on each side of a box’s content, you can use the following properties:"},{"title":"Position","description":"Positioning in CSS provides designers and developers options for positioning HTML elements on a web page.\n\nThe CSS position can be set to static, relative, absolute, or fixed or sticky."},{"title":"Selectors","description":"CSS selectors are used to “find” (or select) the HTML elements you want to style.\n\nElement Selector\n\nThe element selector selects HTML elements based on the element name.\n\nHere, all <p> elements on the page will be center-aligned, with a red text color:\n\np {\n  text-align: center;\n  color: red;\n}\nId Selector\n\nThe id selector uses the id attribute of an HTML element to select a specific element.\n\nThe id of an element is unique within a page, so the id selector is used to select one unique element!\n\nTo select an element with a specific id, write a hash (#) character, followed by the id of the element.\n\nThe CSS rule below will be applied to the HTML element with id=\"para1\":\n\n#para1 {\n  text-align: center;\n  color: red;\n}\n\nNote: An id name cannot start with a number!\n\nClass Selector\n\nThe class selector selects HTML elements with a specific class attribute.\n\nTo select elements with a specific class, write a period (.) character, followed by the class name.\n\nIn this example, all HTML elements with class=\"center\" will be red and center-aligned:\n\n.center {\n  text-align: center;\n  color: red;\n}\n\nYou can also specify that only specific HTML elements should be affected by a class.\n\nIn this example only <p> elements with class=\"center\" will be center-aligned:\n\np.center {\n  text-align: center;\n  color: red;\n}"},{"title":"Transform Functions","description":"We can transform any HTML element using the transform property combined with CSS functions that scale, rotate, and even distort.\n\nThese functions apply both 2D and 3D transformations to element.\n\nFor example:\n\n.shifted {\n  transform: translate(0px, 100px);\n}"},{"title":"Sizing","description":"The CSS height and width properties are used to set the height and width of an element. They do not include padding, borders, or margins of the element, but instead, the height/width of the area inside the padding, border, and margin.\n\nThe height and width properties may have the following values:\n\nauto (default): The browser calculates the height and width.\nlength: Defines the height/width in px, cm, etc.\n%: Defines the height/width in percent of the containing block.\ninitial: Sets the height/width to its default value.\ninherit: The height/width will be inherited from its parent value."},{"title":"Transition","description":"CSS transitions provide a way to control an animation’s speed and timing of the property changes. Instead of having property changes take effect immediately, you can cause the changes in a property to take place over a period of time.\n\nFor example, if the mouse cursor hovers over a link, the link may change color or appearance, and usually the change is instantaneous. With CSS transitions enabled, changes can occur at time intervals that follow an acceleration curve, all of which can be customized.\n\nWe can control the following four aspects of an element’s transition:\n\nHow much time there is before a transition begins\nHow long a transition lasts\nWhich property the transition is for\nHow a transition accelerates"},{"title":"Typography","description":"Typography is the art of arranging text on a page. Some of the most important information a user will see on a web page will be textual.\n\nStyling text to make page content accessible and engaging can significantly improve user experience.\n\nSome of the things that typography can help with:\n\nHow to style and transform fonts.\nHow to lay text out on a page.\nHow to add external fonts to your web pages."},{"title":"Units","description":"CSS uses units to measure the values of various properties in a stylesheet. The two main types of units are absolute units and relative units.\n\nAbsolute Units\n\nAbsolute units are CSS units that are of fixed lengths and not relative to any other styles. This includes:\n\npx: Pixels (most common)\npt: Points\nmm: Millimeters\nRelative Units\n\nRelative units are CSS units whose size is relative to some other length. They could relate to things like:\n\nThe font-size of a direct parent element\nThe default font-size of the HTML body\nThe size of the viewport\n\nSome common relative units include:\n\nem: Property size relative to property size of direct parent element (most common)\nrem: Property size relative to property size of direct root element\nvw: Percentage based on width of screen\nvh: Percentage based on height of screen\nSyntax\n<length>: <length-unit>;\nA <length> is any measurable property, such as border, background-color, and margin.\nA <length-unit> is the value assigned to a measurable property, such as 2px, 30em, and 10pt.\nExample\nborder-width: 30px;\n\nThis sets the border-width to 30 pixels."},{"title":"Variables","description":"CSS variables are custom properties that are defined in one place and used in multiple places throughout the stylesheet.\n\nSyntax\n\nCSS variables are used in two principle steps:\n\nDefine the custom variable inside a selected element\n\nelement {\n  --custom-variable: red;\n}\n\nUse the var() function to allow --custom-variable to be assigned to a property in multiple elements:\n\nelementA {\n  background-color: var(--custom-variable);\n}\n\n\n.elementBWithClass {\n  background-color: var(--custom-variable);\n}\n\n\n#elementCWithId {\n  background-color: var(--custom-variable);\n}\nCSS Variables and the Cascade\n\nCSS cascade rules makes custom variable properties inheritable. This means that any child or grandchild element can inherit that variable value.\n\nIn the samples below, there are 3 div elements with classes divA, divB, and divC. The hierarchy is as follows:\n\ndivA is the topmost parent in the body\ndivB is a child of divA\ndivC is a child of divB (and a grand-child of divA)\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <link rel=\"stylesheet\" href=\"./csspractice.css\" />\n    <title>CSS Practice</title>\n  </head>\n\n\n  <body>\n    <div class=\"divA\">\n      A\n      <div class=\"divB\">\n        B\n        <div class=\"divC\">C</div>\n      </div>\n    </div>\n  </body>\n</html>\n\nThe CSS variable --custom-bg-color-saffron is defined in the selector for divB.\n\n.divA {\n  width: 40em;\n  height: 40em;\n}\n\n\n.divB {\n  --custom-bg-color-saffron: #f4c430;\n  background-color: var(--custom-bg-color-saffron);\n  position: relative;\n  margin: 2em;\n  width: 35em;\n  height: 35em;\n}\n\n\n.divC {\n  position: absolute;\n  width: 25em;\n  height: 25em;\n  bottom: 1em;\n  right: 1em;\n}\n\nThe rendered image below shows that the background color for divB is set to --custom-bg-color-saffron. While its child, divC, doesn’t have background color specified, it inherits the property from its parent. On the other hand, divA, the parent of divB, has a default white background color because it exists outside the scope of --custom-bg-color-saffron."},{"title":"Visibility","description":"The visibility property shows or hides an element. If the element is hidden, it will still take up space within the page.\n\nSyntax\nvisibility: <value>;\n\nThe visibility property has three values.\n\nvisible: Shows the element.\nhidden: Hides the element.\ncollapse: Hides both the element and the space it would have occupied.\n\nNote: collapse should only be used with <table> rows, row groups, columns, and column groups. If collapse is used on other elements, it will be treated the same as hidden. Implementing collapse within a <table> can be especially useful because it allows for hiding rows or columns without affecting the table layout.\n\nExample 1\n\nHiding an element with an id of hide.\n\n.hide {\n  visibility: hidden;\n}\nExample 2\n\nHiding a <tr> element within a table.\n\ntr {\n  visibility: collapse;\n}"}],"Emojicode":[{"title":"↪️ Conditionals","description":"Conditionals take an expression, which is code that evaluates to determine a value, and checks if it is 👍 or 👎. If it’s 👍, we can tell our program to do one thing — we can even account for 👎 to do another.\n\nAs we write more complex programs, conditionals allow us to address multiple scenarios and make our programs more robust.\n\nIf Statement\n\nThe ↪️ statement is very important. It allows for conditional execution of a code block. The whole syntax is:\n\nIf the condition evaluates to 👍, the code block will be executed.\nAnd if it evaluates to 👎, it’ll be ignored.\n\nThis example will display “a is greater than b” if the content for variable a is greater than b:\n\n↪️ a ▶️ b 🍇\n  😀 🔤a is greater than b🔤❗️\n🍉\nElse Statement\n\nThe 🙅 extends an ↪️ statement to execute an additional code block in case the expression in the if statement evaluates to false.\n\nFor example, the following code would display “a is greater than b” if a is greater than b, and a is not greater than b otherwise:\n\n↪️ a ▶️ b 🍇\n  😀 🔤a is greater than b🔤❗️\n🍉\n🙅 🍇\n  😀 🔤a is not greater than b🔤❗️\n🍉\n\nNote: The 🙅 statements is only executed if the ↪️ statement evaluated to 👎, and if all 🙅↪️ statements evaluated to 👎 too."},{"title":"🍯 Dictionaries","description":"🍯, or dictionary or hash map in other languages, is an ordered set of value pairs:\n\n🔤key🔤 ➡️ 🔤value🔤\n\nIt provides a way to map pieces of data to each other, and allows for quick access to values associated to keys. Keys must be unique in dictionaries, but the values don’t have to be.\n\nSyntax\n🏁 🍇\n  🍿\n    🔤fr🔤 ➡️ 🔤Salut!🔤\n    🔤it🔤 ➡️ 🔤Ciao!🔤\n    🔤de🔤 ➡️ 🔤Guten Tag!🔤\n    🔤en🔤 ➡️ 🔤Hey!🔤\n    🔤es🔤 ➡️ 🔤Hola!🔤\n    🔤cn🔤 ➡️ 🔤你好!🔤\n    🔤jp🔤 ➡️ 🔤こんにちは!🔤\n  🍆 ➡️ dictionary\n🍉\n\n🍿 is used to list key value pairs, where each key is separated from its value with a ➡️. This will create an instance of 🍯, which is stored into dictionary.\n\n🍯 is implemented as a hash table and is O(1) on average and O(n) in worst case."},{"title":"🍿 Lists","description":"A list literal is a listing of expressions.\n\nLists are always ordered and can contain different types of objects, such as strings, integers, booleans, etc. Lists are a mutable data type and therefore a good choice for dynamic data (adding and subtracting to lists).\n\nSyntax\n\nIn Emojicode, a list is created by using 🍿 and 🍆.\n\nFor instance, the example below is a list literal with integer values 18, 67, 420.\n\n🍿 18 67 420 🍆\n\nHere’s another list with three strings:\n\n🍿 🔤eggs🔤 🔤blueberries🔤 🔤cookies🔤 🍆\n\nThe compiler will try to infer the type of a list literal. The default type of list literals, is the list type 🍨, an ordered mutable collections of values."},{"title":"💭 Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.\n\nThere are two types of comments in Emojicode.\n\nSingle-line Comments\n\nIn Emojicode, single-line comments are made with 💭. Any text after the 💭 that is on the same line is not executed.\n\n💭 The next line outputs \"Hello\"\n😀 🔤Hello🔤❗️\nMultiline Comments\n\nMultiline comments are created with 💭🔜 and 🔚💭. Any text in between is not executed.\n\n💭🔜\nThis is a comment.\nIt will be ignored by the compiler.\n🔚💭\nExample\n\nHere’s a whole Emojicode programe with comments:\n\n💭🔜\nEmojicode is created by:\nTheo Weidmann\n🔚💭\n\n\n🏁 🍇\n  😀 🔤Hello World!🔤❗️\n  💭 Output: Hello World!\n🍉"},{"title":"🔁 Repeat While","description":"The 🔁 statment repeats a code block while as long as the given condition is 👍 (true). And if the condition is never 👍 (false), the code block will be ignored and skipped.\n\nDue to the ease of use of the 🔂 (for-in) statement, 🔁 is only used seldomly.\n\nInfinite Loop\n🏁 🍇\n  🔁 👍 🍇\n    😀 🔤It goes on and on and on🔤❗️\n  🍉\n🍉\n\nThis program will infinitely print “It goes on and on and on”.\n\nIt goes on and on and on\nIt goes on and on and on\nIt goes on and on and on\n..."},{"title":"🔂 For In","description":"The 🔂 statement allows you to quickly iterate over an instance, that is repeatedly retrieving values from it until there are no more values to provide.\n\nFor example, you can iterate over an 🍨 instance and you’ll receive all elements contained in the list.\n\nSyntax\n🏁 🍇\n  🍿 🔤cookies🔤 🔤milk🔤 🔤eggs🔤 🔤blueberries🔤 🍆 ➡️ grocery\n\n\n  🔂 item grocery 🍇\n    😀 item❗️\n  🍉\n🍉\n\nThe output would be:\n\ncookies\nmilk\neggs\nblueberries\n\nIn this example, the code block will be repeated for every value of the list and the values are printed. The type of item is naturally 🔡."},{"title":"🔡 Strings","description":"Strings are words or pieces of text that the computer treats as a single item. They provide a way to store something like a word, sentence, or whole paragraph.\n\nTechnically speaking, a string is a sequence of characters. It can be of any length and contain any letters, numbers, symbols, or spaces as long as they are surrounded by 🔤‘s.\n\nSyntax\n\nHere are four different strings in Emojicode:\n\n🔤This is a string!🔤\n🔤This is also a string!!!🔤\n🔤1337🔤\n🔤👆👍🔤\n\nIt’s important to distinguish between strings and the rest of the code in our programs. Every part of a program is made up of characters, but strings are the parts we intend to keep as data—not as instructions to be executed by the computer.\n\nExample\n\nHere’s a full program that print out two strings:\n\n🏁 🍇\n  😀 🔤2020...🔤❗️\n  😀 🔤That was a crazy year.🔤❗️\n🍉\nString Interpolation\n\nString interpolation can be used to construct a string from a mix of constants, variables, and others by including their values inside a string literal.\n\nIn Emojicode, to insert a value into a string using string interpolation, we can write the variable inside two 🧲s and it will print its value.\n\nSuppose we have a constant named height with a value of 3000, and we want to use string interpolation to print out a fun fact:\n\n3000 ➡️ height\n\n\n😀 🔤Alex Honnold climbed El Capitan, which is 🧲height🧲 feet, without a rope!🔤❗️\n\nIt will output:\n\nAlex Honnold climbed El Capitan, which is 3000 feet, without a rope!"},{"title":"🧲 Interpolation","description":"String interpolation can be used to construct a string from a mix of constants, variables, and others by including their values inside a string literal.\n\nIn Emojicode, to insert a value into a string using string interpolation, we can write the variable inside two 🧲s and it will print its value.\n\nSuppose we have a constant named height with a value of 3000, and we want to use string interpolation to print out a fun fact:\n\n3000 ➡️ height\n\n\n😀 🔤Alex Honnold climbed El Capitan, which is 🧲height🧲 feet, without a rope!🔤❗️\n\nIt will output:\n\nAlex Honnold climbed El Capitan, which is 3000 feet, without a rope!\nExample\n💭 Tip Calculator\n\n\n🏁 🍇\n  3.80 ➡️ tip\n\n\n  😀 🔤The tip is $🧲tip🧲🔤❗️\n🍉\n\nIt will output:\n\nThe tip is 3.80"},{"title":"😀 Hello World","description":"We write Emojicode programs in files with the extension .emojic or .🍇.\n\nAlmost all the code in an Emojicode program will live inside a 🏁 block. A block is a collection of code. The 🏁 block indicates all the code that should run when the file is executed.\n\nWithin our larger program, we can indicate one or more blocks of code with 🍇 🍉 code blocks:\n\n🍇 to indicate the start of the code block\n🍉 to indicate the end of the code block\n\nSo a basic Emojicode file will have the following structure:\n\n🏁 🍇\n  Some code go here\n🍉\n\nTo print in Emojicode, we use the 😀 ❗️ method:\n\n😀 🔤Hello, World!🔤❗️\n\nThis prints “Hello, World!” to the terminal.\n\n🔤Hello, World!🔤 is a string. It holds the message we want to print to the terminal.\nWe wrap the thing we want to print with a 😀 at the start and a ❗️ at the end.\nExample\n\nHere’s a program called welcome.emojic that prints a string:\n\n🏁 🍇\n  😀 🔤Welcome to Codecademy Docs🔤❗️\n🍉"},{"title":"Data Types","description":"All programming languages designate certain “types” of data. This helps the operating system and computer hardware allocate memory based on the type of data that is going to be stored.\n\nEmojicode, being a very type-safe language, takes great care to ensure that data types are understood, by both you and the compiler.\n\nHere are a few basic data types in Emojicode:\n\nType\tDescription\n🔢\tInteger numbers\n💯\tDecimal numbers\n🔡\tText strings\n👌\tTruth values 👍/👎\n🔲 Type Casting\n\nType casting is a way to determine whether a value is of a given type at run-time and to treat the value as an instance of this type.\n\n🔲 value type\n\nThe value is the value to be casted to type:\n\nIf value can be casted to type, then value is returned as type.\nIf it can’t, then no value is returned.\n\nType casting is implemented with the 🔲 statement:\n\n🔲 hello 🔡     💭 Tries to cast txt to 🔡\n🔲 world 🐟     💭 Tries to cast a to 🐟"},{"title":"Operators","description":"Arithmetic Operations\n\nEmojicode supports arithmetic operators for:\n\n➕: addition\n➖: subtraction\n✖️: multiplication\n➗: division\n🚮: modulo (divides and gives the remainder)\n\nFor example:\n\n4 ➕ 2 ➡️ score1     💭 scores1 is 6\n\n\n4 ➖ 2 ➡️ score2     💭 scores2 is 2\n\n\n4 ✖️ 2 ➡️ score3      💭 scores3 is 8\n\n\n4 ➗ 2 ➡️ score4     💭 scores4 is 2\n\n\n4 🚮 2 ➡️ score5     💭 scores5 is 0"}],"Git":[{"title":"Add","description":"In Git, adding is used to add changes from the working tree to the staging area. This is where changes are saved for the next commit. When the file name appears in green, it indicates that the file is tracked and will be staged for the next commit.\n\nExample\n\nBelow is a short example of how the git add command works. Assuming a change was saved in a message.txt text file, running git status will show this:\n\n$ git status\n\n\nOn branch main\n\n\nNo commits yet\n\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n  message.txt\n\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\nSince the file is untracked, git add can be used to stage it for the next commit. Afterwards, running git status again should yield the following:\n\n$ git add message.txt\n$ git status\n\n\nOn branch main\n\n\nNo commits yet\n\n\nChanges to be committed:\n  (use \"git rm --cached <file>...\" to unstage)\n  new file:   message.txt\n\nThe file now appears in green when running git status, indicating that it is staged and will be saved with the next commit.\n\nThere are many extensions to the git add command such as:\n\n-n: Where the file will not be added to the staging area but will show whether or not the file exists and/or if it will be ignored.\n-f: Which stages all files including those which are ignored.\n. : Which stages all the files in the current directory. On the command line, it references the current directory.\n-A: Which stages all the files in the current directory as well as subdirectories."},{"title":"Branch","description":"In Git, a branch represents a way to provide an isolated copy of the current code. The code in the branch can be modified without affecting the original code and, when it is ready, the changes can be moved back into the original code. Branches also make it much easier to undo changes.\n\nCreating a Branch\n\nThe syntax for creating a branch in Git is this:\n\ngit branch <branch-name>\n\nUsing this command from <current-branch> will create a new branch called <branch-name> based off of the code that is currently in <current-branch>.\n\nRenaming a branch\n\nTo rename a local branch in Git, use the following syntax:\n\ngit branch -m <old-branch-name> <new-branch-name>\n\nThe -m flag here is short for --move. A good way to remember this is to think of renaming as “moving” the branch from one name to another.\n\nDeleting a Branch\n\nThe syntax for removing a branch in Git is this:\n\ngit branch -d <branch-name>\n\nAs long as the branch has no uncommitted code, this command will remove the branch entirely. It will no longer be available to check out, and the changed code will be unrecoverable.\n\nSometimes, Git will refuse to delete a branch because it has unmerged changes in an existing upstream or remote version of that branch. In such cases, it can be forcefully deleted with either the -d --force or capitalized -D flag, like so in the my-branch examples below.\n\nOption 1:\n\ngit branch -d --force my-branch\n\nOption 2:\n\ngit branch -D my-branch\n\nPerforming a force delete tells Git the user understands that all changes on that branch will be lost forever, and they want to delete the branch anyway.\n\nMoving Between Branches\n\nThe syntax for moving between branches in Git is this:\n\ngit checkout branch-name\n\nThis will change the active branch to the one named branch-name. Any editing done at this point will be to the copy of the code within branch-name rather than the previous branch.\n\nThe checkout command is often used immediately after creating a new branch. This is so common that there is a shorthand command to create a new branch and switch to it automatically:\n\ngit checkout -b branch-name\n\nThis is the same as performing the following commands in direct succession:\n\ngit branch branch-name\ngit checkout branch-name\nMerging Branches\n\nThe syntax for moving code from one branch into another in Git is this:\n\ngit merge <branch-name>\n\nThis will merge the code from <branch-name> to the currently checked out branch.\n\nExample\n\nWhen working with code, a programmer will often want to work on a specific feature. They will create a branch off of the main one, and code within it. Once they are happy with the feature and are certain that it is ready to be added back to the main branch they will merge it from the feature branch into the main one. Finally, they will clean up their repository by deleting the feature branch.\n\nFirst, we branch off of the main branch and check out the new one:\n\ngit checkout main                   # Make sure we are in the main branch\n\n\ngit branch my-awesome-feature       # Create the new branch\n\n\ngit checkout my-awesome-feature     # Switch to the new branch\n\nWhen our code is ready, and fully committed to the new branch:\n\ngit checkout main                   # Go back to the main branch\n\n\ngit merge my-awesome-feature        # Combine the code from my-awesome-feature into the main branch\n\n\ngit branch -d my-awesome-feature    # Remove the branch now that the code has been combined"},{"title":"Clone","description":"In Git, cloning means copying an existing remote repository to the current directory.\n\nMany common Git commands are performed only on a local repository, that is, a repository that exists on a local machine. Here’s a command that will interact with a remote repository — a repository on a server that can be accessed through the internet.\n\nSyntax\n\nThe syntax for cloning in Git via HTTPS is this:\n\ngit clone https://github.com/repository/URL.git\nExample\n\nIn the example below, git clone is used to clone the Codecademy Docs repository:\n\n$ git clone https://github.com/Codecademy/docs.git\n\n\n  Cloning into 'docs'...\n  remote: Enumerating objects: 21512, done.\n  remote: Counting objects: 100% (3517/3517), done.\n  remote: Compressing objects: 100% (1795/1795), done.\n  remote: Total 21512 (delta 2233), reused 1727 (delta 1466), pack-reused 17995\n  Receiving objects: 100% (21512/21512), 3.48 MiB | 9.56 MiB/s, done.\n  Resolving deltas: 100% (10600/10600), done."},{"title":"Init","description":"In Git, init is used to initiate the process of creating a repository. When beginning a new project, this is the first step to take in order to track changes to the code throughout all files and folders.\n\nSyntax\ngit init\nInitializing a Git Repository\nStep 1: Navigate to the Desired Directory\n\nThe init command initializes a Git repository in the current directory. Prior to using this command, users must take care to navigate to the appropriate directory — this will become the root directory of the repository. The cd command can be used to navigate the filesystem from the command line:\n\ncd go/to/desired/project/directory\nStep 2: Init\n\nIn the appropriate directory, initialize a repository to begin tracking changes made to all the files with the following git command:\n\ngit init\n\nAfter the initialization is complete, the following should appear in the command line.\n\nInitialized empty Git repository in /go/to/desired/project/directory/.git/\n\nA new, hidden .git directory is then added alongside the new repository’s root directory. In this case, the root directory is directory."},{"title":"Commit","description":"In Git, commits are used as snapshots of a given branch in a repository. Collectively, they serve as the growth history of all the branches in a Git repository. The most recent commit is considered directly related to the pointer of the current branch.\n\nSyntax\ngit commit\nHow Do I Commit?\nStep 1: Files Ready\n\nBefore using git commit, make sure to have all the neccessary files staged for the commit.\n\ngit add filename\n\nThe git add . command can be used to add all files in the current directory.\n\nStep 2: Commit\n\nAfter the files are staged for commit, use the following syntax:\n\ngit commit\n\nNote: Using the git commit command by itself will open up an editor (usually set to Vim by default), where users will be asked to add a commit message. After writing a message, saving and closing the file (:wq in Vim) will add that message to the current commit.\n\nHere is an example of what the commit message prompt might look like when using git commit:\n\nAdd git_practice.js and install dependencies\n\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch main\n# Changes to be committed:\n#       new file:   git_practice.js\n#       new file:   package-lock.json\n#       new file:   package.json\n\nHere is what the command line would look like afterwards:\n\n$ git commit\n[main (root-commit) b77d68b] Add git_practice.js and install dependencies\n 3 files changed, 26 insertions(+)\n create mode 100644 git_practice.js\n create mode 100644 package-lock.json\n create mode 100644 package.json\n\nUsing the -m flag like so, git commit -m <message>, adds a commit message without opening up an editor:\n\n$ git commit -m \"this is a commit message\"\n[main (root-commit) b77d68b] this is a commit message\n 3 files changed, 26 insertions(+)\n create mode 100644 git_practice.js\n create mode 100644 package-lock.json\n create mode 100644 package.json"},{"title":"Pull","description":"In Git, pulling is the process of moving code from one repository to another one. Often this is used to move code from a remote machine to a local one, or retrieving code from a repository hosting service like GitHub.\n\nPulling a repository allows a programmer to access code from a remote backup and make it available on their local machine. It is also used when collaborating with others in order to keep the local code up to date with the team’s current version.\n\nSyntax\n\nThe syntax for pulling changes in Git is this:\n\ngit pull <remote-name> <branch-name>\n\nThis will move the code from <remote-name> currently in branch <branch-name>, and move it to the branch checked out locally on the user’s computer.\n\nHow to Pull\n\nPrerequisites to pulling from a remote repository include:\n\nBeing inside of the local repository (if not, the next step will return an error)\n\nBeing inside of the correct branch and having a clean git status in that branch:\n\n$ git checkout new-feature-branch\n$ git status\n\n\nOn branch new-feature-branch\nnothing to commit, working tree clean\n\nHaving a valid remote repository set. In this case the remote repository is named origin and can be found at the url https://github.com/CompanyName/product-dev:\n\n$ git remote -v\n\n\norigin    https://github.com/CompanyName/product-dev.git (fetch)\norigin    https://github.com/CompanyName/product-dev.git (push)\n\nAt this stage, pulling can be accomplished with a valid remote and branch name:\n\ngit pull origin new-feature-branch\n\nWhen the pull completes, it will display a message like this:\n\nremote: Counting objects: 5, done.\nremote: Compressing objects: 100% (3/3), done.\nremote: Total 5 (delta 2), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (5/5), done.\nFrom https://github.com/CompanyName/product-dev.git\n  * branch      new-feature-branch    -> FETCH_HEAD"},{"title":"Merge","description":"In Git, completed changes made to a branch can be merged to the main branch. When collaborating on a remote repository, a pull request will need to be opened in order to do this. Anyone with push access to the repository can complete the merge.\n\nGit Command\n\nTo merge a branch into the local main branch:\n\ngit checkout main     # Switch to the main branch\ngit merge branch_name\n\nFor example, the following merges a branch called feature_test branch to the main branch:\n\ngit checkout main\ngit merge feature_test\nMerging a Pull Request on GitHub\n\nFor information on how to open a pull request, see the Pull Requests section.\n\nOn the GitHub repository page, click the “Pull requests” tab at the top.\n\nIn the “Pull Requests” list, choose the pull request that you’d like to merge.\n\nDepending on the merge options enabled for your repository, you can:\n\nMerge all the commits into the base branch by clicking Merge pull request. If the Merge pull request option is not shown, then click the merge drop down menu and select Create a merge commit.\n\nSquash the commits into one commit by clicking the merge drop down menu, selecting Squash and merge and then clicking the Squash and merge button.\n\nRebase the commits individually onto the base branch by clicking the merge drop down menu, selecting Rebase and merge and then clicking the Rebase and merge button.\n\nIf prompted, type a commit message, or accept the default commit message.\n\nIf you have more than one email address associated with your GitHub account, click the email address drop-down menu and select the email address to use as the Git author email address. Only verified email addresses appear in this drop-down menu. If you enabled email address privacy, then <username>@users.noreply.github.com is the default commit author email address.\n\nClick Confirm merge, Confirm squash and merge, or Confirm rebase and merge.\n\n(Optional) Last but not the least, delete the feature branch. This keeps the list of branches in your repository nice and tidy."},{"title":"Pull Request","description":"Pull requests (PRs) are used to recommend the merging of code from one branch into a different branch. PRs are a core tool in open-source software development as it allows developers to propose changes to large, open-source codebases.\n\nAfter reviewing, if the changes are approved by author(s)/collaborators of the repository, they are merged into the base branch (this is usually named the main branch). If the changes are not approved, the maintainer(s) may either ask the requester for additional changes or decline the PR altogether.\n\nPRs are featured on popular version control platforms such as GitHub and GitLab.\n\nCreate a Pull Request\n\nThe prerequisites for creating a PR and contributing to a project are:\n\nFork the project.\nClone the forked repository to local machine.\nCreate, and switch into, a new branch.\nAdd, commit, and push the changes back to repository.\n\nWith the newly added changes pushed, open the web page of the repository. There should be a button that says “Create Pull Request” placed somewhere, similar to the image below.\n\nClick that button and follow the steps to create the PR."},{"title":"Push","description":"In Git, pushing is the process of moving code from one repository to another one. Often this is used to move code from a local machine to a remote one, or to a repository hosting service like GitHub.\n\nPushing a repository allows a programmer to maintain an easily accessible backup in a second location. It is also used when collaborating with people that would not have access to the computer that the code is written on.\n\nSyntax\n\nThe syntax for pushing changes in Git is this:\n\ngit push <remote-name> <branch-name>\nHow to Push\n\nPrerequisites to pushing from within a repository include:\n\nBeing inside of a repository (if not, the next step will return an error)\n\nHaving a clean git status (no uncommitted, but tracked, files):\n\n$ git status\n\n\nOn branch main\nnothing to commit, working tree clean\n\nHaving a valid remote repository set. In this case the remote repository is named origin and can be found at the url https://github.com/CompanyName/product-dev:\n\n$ git remote -v\n\n\norigin    https://github.com/CompanyName/product-dev.git (fetch)\norigin    https://github.com/CompanyName/product-dev.git (push)\n\nAt this stage, pushing can be accomplished with a valid remote and branch name:\n\ngit push origin main\n\nWhen the push completes, it will display a message like this:\n\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nWriting objects: 100% (3/3), 304 bytes | 304.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/CompanyName/product-dev.git\n   0e21f7b..2a668cb  main -> main"},{"title":"Status","description":"In Git, the status command shows the state of the working directory, staging area, and which files are untracked (names shown in red and not staged) or tracked (shown in green and staged). The tracked files, shown in green, are found in the staging area and will be saved with the next commit.\n\nExample\n\nBelow is a short example of how the git status command works. Assuming a change was saved in a text file, example.txt, running git status will show that:\n\n$ git status\n\n\nOn branch main\n\n\nNo commits yet\n\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n  example.txt\n\n\nnothing added to commit but untracked files present (use \"git add\" to track)"},{"title":"Reset","description":"In Git, the reset command is used to change the state of the Git repository or undo commits.\n\nSyntax\n\nThe git reset command is run in the terminal and generally follows this template:\n\ngit reset <mode-option> <commit-reference>\nMode Options\n\nThe <mode-options> refer to how far reset will go when rolling back changes to a previous commit, including:\n\nWhere the HEAD is pointing towards (usually done with just git reset).\nWhether the staging area or index, reflects the commit the HEAD is now pointing towards.\nWhether the working tree is rolled back to reflect the changes reset in the HEAD and staging area.\n\nMore specifically, these modes include:\n\n--soft: This rolls back to an earlier commit by moving the HEAD pointer towards it but leaving the staging area and working tree untouched, allowing for new commits to be made.\n--mixed: In addition to moving the HEAD pointer to an earlier commit, the staging area is cleared to reflect the changes made in that commit (this runs by default).\n--hard: This goes one step further and resets the working tree to reflect the previous commit reflected in the staging area and the HEAD pointer.\n\nIf, for example, an error was made in a text file, example.txt, and the changes were accidentally added and committed, git reset can be used to go back to the state before that commit was made.\n\nReferencing Commits\n\nThe commit-reference refers to a commit’s unique hash, or save point, that was generated after creation. This hash is a long string that is a mix of characters and numbers that is usually represented by a shorter version: 05df67f9066c8ddd95c8d7bb2137acfb8b18e167 -> 05df67f\n\ngit reset can be used with either the commit hash or with the HEAD keyword, which refers to the commit being viewed on the currently checked-out branch.\n\nExample\n\nThis is what the terminal would look like after creating a commit by accident on the main branch and running a git status check:\n\nOn branch main\nnothing to commit, working tree clean\n\nThe text above indicates the following:\n\nThe main branch is up to date, with the HEAD pointing towards the most recent commit.\nThere is nothing to commit in the staging area.\nNew changes haven’t been made yet in the working tree, hence why it is “clean”.\n\nTo set the HEAD back by one commit as well as clear the staging area, one of the following commands can be run:\n\ngit reset HEAD~1\ngit reset --mixed HEAD~1\n\nSince the --mixed mode runs by default, both of the commands are identical in function. This will do the following:\n\nIt will move the HEAD pointer back by one (~1) commit.\nThe staging area will be cleared of changes.\nThe overall state of the main branch is set to before changes in example.txt were added to the staging area for the previous commit.\n\nIf git status is run once more, this should appear on the terminal:\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   example.txt\n\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"}],"Go Programming Language":[{"title":"Conditionals","description":"Conditionals, primarily the if, else, and else if statements, are used to execute based on whether an expression evaluates to true or false.\n\nConditionals can be nested elsewhere such as inside the switch and for statements.\n\nThe if Statement\n\nThe if statement is mostly associated with conditionals. The code block inside an if statement executes if a condition evaluates true. Otherwise, it is skipped.\n\nSyntax\nif condition {\n  statements\n}\n\nIf the condition is true, the statements inside the code block will be executed. Execution continues after the if block regardless of the value of condition.\n\nThe if statement in Go also allows a small statement to be executed before the condition is evaluated. In this respect, it is similar to the for statement.\n\nif statement; condition {\n  statements\n}\nExample\ni := 0\n\n\nif i++; i > 0 {\n  fmt.Println(\"This line will be executed.\")\n}\nThe else Statement\n\nThe else statement provides an optional block of code that executes if all prior conditions evaluate to false.\n\nSyntax\nif condition {\n  statements_1\n} else {\n  statements_2\n}\n\nIf condition is true, statements_1 will execute. If condition is false, statements_2 will execute instead. Execution then continues after the else block.\n\nThe else if Statement\n\nThe addition of else if statements allow additional conditions to be tested if the prior ones are false. Each is associated with its own block of code to execute if its condition is true.\n\nSyntax\nif condition_1 {\n  statements_1\n} else if condition_2 {\n  statements_2\n} else {\n  statements_3\n}\n\nThe control flow logic of the code below can be broken down like this:\n\nIf condition_1 is true, statements_1 will execute.\nElse, if condition_1 is false and condition_2 is true, statements_2 will be executed instead.\nHowever, if neither condition is true, statements_3 will execute.\n\nExecution then continues after the else block. There can be any number of else if statements, and the final else is optional.\n\nCodebyte Example\n\nFor further information on writing conditional expressions see the sections “Comparison Operators” and “Logical Operators” under Go Operators"},{"title":"Data Types","description":"Data types are the classifications given to the different kinds of values used in everyday programming. In Go, there are seven fundamental data types: Numbers, Strings, Booleans, Arrays, Structs, Slices, and Pointers.\n\nNumbers\n\nIn Go, any number is regarded as number, but there are three sub-categories:\n\nIntegers (signed and unsigned)\nFloating-point numbers\nComplex numbers\nIntegers\n\nIntegers are number-types that are either:\n\nSigned (int) integers that can be positive or negative.\nUnsigned (uint) integers ranging from 0 to positive infinity.\n\nEach integer value comes in 4 different memory sizes.\n\n8-bit: int8/uint8\n16-bit: int16/uint16\n32-bit: int32/uint32\n64-bit: int64/uint64\n32- or 64-bit based on system architecture: int/uint\nSynonym for int32: rune\nsynonym for int8: byte\nFloating-Point Numbers\n\nFloating-point numbers can contain a decimal point. There are two different sizes.\n\n32-bit: float32\n64-bit: float64\nComplex Numbers\n\nComplex numbers are composed of a real number and an imaginary number. The real number is either a float. There are two different sizes:\n\n32-bit float + imaginary number: complex64\n64-bit float + imaginary number: complex128\n// Initialize with complex() taking 2 arguments: a float and a complex number\nvar complex complex64 = complex(1, 2) // Equals 1 + 2i\n\nVariables can also be initialized with a shorthand:\n\ncomplex := 1 + 2i\nStrings\n\nA string represents a sequence of characters. Strings are immutable; once they are created they can’t be modified.\n\nvar s string\n\n\ns = \"Hello, World!\"\nBooleans\n\nA boolean can hold one of two possible values, either true or false.\n\nvar isValid bool\n\n\nisValid = true\nisValid = false\nArrays\n\nArrays are list with static capacity. They can’t change their capacity after the declaration.\n\n// Declare and initialize an arraz of capacity 5 and fill it with elements\nsomeArray := [5]int{0, 2, 3, 4, 5}\nSlices\n\nSlices can change their capacity dynamically even after their declaration. Under the hood a slice references an array. If the array changes, so does the slice.\n\n// Copy the elements from index 0 until (excluding) index 3 into a slace\nvar slice []int = someArary[0:3]\nStructs\n\nIn Go, a struct is a more complex type that can contain custom fields. It’s similar to an object in JavaScript or a dictionary in Python. The fields of a struct can be accessed with a dot ..\n\n// Declaration with \"type ... struct\" keywords\ntype Box struct {\n  X int\n  Y int\n }\n\nStructs are initialized by:\n\nReferencing the name of the struct\nPassing zero, any or all of the fields of the struct.\n\nThe fields without a value will be initialized with zero-values by default.\n\n// Initialization\nb := Box{1, 2}\nPointers\n\nPointers contain the memory address of the variable they are based on. Pointers used *.\n\n// Declaration of a pointer with *\nvar p *int\nsomeInteger := 42\n\n\n// Create pointer from variable using \"&\"\np = &someInteger"},{"title":"Operators","description":"Go supports a number of different operators. These are symbols that modify the value of one or more expressions. These symbols include arithmetic operators, comparison operators, logical operators, bitwise operators, and assignment operators.\n\nArithmetic Operators\n\nArithmetic operators take one or two numeric expressions and return a numeric result.\n\n+ Takes two expressions, (A + B), and returns the sum of the two expressions.\n- Takes two expressions, (A - B), and returns the difference of the two expressions, the first expression minus the second.\n* Takes two expressions, (A * B), and returns the product of the two expressions.\n/ Takes two expressions, (A / B), and returns the first expression divided by the second.\n% Takes two expressions, (A % B), and returns the modulus, the remainder after the integer division of the first expression by the second.\n++ Takes one expression, (A++), and returns the expression incremented by one.\n-- Takes one expression, (B--), and returns the expression decremented by one.\nComparison Operators\n\nComparison operators compare two expressions and return true or false based on the operator and the values of the expression. Go has the following comparison operators.\n\n==: Takes two expressions, (A == B), and returns true if both expressions are equal.\n!=: Takes two expressions, (A != B), and returns true if both expressions are not equal.\n<: Takes two expressions, (A < B), and returns true if the left expression is numerically less than or comes lexically before the right one.\n<=: Takes two expressions, (A <= B), and returns true if the left expression is numerically less than or comes lexically before the right one, or if both expressions are equal.\n>: Takes two expressions, (A > B), and returns true if the left expression is numerically greater than or comes lexically after the right one.\n>=: Takes two expressions, (A >= B), and returns true if the left expression is numerically greater than or comes lexically after the right one, or if both expressions are equal.\nLogical Operators\n\nLogical operators return a true or false value based on the true or false values of the expressions they operate on. When expressions are numeric, a zero value is treated as false and a non-zero value is treated as true.\n\n&& AND operator: Takes two expressions, (A && B), and returns true if both expressions are true.\n|| OR operator: Takes two expressions, (A || B), and returns true if one of them is true.\n! NOT operator: Takes one expression, !(A), and returns true if its value is false.\nBitwise Operators\n\nBitwise operators manipulate the individual bits of their numeric expressions.\n\n& Binary AND Operator: Takes two expressions, (A & B), result will have a bit set if the corresponding bit in each expression is set.\n| Binary OR Operator: Takes two expressions, (A | B), result will have a bit set if either expression has the corresponding bit set.\n^ Binary XOR Operator: Takes two arguments, (A ^ B), result will have a bit set if only one corresponding bit is set between the two expressions.\n<< Binary Left Shift Operator: Takes two arguments, (A << B), result will be the first argument with its bits moved to the left the number of positions specified by the second.\n>> Binary Right Shift Operator: Takes two arguments, (A >> B), result will be the first argument with its bits moved to the right the number of positions specified by the second.\nAssignment Operators\n\nAssignment operators store the value of an expression into a variable. The variable being assigned to is always on the left.\n\n=: Assigns the value of the expression to the right to the variable on the left.\n\nC = A + B stores the value of A + B into the variable C.\n\n+=: Adds the value on the right to the value in the variable on the left and assigns it to the variable.\n\nC += A is the same as C = C + A.\n\n-=: Subtracts the value on the right from the value in the variable on the left and assigns it to the variable.\n\nC -= A is the same as C = C - A.\n\n*=: Multiplies the value on the right to the value in the variable to the left and assigns it to the variable.\n\nC *= A is the same as C = C * A.\n\n/=: Divides the value in the variable on the left by the value on the right and stores the result in the variable.\n\nC /= A is the same as C = C / A.\n\n%=: Performs an integer division of the value in the variable on the left by the value on the right and stores the remainder in the variable.\n\nC %= A is the same as C = C % A.\n\n<<=: Does a binary left shift operation on the value in the variable on the left by the number of positions specified on the right and stores the result in the variable.\n\nC <<= A is the same as C = C << A.\n\n>>=: Does a binary right shift operation on the value in the variable on the left by the number of positions specified on the right and stores the result in the variable.\n\nC >>= A is the same as C = C >> A.\n\n&=: Does a bitwise AND operation between the value in the variable on the left with the value on the right and stores the result in the variable.\n\nC &= A is the same as C = C & A.\n\n|=: Does a bitwise OR operation between the value in the variable on the left and the value on the right and stores the result in the variable.\n\nC |= A is the same as C = C | A.\n\n^=: Does a bitwise XOR operation between the value in the variable on the left and the value on the right and stores the value in the variable.\n\nC ^= A is the same as C = C ^ A."},{"title":"Loops","description":"There are several kinds of loops in Go, all written with a syntax similar to the for loop statement.\n\nThree-Component Loop\n\nIn Go, loops are defined with a three-component syntax similar to what is used in for loops for other languages like C or Java.\n\nSyntax\nfor init; condition; post {\n  statements\n}\n\nHere, the init statement initializes an index variable. Next, a condition is used to check the index variable against a boolean expression before every loop. As long as it’s true, the iteration will go forward and statements inside the loop will execute. Lastly, the post statement executes after every loop, usually to increment/decrement the index variable.\n\nExample\n\nThis example counts down from ten to one. The init statement sets the variable i to 10, the condition ends the loop when i is no longer greater than zero, and the post statement decrements i by one after each pass.\n\nfor i := 10; i > 0; i-- {\n  fmt.Println(i) // Counts down from 10 to 1\n}\nThe While Loop\n\nA “while” loop runs as long as the condition is true. In some languages, this is implemented with a while keyword. In Go, however, the “while” loop is implemented with a for loop by omitting the init and post statements.\n\nSyntax\nfor condition {\n  statements\n}\n\nThe loop will execute as long as condition remains true.\n\nExample\n\nThis example behaves exactly the same way as the prior example, except the variable countdown is initalized outside the loop, and is decremented inside the loop itself. The condition still runs the loop as long as countdown is still greater than zero.\n\ncountdown := 10\nfor countdown > 0 {\n  fmt.Println(countdown) // counts down from 10 to 1\n  countdown--\n}\nAn Infinite Loop\n\nIf the condition statement is omitted along with the post and init statements, the loop will execute indefinitely unless a break statement is encountered.\n\nSyntax\nfor {\n  statements\n}\nExample\n\nThis example will print the string “Help! I’m trapped in a loop!” until the program is halted externally.\n\nfor {\n  fmt.Println(\"Help! I'm trapped in a loop!\") // executes forever\n}\nA Range Loop\n\nBy using the range keyword, a for loop can step through the items in a collection such as a array, map, slice, channel, or string.\n\nSyntax\nfor index, value = range collection {\n  statements\n}\n\nWhere index is a variable containing the index of the collection, value is a variable used to step through the values in collection, and collection is the collection the loop is stepping through.\n\nExample\n\nIn the example below, a range loop steps through the elements of the slice numbers and prints the index-value pair for each element.\n\nnumbers := []string{\"One\",\"Two\",\"Three\"}\nfor i, n := range numbers {\n  fmt.Println(i,n)\n}\n\nThis example leads to the following output:\n\n0 One\n1 Two\n2 Three\nbreak and continue\n\nThe break and continue statements work in Go as they do in C and Java.\n\nA break statement halts execution of a loop and continues with the next statement after the loop.\nThe continue statement skips execution to the next iteration of the loop.\nCodebyte Example"},{"title":"Switch","description":"A switch statement allows the selective execution of one of several blocks of code based on the value of an expression. It can be thought of as an expanded if ... else statement, with many potential if clauses.\n\nSyntax 1\n\nThere are many syntaxes that can be used in the switch statement. The following is probably the most common:\n\nswitch <expression> {\ncase <value 1>:\n  <statements>\ncase <value 2>:\n  <statements>\n.\n.\n.\ncase <value N>:\n  <statements>\ndefault:\n  <statements>\n}\n\nWhen <expression> is equal to the value of one of the case statements, the corresponding <statements> block is executed. If the <expression> matches none of the case values, then the optional default statements block is executed. If the default block is omitted, and none of the values are matched, none of the statements in the switch block are executed.\n\nIn Go, the switch statement differs from other languages like C++ and Java in that the values used by the case statements are not limited to constants. They can also be variables or full expressions. Additionally, Go only executes the selected case <expressions> block, or the default block, so no “break” statement is needed. Code execution automatically resumes after the switch statement.\n\nSyntax 2\n\nThe <expression> after the switch can be omitted, making the cases behave more like expressions in if... else statements:\n\nswitch {\ncase <expression 1>:\n  <statements>\ncase <expression 2>:\n  <statements>\n    .\n    .\n    .\ncase <expression N>\n  <statements>\ndefault:\n  <statements>\n}\n\nThe first case <expression> that evaluates to true will execute its corresponding <statements>. Again, the default block is optional, and will execute its <statements> if none of the case statements are executed.\n\nThis is equivalent to:\n\nswitch true { ... }\nSyntax 3\n\nIn each case, a given case statement can have more than one matching value (or expression), separated by commas:\n\nswitch <expression> {\ncase <value 1>, <value 2>, ... <value N>:\n  <statements>\n    .\n    .\n    .\ndefault:\n  <statements>\n}\n\nValues are compared left-to-right and top-to-bottom. The first case block to match the switch expression will be executed.\n\nExample\n\nIn the example below, a variable i is declared and used in a switch expression to test whether the result will be even or odd:\n\ni := 7\nswitch i % 2 {\ncase 0:\n   fmt.Printf(\"%d is even.\\n\",i)\ncase 1:\n   fmt.Printf(\"%d is odd.\\n\",i)\n}\n\n\n// Output: 7 is odd.\nCodebyte Example"}],"HTML":[{"title":"Attributes","description":"Attributes can be added to the opening tag of an HTML element to change its default behavior or provide additional data about it.\n\nAttributes consist of a name and a value in the format name=\"value\":\n\n<tag name=\"value\"></tag>\n\nSo for example, the <img> image element has a mandatory src attribute that contains the image file path/URL:\n\n<img src=\"codecademy_logo.png\" />\nsrc is the attribute name.\ncodecademy_logo.png is the attribute value.\n\nHTML elements can have any number of attributes.\n\nThe example below displays an image element with three attributes:\n\n<img src=\"nyan_cat.gif\" width=\"500\" height=\"600\" />\n\nThese declare its source, width, and height.\n\nNote: Attribute names are not case-sensitive, but it is good practice to write HTML markup in lowercase.\n\nUnique ID Attributes\n\nSpecific and unique id attributes can be assigned to elements to differentiate them, and id values can be referenced in CSS and JavaScript to manipulate, format, and perform specific instructions on a single element alone, without affecting others of the same type.\n\nValid id attribute values begin with a letter and must comprise only letters (a-Z), digits (0-9), hyphens (-), underscores (_), and periods (.).\n\n<h1 id=\"th1s_is.v4lid\">Hello World</h1>\n\nNote: While th1s_is.v4lid is indeed a valid id value, it’s best to use a consistent naming scheme such as camel case (thisIsValid), dash case (this-is-valid), or snake case (this_is_valid).\n\nExample\n\nIn the example below, the <p> (paragraph) element is given a unique identifier in its id attribute, and the text color is set using the style attribute:\n\n<p id=\"my-paragraph\" style=\"color: aqua;\">\n  Here's some text that is being altered by the HTML attributes\n</p>"},{"title":"Classes","description":"Classes are HTML attributes used to select one or more elements for CSS styling or JavaScript purposes.\n\nFor Styling\n\nThe class attribute is commonly used for assigning styles to one or more elements. Multiple classes can be assigned to a single element in a space-separated list. (e.g. class=\"class1 class2 class3\")\n\nInside the stylesheet, a class name is selected with the following syntax:\n\n.class-name {\n}\n\nA class selector is a name preceded by a period (.).\n\nBelow is some markup with an outer wrapper-div, containing a level 1 heading and three level 2 sub-headings. The styling for the heading will be unique. However, all elements with the sub-heading class name received the same styling.\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <style>\n      .heading {\n        background-color: lightcoral;\n      }\n\n\n      .sub-heading {\n        background-color: lightskyblue;\n        margin: 5px;\n      }\n    </style>\n    <title>Classes</title>\n  </head>\n  <body>\n    <div class=\"wrapper-div\">\n      <h1 class=\"heading\">Welcome to Class!</h1>\n\n\n      <h2 class=\"sub-heading\">_</h2>\n\n\n      <h2 class=\"sub-heading\">_</h2>\n\n\n      <h2 class=\"sub-heading\">_</h2>\n    </div>\n  </body>\n</html>\n\nFor JavaScript\n\nThe class attribute can also be used to perform JavaScript operations on HTML elements. Through the Document Object Model (“DOM”), there are various JavaScript methods built for selecting elements via their class.\n\nAssuming the markup from the last example is linked to a JavaScript file:\n\nwindow.onload = function () {\n  const subheadings = document.getElementsByClassName('sub-heading');\n\n\n  for (let i = 0; i < subheadings.length; i++) {\n    subheadings.item(i).innerText = `Sub-heading ${i + 1}`;\n  }\n};\n\nThe code above is assigning an event handler to the onload property of the global window object in the browser. When the window as loaded, the elements with class=sub-heading are collected in subheadings. They are then looped over, their innerText property being changed each iteration."},{"title":"Comments","description":"HTML comments are used for documentation and excluding markup from being rendered. Like with comments in other languages, developers may also use HTML comments for historical or debugging purposes.\n\nSyntax\n\nHTML comments always start with an opening <!-- and end with a closing tag -->. They may contain anything from text to other markup that will not be rendered.\n\n<!-- Comments go between these tags. -->\n\nNested comments are not recommended because they may cause unexpected behavior. Comments generally end after the first closing tag -->. Anything after that will be rendered on the page, including all outer closing tags. Thus, when commenting out HTML code, developers should remove any interior comment tags (or at least the trailing ones -->).\n\n<!-- Outer comment <!-- Inner comment --> This text will render. -->\n\nThis example will render as follows:\n\nComments can also be placed anywhere inside another element.\n\n<p>Some text that <!-- This is a legal comment --> gets displayed</p>\n\nHowever, they cannot be placed inside the element tags themselves (e.g. between the left angle < and right angle bracket > of a tag).\n\n<p <!-- This is an illegal comment -->>Some more text.</p>\nExample\n<p>This will display.</p>\n<!--\n  <p>This will not</p>\n-->\n\nThis will render as follows:"},{"title":"Entities","description":"Entities are character sequences placed in the text of an HTML document to print out reserved characters which may otherwise be interpreted as HTML code by a browser, or other special characters that would be difficult to generate with a typical keyboard. In fact, using reference numbers, an entity can represent any Unicode character. When parsing the HTML, a browser replaces the entity’s character sequence with the character it represents.\n\nSyntax\n\nEntities are case-sensitive and can take one of three forms.\n\nThe first form references an entity by name:\n\n&name;\n\nThe second form references it by the decimal Unicode number:\n\n&#number;\n\nThe third represents it with the hexadecimal Unicode number, often with leading zeros:\n\n&#xnumber;\n\nSo the copyright entity (©) can be represented as &copy;, &#169 or &#x000A9;.\n\nEntity Values\n\nThere are many HTML entities. The following are some common ones:\n\nEntity Name\t1st Form\t2nd Form\t3rd Form\nNon-breaking space\t&nbsp;\t&#160;\t&#x000A0;\nLess-than sign <\t&lt;\t&#60;\t&#x0003C;\nGreater-than sign >\t&gt;\t&#62;\t&#x0003E;\nAmpersand &\t&amp;\t&#38;\t&#x00026;\nQuote \"\t&quot;\t&#34;\t&#x00022;\nApostrophe '\t&apos;\t&#39;\t&#x00027;\nCopyright ©\t&copy;\t&#169;\t&#x000A9;\nDegree °\t&deg;\t&#176;\t&#x000B0;\nEuro €\t&euro;\t&#8364;\t&#x020AC;\nBullet character •\t&bullet;\t&#8226;\t&#x02022;\n\nMore can be found in this extensive HTML 5 entity reference.\n\nThe Tab Entity\n\nThere is an entity &Tab; (or &#9;) which nominally produces a tab character. However, it will not behave as expected because HTML collapses whitespace where it appears in text with the exception of the non-breaking space entity, &nbsp;. So to render a tab in HTML text, it needs to be wrapped within a <pre> tag to preserve the whitespace.\n\n<p>The tab entity &Tab; in this sentence is collapsed</p>\n\n\n<pre>\n  <p>The Tab entity &Tab; in this sentence is preserved</p>\n</pre>\n\nAlternatively, four &nbsp; entities can be used.\n\n<p>The Tab entity &Tab; in this sentence is collapsed.</p>\n\n\n<p>The spaces &nbsp;&nbsp;&nbsp;&nbsp; in this sentence are preserved.</p>"},{"title":"Elements","description":"An HTML element is a piece of content in an HTML document. It is everything from the opening tag to the closing tag.\n\nSyntax\n\nHTML elements typically use the following syntax:\n\n<opening tag> content </closing tag>\nExample\n<p>Hello World!</p>\n<p> is the opening tag.\nHello World! is the content.\n</p> is the closing tag.\n\nNote: Some HTML elements have no content, like the <br> element. These elements are called empty elements. Empty elements do not have a closing tag, so they are referred to as self-closing. Also, self-closing tags such as <br> can have a slash at the end like so: <br />.\n\nNested HTML Elements\n\nHTML elements can be nested, which means that elements can contain other elements inside them, or nested. All HTML documents consist of nested HTML elements.\n\nThe following example contains four HTML elements: <html>, <body>, <h1>, and <p>:\n\n<!DOCTYPE >\n<html>\n  <body>\n    <h1>Blog Post</h1>\n    <p>My first paragraph.</p>\n  </body>\n</html>\nHTML Structure\n\nHTML is organized into a family tree structure. HTML elements can have parents, grandparents, siblings, children, grandchildren, etc.\n\n<body>\n  <div>\n    <h1>Heading 1</h1>\n    <h2>Heading 2</h2>\n  </div>\n</body>\n\nHere are the relationships depicted above in relation to the <h1> tag:\n\n<h1> is the child of <div>\n<div> is the parent of the <h1>\n<h1> is the grandchild of <body>\n<body> is the grandparent of the <h1>\n<h1> is the sibling of <h2>"},{"title":"Forms","description":"The HTML <form> element is used to collect and send information to an external source.\n\n<form> can contain various input elements. When a user submits the form, information in these input elements is passed to the source which is named in the action attribute of the form.\n\nSyntax\n<form method=\"post\" action=\"http://server1\">\n  Enter your name:\n  <input type=\"text\" name=\"fname\" />\n  <br />\n\n\n  Enter your age:\n  <input type=\"text\" name=\"age\" />\n  <br />\n\n\n  <input type=\"submit\" value=\"Submit\" />\n</form>\nSubmitting a Form\n\nOnce we have collected information in a form we can send that information somewhere else by using the action and method attribute:\n\nThe action attribute tells the form to send the information. A URL is assigned that determines the recipient of the information.\nThe method attribute tells the form what to do with that information once it’s sent. An HTTP verb is assigned to the method attribute that determines the action to be performed.\n<form action=\"/index3.html\" method=\"PUT\"></form>\nRequired Attribute\n\nIn HTML, input fields have an attribute called required which specifies that the field must include a value.\n\nThe example code block shows an input field that is required. The attribute can be written as required=\"true\" or simply required.\n\n<input type=\"password\" name=\"password\" required />"},{"title":"File Paths","description":"A file path describes the location of a file in a web site’s folder structure. They are used to link to external files, like:\n\nWebsites\nImages\nVideos\nMP3 files\nStyle sheets\nJavaScript code\nAbsolute File Paths\n\nURL paths in HTML can be absolute paths, like a full URL, for example:\n\nhttps://codecademy.com/resources/docs\n\n<a href=\"https://www.codecademy.com/resources/docs\">\n  The URL for this anchor element is an absolute file path.\n</a>\nRelative File Paths\n\nRelative file path are paths that links to a local file in the same folder or on the same server, for example:\n\n./about.html\n./style.css\n./images/logo.png\n\nRelative file paths begin with ./ followed by a path to the local file. ./ tells the browser to look for the file path from the current folder.\n\n<a href=\"./about.html\">\n  The URL for this anchor element is a relative file path.\n</a>\nLink to a Specific Part of the Page\n\nThe anchor element <a> can create hyperlinks to different parts of the same HTML document using the href attribute to point to the desired location with # followed by the id of the element to link to.\n\n<div>\n  <p id=\"id-of-element-to-link-to\">A different part of the page!</p>\n</div>\n\n\n<!-- Later in the page --->\n\n\n<a href=\"#id-of-element-to-link-to\">Take me to a different part of the page</a>"},{"title":"IFrames","description":"IFrame (Inline Frame) is an HTML document embedded inside another HTML document on a website. It provides a smaller version of a browser window that contains various media, such as an advertisement, a YouTube video, etc.\n\nThese smaller windows are known as “browsing contexts”, because the URL passed to the iframe element is still functional as a web page. This makes their usage somewhat controversial as many commercial websites have safeguards against their URL being passed to this particular element.\n\nExample\n\nThe example features an iframe element with the URL from the National Park Service passed to the src attribute. Additionally, it is advisable to include alternative text inside the element in the event a problem occurs.\n\n<iframe\n  class=\"i-frame-element\"\n  src=\"https://www.nps.gov/caco/index.html\"\n  width=\"100vw\"\n  height=\"1000\"\n>\n  Alt-text for IFrame\n</iframe>"},{"title":"Headings","description":"Among the HTML elements are the 6 heading elements. They are labeled 1-6, with 1 being the largest sized heading and 6 being the smallest. These are great for labeling different sections in a website:\n\n<h1>Heading 1</h1>\n<h2>Heading 2</h2>\n<h3>Heading 3</h3>\n<h4>Heading 4</h4>\n<h5>Heading 5</h5>\n<h6>Heading 6</h6>\nHeading 1\nHeading 2\nHeading 3\nHeading 4\nHeading 5\nHeading 6\nAccessibility with Headings\n\nEach heading has semantic meaning for the overall structure of a page. Headings have affects on how well a page performs with SEO and how devices like screen readers can access them. Here are a few best practices for using heading elements in an accessible and SEO-friendly way:\n\nKeep it to one <h1> element to one page. This element should be associated with the main topic of the page.\nDo not skip levels. Go from <h1> to <h2> and so on.\nAvoid nesting headings too deeply so they aren’t skipped."},{"title":"Images","description":"While many websites are primarily text, embedding images using HTML within a site allows for more lively pages that can be more attractive and informative to visitors. However, when serving images, there are concerns of the impact to page loading speeds as well as to accessibility, so knowledge on how images can be best served to users is critical for good development.\n\nChoosing an Image Format\n\nAs images make up most of the bandwidth for a standard webpage, and therefore can slow the speed of page loads, it is best to optimize the size of images as much as possible ahead of time. While there are a myriad of image formats available, only a few key formats are needed for most use cases:\n\nJPEG: Best for minimizing image sizes at the cost of some graphical fidelity\nPNG: Best for images where graphical fidelity is of the upmost importance\nSVG: Best for vector images, such as simple symbols and shapes\n\nThere are also new image formats such as AVIF and WebP that are attempting to replace JPEG. While their browser support may currently be limited, their reductions in file sizes are significant.\n\nInserting and Sizing an Image\n\nBelow is an example of how an image is commonly inserted into a page using the HTML image tag, <img>:\n\n<img src=\"logo.png\" alt=\"Codecademy logo\" />\n\nIt is recommended to describe image dimensions using percents of the current screen size to best support both smaller mobile devices as well larger workstations. The below image would take up the top half of any screen, regardless of its size:\n\n<img src=\"logo.png\" alt=\"Codecademy logo\" height=\"50%\" width=\"100%\" />\n\nHowever, this may lead to stretched images on wider screens, so setting a maximum width may be preferred:\n\n<img src=\"logo.png\" alt=\"Codecademy logo\" height=\"50%\" max-width=\"800px\" />\n\nTo only serve higher resolution images to certain devices with higher resolution screens, the srcset attribute can be used. srcset allows the browser to choose an image based on the given amount of pixels on the screen. For example, to serve users with ultra-wide screens a larger, high-resolution image of a logo, as well as provide support for standard desktop and mobile sizes, the following HTML <img> element can be used:\n\n<img\n  src=\"logo-mobile.png\"\n  srcset=\"logo-desktop.png 1000w, logo-ultra-wide-hires.png 2000w\"\n  alt=\"Codecademy logo\"\n/>\n\nNote: srcset is intended only to serve the same image at different resolutions. This is to save bandwidth by providing higher-quality images only to the devices that can support it. To serve different images for other uses, such as for artistic direction or to support cutting-edge filetypes such as AVIF and WebP, it is best to use the <picture> element. <picture> elements are a collection of <source> elements ordered in terms of preference with an <img> element as fallback. For example, to prefer to serve an AVIF image, that falls back to a WebP image if that is not supported, and finally resort to a JPEG image if neither of those are available, use the following <picture> element:\n\n<picture>\n  <source srcset=\"logo.avif\" type=\"image/avif\" />\n  <source srcset=\"logo.webp\" type=\"image/webp\" />\n  <img src=\"logo.jpeg\" alt=\"Codecademy logo\" />\n</picture>\nAccessibility with Images and Semantic HTML\n\nThe goal of creating accessible images is to convey the same content and function that the image would normally provide to those people that are not able to view it. Images are an important tool for communication. Accessible images should not impede that goal, but instead communicate that content to even more users.\n\nThis is best done by the alternate text attribute required with each image. As an image is typically intended to convey a message, to best serve the users who cannot view that image, the same message needs to be conveyed in textual form. This should leave any user able to properly consume the entirety of the content, regardless of ability.\n\nThe semantic <figure> element serves a similar purpose to the alternate text attribute by providing additional context to browsers and screen readers. It is a self-contained image within the main flow of content, and usually paired with a <figcaption> child element to provide additional context to the reader. Note that the use of the <figcaption> does not replace the need for an alt attribute for the corresponding image.\n\n<figure>\n  <img src=\"logo.png\" alt=\"Codecademy logo\" />\n  <figcaption>The Codecademy logo</figcaption>\n</figure>"},{"title":"Links","description":"The anchor element <a> is used to link to another page or to a certain part of the page if you use its id. And the <link> element defines a link between a document and an external resource.\n\n<a> links are visible to the end users, whereas <link> links are not.\n\nAnchor Element\n\nThe <a> anchor element is used to create hyperlinks in an HTML document. The hyperlinks can point to other webpages, files on the same server, a location on the same page, or any other URL using the hyperlink reference attribute, href.\n\nThe href determines the location the anchor element points to.\n\nText Link\n<!-- Creating a text link -->\n\n\n<a href=\"http://www.codecademy.com\">Visit this site</a>\nImage Link\n<!-- Creating an image link -->\n\n\n<a href=\"http://www.codecademy.com\"> <img src=\"logo.jpg\" />Click this image </a>\nLink Element\n\nThe <link> is used to connect the document to an outside resource, most commonly stylesheets. Unlike most elements, which come as opening and closing tags, the <link /> is self-closing and only contains attributes.\n\nThe two primary attributes are:\n\nA rel to describe the format of the external source.\nAn href that contains the filepath to the external source.\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Links in HTML</title>\n    <link rel=\"stylesheet\" href=\"some/outside/source.css\" />\n  </head>\n  <body>\n    ...\n  </body>\n</html>"},{"title":"Paragraphs","description":"Paragraph element <p> contains and displays a block of text. They are among the most common text-based HTML elements.\n\nThey are block-level, which means it is as wide as it’s parent element and as tall as its content’s height.\n\nSyntax\n\nThe pargraph element is enclosed by an opening <p> tag and a closing </p> tag:\n\n<p>\n  This is a block of text! Lorem ipsum dolor sit amet, consectetur adipisicing\n  elit.\n</p>\nExample\n<!DOCTYPE html>\n<html>\n  <body>\n    <div style=\"width: 50%; margin: auto; border: 2px solid black;\">\n      <p style=\"padding: 10px; font-family: system-ui;\">\n        It was love at first sight. The first time Yossarian saw the chaplain he\n        fell madly in love with him. Yossarian was in the hospital with a pain\n        in his liver that fell just short of being jaundice.\n      </p>\n    </div>\n  </body>\n</html>\n\nAccessibility with Paragraphs\n\nParagraphs are relatively easy for accessibility devices, such as screen readers, to find and process. The more <p> elements, the better."},{"title":"Lists","description":"The <li> list item element create list items inside:\n\nOrdered lists <ol>\nUnordered lists <ul>\n<ol> Ordered List Element\n\nThe ordered list <ol> element creates a list of items in sequential order.\n\n<ol>\n  <li>Preheat oven to 325 F 👩‍🍳</li>\n  <li>Drop cookie dough 🍪</li>\n  <li>Bake for 15 min ⏰</li>\n</ol>\n\nEach list item appears numbered by default:\n\nPreheat oven to 325 F 👩‍🍳\nDrop cookie dough 🍪\nBake for 15 min ⏰\n<ul> Unordered List Element\n\nThe unordered list <ul> element is used to create a list of items in no particular order.\n\n<ul>\n  <li>Play more music 🎸</li>\n  <li>Read more books 📚</li>\n</ul>\n\nEach individual list item will have a bullet point by default:\n\nPlay more music 🎸\nRead more books 📚\nNesting Lists Elements\n\nLists can be nested, meaning one list can be placed inside of another.\n\n<ol>\n  <li>Fruits</li>\n  <ul>\n    <li>Apples 🍎</li>\n    <li>Oranges 🍊</li>\n  </ul>\n  <li>Vegetables</li>\n  <ul>\n    <li>Tomatoes 🍅</li>\n  </ul>\n</ol>\n\nThis way, multilevel lists can be created with different indentations.\n\nFruits\nApples 🍎\nOranges 🍊\nVegetables\nTomatoes 🍅"},{"title":"Tables","description":"In HTML, a table is an element that allows for the representation of data in two dimensions; these dimensions are columns and rows.\n\nExample\nName\tLocation\tCategory\tFounded\tCEO\tInfo\nPied Piper\tSilicon Valley\tCloud Computing\t2014\tRichard Hendricks\tA Middle-Out Compression Solution\nHooli\tSilicon Valley\tEnterprise\t1997\tGavin Bensen\tHooli is About People\nRaviga Capital\tSilicon Valley\tVenture Capital\t2012\tPeter Gregory\tShare Only in Success\nAviato\tSilicon Valley\tTravel\t2006\tErlich Bachman\tSoftware Aggregation Program\nSee Food\tSilicon Valley\tMobile\t2016\tJian-Yang\tThe Shazam of Food\nStructure\n\nTables are composed of multiple smaller types of elements that have special meaning within the structure of the table. The elements that are used in the construction of a typical table are as follows:\n\nTable\n\nThe <table> element itself serves as the container for all elements and information contained within the table including headers, columns, and rows.\n\nTable Row\n\nThe table row element, denoted as <tr>, is used to display data within a row (horizontally) in a table. Table rows do not display data on their own. Instead, table rows serve as a container for child elements that are responsible for displaying the data in a semantic way.\n\n<table>\n  <tr>\n    ...\n  </tr>\n</table>\nTable Header\n\nThe table header element, denoted as <th>, is used to display data for a specific column header within a table. Multiple <th> elements can be added as children to a table row at the top of a table to create a complete header for a table.\n\n<table>\n  <tr>\n    <th>Heading 1</th>\n    <th>Heading 2</th>\n    <th>Heading 3</th>\n  </tr>\n</table>\nHeading 1\tHeading 2\tHeading 3\nTable Data\n\nThe table data element, denoted as <td>, is used to display individual data within a specific row/column position in a table. Table data elements are included as children of table rows to properly coordinate their positioning within the structure of a table.\n\n<table>\n  <tr>\n    <th>Heading 1</th>\n    <th>Heading 2</th>\n    <th>Heading 3</th>\n  </tr>\n  <tr>\n    <td>Cell 1</td>\n    <td>Cell 2</td>\n    <td>Cell 3</td>\n  </tr>\n  <tr>\n    <td>Cell 4</td>\n    <td>Cell 5</td>\n    <td>Cell 6</td>\n  </tr>\n</table>\nHeading 1\tHeading 2\tHeading 3\nCell 1\tCell 2\tCell 3\nCell 4\tCell 5\tCell 6\nUses\n\nGenerally, tables are used to display tabular data in particular. In the past, tables were sometimes used to display data that was not tabular in nature due to constraints present within browser environments. In modern development, the use of tables to position elements not semantically related to a table is an anti-pattern and should be avoided."},{"title":"Semantic HTML","description":"Semantic HTML introduces meaning to the code we write.\n\nBefore Semantic HTML the elements didn’t have any meaning as to what it does or what content goes in it. An element such as <div> was used as a general-purpose element to create things from headers to footers to articles.\n\n<!-- Non Semantic HTML -->\n<div id=\"footer\">\n  <p>This is a footer</p>\n</div>\n\nWith Semantic HTML, we were introduced to elements that tell developers and browsers exactly what it does and what content should go in it.\n\n<!-- Semantic HTML -->\n<footer>\n  <p>This is a footer</p>\n</footer>\nWhy Use Semantic HTML?\n\nAccessibility: Semantic HTML makes webpages accessible for mobile devices and for people with disabilities as well. This is because screen readers and browsers are able to interpret the code better.\n\nReadability: Semantic HTML also makes the website’s source code easier to read for other web developers.\n\nSEO: It improves the website SEO, or Search Engine Optimization, which is the process of increasing the number of people that visit your webpage. With better SEO, search engines are better able to identify the content of your website and weight the most important content appropriately."},{"title":"Text Formatting","description":"There are two ways to format text with HTML. One way is to use HTML tags, which specify some characteristic of the text that should cause it to render differently. The other way is to use CSS typography properties to define specific formatting for a text element.\n\nNote: Modern HTML specifications eschew using HTML tags to specify specific formatting of elements (bold, underline, italic etc.), instead using HTML to describe the characteristics of the text, allowing the software rendering the HTML to decide how tags are displayed. Best practice to define specific styling of text is to use CSS.\n\nHTML Tags\n\nThe following HTML tags can affect the formatting of text:\n\n<b>: Represents text that the reader’s attention should be directed to, without further significance. Usually displayed with boldface.\n<em>: Represents text which is emphasized. Usually displayed with italics.\n<h1> - <h6>: Represents various heading levels for text. Usually affects font size and weight.\n<i>: Represents text set off as an idiomatic expression, technical term, taxonomical designation and so on. Usually displayed with italics.\n<strong>: Represents text that is urgent or important. Usually displayed with boldface.\n<u>: Represents text to be displayed with a non-textual annotation. Usually displayed using a solid underline.\n\nWhile legacy usage of the <b>,<i>, and <u> tags were to explicitly format text in a HTML document, that use has been depreciated. These tags now indicate characteristics of the text without specifying a definitive format for how it is rendered. If a specific specified format is required, CSS should be used.\n\nStyle HTML Using CSS\n\nTo render text with some specific format, CSS is used. CSS can be applied using a stylesheet or using the style attribute. The following CSS properties can be used to format text:\n\n@font-face: Specifies a custom font to be used to display text.\nfont: Shorthand property that sets different properties for an element’s font in a single declaration.\nfont-family: Specify the typeface.\nfont-size: Sets the text size.\nfont-style: To set the font style in which text will appear. Should be used instead of <i> to display italics.\nfont-weight: To set the text to be thicker or thinner. Should be used instead of <b> to make text bold.\ntext-decoration: To add lines on the text. Should be used instead of <u> to underline text.\ntext-shadow: Adds shadow to text."},{"title":"Tags","description":"A HTML tag is commonly defined as a set of characters constituting a formatted command for a web page. During the early days of the World Wide Web, they were responsible for a majority of the web’s code.\n\nHere are some of the most common HTML tags ordered alphabetically:"},{"title":"Videos","description":"Embedding videos within a site creates more lively and informative pages that are more attractive to visitors. Similar to serving images, serving video raises concerns on the impact to users due to the higher bandwidth requirements as well as the less accessible nature of the medium.\n\nChoosing a Video Codec and Format\n\nUnless videos are preloaded or set to automatically play, their impact on page speed should be minimal. However, attention should be paid to video file sizes to guarantee that the greatest numbers of users can stream them.\n\nVideos typically contain multiple items: the collection of images that is the video, the audio accompanying those images, and any number of subtitles or captions. Therefore there is a distinction between the format of the codec used to encode each of these individual items as well as the format of the container meant to package it all together. Container and codec support is browser dependent, with the latest generation of codecs attempting to provide even better video compression with less quality loss.\n\nMP4 is not only the most widely supported container format, but also supports the largest number of codecs, so it is the default option for containers. The situation for audio codecs is similar, with AAC being the default due to its good compression and wide spread use. For video codecs there are two main options: H.264 for if support is of the upmost concern and AV1 for streaming the absolute smallest files at a given quality.\n\nIn summary there are two main media stacks:\n\nContainer Format\tVideo Codec\tAudio Codec\tUse Case\nMP4\tH.264\tAAC\tCompatible with most every browser\nMP4\tAV1\tAAC\tBetter compression with better quality, but less compatible\nInserting a Video\n\nBelow is an example of how a video is commonly inserted into a page:\n\n<video controls poster=\"spooky_ghost.jpg\">\n  <source type=\"video/mp4\" src=\"spooky_ghost.mp4\" />\n\n\n  Sorry, your browser doesn't support this video. Click\n  <a href=\"spooky_ghost.mp4\">here</a> to download it instead.\n</video>\n\nThis example:\n\nSets the control attribute to have the browser offer playback controls to the user\nProvides a thumbnail for the video with poster=\"spooky_ghost.jpg\"\nDeclares the source file for the video, spooky_ghost.mp4, and its MIME type, video/mp4\nProvides a fallback text that allows the user to download the video instead\n\nSources are written in preference order, so that the first source listed is played if the browser supports it, with the subsequent sources acting as a fallback. This is usually used to try newer video formats while also providing a fallback for better compatibility. To modify the original example to support the AV1 video codec and fallback to the H.264 video codec:\n\n<video controls poster=\"spooky_ghost.jpg\">\n  <source type=\"video/mp4\" src=\"spooky_ghost_av1.mp4\" />\n  <source type=\"video/mp4\" src=\"spooky_ghost_h264.mp4\" />\n\n\n  Sorry, your browser doesn't support this video. Click\n  <a href=\"spooky_ghost_h264.mp4\">here</a> to download it instead.\n</video>\nAccessibility with Videos\n\nIt is generally discouraged to use videos as the background for a webpage. In many cases a static image should be considered instead in order to avoid any potential issues caused by moving images as well as to better support users with screen readers. However, if a video must be used as a background, a few key steps should be taken to best support the most users:\n\nIf the video is purely decorative, use aria-hidden=\"true\" to denote to screen readers that the video provides no additional context or content and is purely decorative\nUse the prefers-reduced-motion CSS media query in order to disable autoplaying videos for certain users\n\nTo convey the same content to users who are not able to view videos, provide either sufficient captions or aria descriptons for the video.\n\nCaptions can be added as a child of the <video> element using the <track> tag with the following key attributes:\n\nkind to describe the text track. Here is it is a caption, but it can also be subtitles or metadata\nlabel is how this option is represented in the user interface\nsrclang represents the language for the caption\nsrc is the actual location of the caption track. Text tracks such as subtitles and captions use the WebVTT format as indicated by the .vtt extension.\n<video controls poster=\"spooky_ghost.jpg\">\n  <source type=\"video/mp4\" src=\"spooky_ghost_av1.mp4\" />\n  <source type=\"video/mp4\" src=\"spooky_ghost_h264.mp4\" />\n  <track\n    kind=\"caption\"\n    label=\"English\"\n    srclang=\"en\"\n    src=\"spooky_ghost-en.vtt\"\n  />\n  <track\n    kind=\"caption\"\n    label=\"Español\"\n    srclang=\"es\"\n    src=\"spooky_ghost-es.vtt\"\n  />\n\n\n  Sorry, your browser doesn't support this video. Click\n  <a href=\"spooky_ghost_h264.mp4\">here</a> to download it instead.\n</video>"}],"Java":[{"title":"ArrayList","description":"The ArrayList class uses dynamic arrays that are resizable, unlike traditional fixed arrays. However, each element must still be of the same type. Elements can be added or removed at any time, making the ArrayList more flexible.\n\nSome other important points about the ArrayList class include:\n\nIt has the ability to contain duplicate elements.\nIt maintains insertion order.\nIt is non-synchronized and, therefore, not safe for multiple threading.\nIt allows random access since arrays work on an index basis.\nThe space/time complexity is a bit slower than a LinkedList due to the nature of adding/removing elements.\nSyntax\n\nThis class is imported with the java.util package.\n\nimport java.util.ArrayList;\n\nThe syntax for defining an instance of ArrayList is similar to defining a traditional array. A key difference is that angle brackets <> are used instead of square brackets:\n\nArrayList<DataType> arrayListInstance = new ArrayList<DataType>();\nExample\n\nIn the example below, a new ArrayList instance arr is defined. There are print statements throughout to show elements being added to and removed from arr before it is ultimately cleared:\n\n// Import from the java.util package\nimport java.util.ArrayList;\n\n\npublic class Example {\n  public static void main(String []args) {\n    ArrayList<String> arr = new ArrayList<>();\n\n\n    System.out.println(arr);  // Currently empty\n\n\n    arr.add(\"hello\");\n    arr.add(\"India\");\n\n\n    System.out.println(arr);\n\n\n    arr.remove(\"hello\");\n\n\n    System.out.println(arr.size());  // Prints size of ArrayList\n\n\n    arr.clear();\n\n\n    System.out.println(arr); // Empty again\n  }\n}\n\nThe output would be:\n\n[]\n[hello, India]\n1\n[]"},{"title":"Classes","description":"In Java, classes are blueprints or templates for objects in Java. They detail the general structure and data for an object including information such as properties, attributes, and method behavior.\n\nSyntax\naccessModifier class ClassName {\n  dataType attributeOne;\n  dataType attributeTwo;\n  dataType attributeN;\n\n  static void classMethod {\n    // Method code here\n  }\n}\nClass names must always be in “PascalCase” and match the name of the file (e.g. ClassName.java).\nJava uses the class keyword for creating classes.\nThey use an accessModifier (public, private, and protected) to determine its visibility to other files.\nInside the class “blueprint” are members.\nClass Instances\n\nIn Java, instances are objects that are based on existing classes.\n\nEvery instance has access to its own set of variables known as instance fields. These are variables declared within the scope of the instance and supplied with new values within the class constructor method during initialization.\n\nFor example, Bob and Alice may each be defined as instances of the class called Person with the new keyword:\n\npublic class Person {\n  int age;\n  String name;\n\n\n  // Constructor method\n  public Person(int age, String name) {\n    this.age = age;\n    this.name = name;\n  }\n\n\n  public static void main(String[] args) {\n    Person Bob = new Person(31, \"Bob\");\n    Person Alice = new Person(27, \"Alice\");\n\n\n    System.out.println(Bob.name + \" is \" + Bob.age + \".\");\n    System.out.println(Alice.name + \" is \" + Alice.age + \".\");\n  }\n}\n\nEach instance of the Person class has an age and name field. When initialized, they are passed as arguments into the class contstructor. The example from above would return the following output:\n\nBob is 31.\nAlice is 27.\nAbstract Classes\n\nClasses can also use the abstract keyword to supply common method implentations to multiple subclasses. Any class that contains abstraction (e.g. methods, fields, etc.), then it must also be abstract:\n\nabstract class Person {\n  int age;\n  String name;\n\n\n  abstract void talk(String message);\n}"},{"title":"Arrays","description":"In Java, an array is used for storing elements of the same data type in a fixed-sized collection, ordered by insertion. Being fixed in size means that unlike with ArrayList, elements cannot be removed or added after the array has been created. They can only be modified.\n\nSyntax\n\nArray variables are defined with a type followed by square brackets []. Next, the actual elements are comma-separated and surrounded by curly brackets {}:\n\ndataType[] varName = {elemOne, elemTwo, elemThree, elemN};\n\nAlternatively, an array can be defined with the new keyword, the arrayLength integer defined, and each of the elements defined afterward:\n\ndataType[] varName = dataType[arrayLength];\n\nvarName[0] = valueOne;\nvarName[1] = valueTwo;\nvarName[n] = valueN;\n\nIt is important the referenced index is valid. Otherwise, an ArrayIndexOutOfBoundsException will be thrown.\n\nExample\n\nIn the example below, an array can be created in the following ways:\n\nint[] semesterOneMarks = {10, 20, 30, 40, 50};\n\n\nString[] semesterOneCourses = new String[5];\n\n\nsemesterOneCourses[0] = \"Algebra\";\nsemesterOneCourses[1] = \"World History\";\nsemesterOneCourses[2] = \"Literature\";\nsemesterOneCourses[3] = \"Programming\";\nsemesterOneCourses[4] = \"Gym\";\n\nElements within the array can be accessed and changed as well:\n\nSystem.out.print(semesterOneCourses[0] + \": \");\nSystem.out.println(semesterOneMarks[0]);\n\n\n// Changed from \"World History\" to \"History\"\nsemesterOneCourses[1] = \"History\";\nSystem.out.print(semesterOneCourses[1] + \": \");\nSystem.out.println(semesterOneMarks[1]);\n\n\nSystem.out.print(semesterOneCourses[2] + \": \");\nSystem.out.println(semesterOneMarks[2]);\n\n\nSystem.out.print(semesterOneCourses[3] + \": \");\nSystem.out.println(semesterOneMarks[3]);\n\n\nSystem.out.print(semesterOneCourses[4] + \": \");\nSystem.out.println(semesterOneMarks[4]);\n\nThe output will look like this:\n\nAlgebra: 10\nHistory: 20\nLiterature: 30\nProgramming: 40\nGym: 50"},{"title":"Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.\n\nSingle-line Comments\n\nIn Java, single-line comments are created with two consecutive forward slashes //.\n\n// I am a single-line comment!\nSystem.out.println('Hello, world!');\n\nA single-line comment can also be used to comment after a line of code:\n\nSystem.out.println('Hello, world!'); // Me, too!\nMulti-line Comments\n\nMulti-line comments are created by surrounding the lines with /* at the beginning and */ at the end. Comments are good ways for a variety of reasons like explaining a code block or indicating some hints, etc.\n\n/*\nAnd I am a\nmulti-line comment!\n*/"},{"title":"Conditionals","description":"Conditionals take an expression, which is code that evaluates to determine a value, and checks if it is true or false. If it’s true, we can tell our program to do one thing — we can even account for false to do another.\n\nAs we write more complex programs, conditionals allow us to address multiple scenarios and make our programs more robust.\n\nIf Statement\n\nAn if statement executes a block of code when a specified boolean expression is evaluated as true; otherwise, the block of code will be skipped.\n\nif (berries > 5) {\n  System.out.println(\"More than a handful of berries.\");\n}\nElse\n\nAn else clause can be added to an if statement.\n\nThe else statement executes a block of code when the condition inside the if statement is false:\n\nIf the condition evaluates to true, code in the if part is executed.\nIf the condition evaluates to false, code in the else part is executed.\n\nThe else statement is always the last condition.\n\nif (year == 2022) {\n  System.out.println(\"Print if year is 2022\");\n}\nelse {\n  System.out.println(\"Print if year is not 2022\");\n}\nElse If\n\nelse if statements can be chained together to check multiple conditions. Once a condition is true, a code block will be executed and the conditional statement will be exited.\n\nThere can be multiple else if statements in a single conditional statement.\n\nint testScore = 76;\nchar grade;\n\n\nif (testScore >= 90) {\n  grade = 'A';\n} else if (testScore >= 80) {\n  grade = 'B';\n} else if (testScore >= 70) {\n  grade = 'C';\n} else if (testScore >= 60) {\n  grade = 'D';\n} else {\n  grade = 'F';\n}\n\n\nSystem.out.println(\"Grade is \" + grade);\n// Ouptut: Grade is C\nNested Conditional Statements\n\nA nested conditional statement is a conditional statement nested inside another conditional statement. The outer conditional statement is evaluated first; if the condition is true, then the nested conditional statement will be evaluated.\n\nboolean studied = true;\nboolean wellRested = true;\n\n\nif (wellRested) {\n  System.out.println(\"Best of luck today!\");\n  if (studied) {\n    System.out.println(\"You are prepared for your exam!\");\n  } else {\n    System.out.println(\"Study before your exam!\");\n  }\n}\n\nThe output would be:\n\nOutput: Best of luck today!\nOutput: You are prepared for your exam!"},{"title":"Constructors","description":"Constructors are like normal methods within the class but are used to initialize the object of the class.\n\nIn Java, every time the new keyword is used to create an object, at least one constructor is called.\n\nTypes of Constructors\nDefault constructor: These constructors do not accept any parameters.\nParameterized constructor: These constructors accept a specific number of parameters.\nCreating Constructors\n\nHere are some rules for creating constructors:\n\nConstructors always have same name as their class name.\nConstructors cannot be declared as abstract, static, final, and synchronized.\nConstrutors do not have any explicit return types.\nCreating a Default Constructor\n\nHere, the Tree class has a default constructor named Tree() with no parameters. When the instance of the class is created in main(), the constructor is called.\n\nclass Tree {\n  // Creating a default constructor\n  Tree() {\n    System.out.println(\"Tree is created\");\n  }\n\n\n  public static void main(String args[]) {\n    Tree t = new Tree();  // Calling a default constructor\n  }\n}\n\n\n// Output: Tree is created\nCreating a Parameterized Constructor\n\nHere, the Employee class has a parameterized constructor which takes parameters int i and string n respectively. These values are passed while creating an instance of class in main().\n\nclass Employee {\n  int id;\n  String name;\n\n\n  // Creating a parameterized constructor\n  Employee(int i, String n) {\n    id = i;\n    name = n;\n    System.out.println(id + \" \" + name);\n  }\n\n\n  public static void main(String args[]) {\n    Employee e = new Employee(110, \"Ashish\"); // Creating objects and passing values\n  }\n}\n\n\n// Output: 110 Ashish"},{"title":"Data Types","description":"Primitive Data Types\n\nJava’s most basic data types are known as primitive data types and are in the system by default.\n\nThe available types are as follows:\n\nint\nchar\nboolean\nbyte\nlong\nshort\ndouble\nfloat\n\nnull is another, but it can only ever store the value null.\n\nint age = 28;\nchar grade = 'A';\nboolean late = true;\nbyte b = 20;\nlong num1 = 1234567;\nshort no = 10;\nfloat k = (float)12.5;\ndouble pi = 3.14;\nStatic Typing\n\nIn Java, the type of variable is checked at compile time. This is known as static typing. It has the advantage of catching the errors at compile time rather than at execution time.\n\nVariables must be declared with the appropriate data type or the program will not compile.\n\nint i = 10;           // Type is int\nchar ch = 'a';        // Type is char\n\n\nj = 20;               // Won't compile, no type is given\nchar name = \"Sonny\";  // Won't compile, wrong data type"},{"title":"Enums","description":"Enumeration (enum) is a special user defined type where we specify a set of values for a variable and the variable can only take one out of a small set of possible values.\n\nThe keyword enum is used to define an enumeration.\n\nAn enum can contain constants, methods, etc.\n\nSyntax\n\nHere’s the basic syntax for creating an enum:\n\npublic enum name {\n  constant1,\n  constant2,\n  ...\n}\n\nHere’s an enum with compass directions:\n\npublic enum Direction {\n  NORTH, SOUTH, EAST, WEST\n}\nDirection.NORTH will have a value of 0.\nDirection.SOUTH will have a value of 1.\nDirection.EAST will have a value of 2.\nDirection.WEST will have a value of 3.\nExample\npublic enum Day {\n  SUN, MON, TUE, WED,\n  THU, FRI, SAT\n}\nDay.SUN will have a value of 0.\nDay.MON will have a value of 1.\nDay.TUE will have a value of 2.\nDay.WED will have a value of 3.\nDay.THU will have a value of 4.\nDay.FRI will have a value of 5.\nDay.SAT will have a value of 6.\n\nTo access one of the values:\n\nDay day = Day.MON;"},{"title":"Errors","description":"In Java, situations where things might go wrong in the program are predominantly handled by the following subclasses of the java.lang.Throwable class: Error and Exception.\n\nErrors\n\nThe Error class represents illegal operations that cause serious abnormalities in the program and are not recommended to catch. Some examples include the following:\n\nThe ClassFormatError occurs when a class file cannot be read or interpreted.\nThe IncompatibleClassChangeError occurs when a base class is altered after a child class has already been initialized.\nThe NoClassDefFoundError occurs when the file with the class containing the main() method cannot be found.\nExceptions\n\nThe Exception class refers to abnormal and unexpected events that disrupt the flow of the program but can be reasonably handled by a catch-statement. Some examples include:\n\nThe ArrayIndexOutOfBoundsException occurs when attempting to access an index that does not exist within a given array.\nThe FileNotFoundException occurs when a file with the specified path cannot be found.\nThe NumberFormatException occurs when an attempt is made to convert a string to a numeric type and the string contains non-numeric characters.\nThe NullPointerException occurs when attempting to use a null value in place of where an object is required.\nExample\n\nA try...catch block is a means for a programmer to encapsulate a block of code and “catch” a potentially-thrown Exception (but never an Error) before it halts execution of the program.\n\nIn the example below, the code used in the try block will run until the Exception is thrown by the assignment to the c variable because division by zero, 0, is not possible. In the catch block, an ArithmeticException is thrown and yields a printed message along with details about where the Exception can be traced.\n\nclass DivideByZero {\n  public static void main(String[] args) {\n    int a = 27, b = 0;\n    try {\n      System.out.println(\"I'm executed first!\");\n      int c = a / b; // This will throw an exception\n      System.out.println(\"I'm never executed!\");\n    } catch (ArithmeticException e) {\n      System.out.println(\"Exception Caught!\");\n      e.printStackTrace();\n    }\n      System.out.println(\"Done!\");\n  }\n}"},{"title":"HashMap","description":"Instances of the HashMap class implement the Map interface, which means that they store items as key-value pairs.\n\nA HashMap is similar to a TreeMap. However, the HashMap stores its items sorted in no particular order. (Actually, it’s sorted by the hashes of its keys, which for most purposes is essentially random.) This is due to the different storage types each collection uses internally. The HashMap stores its keys as hashes for lookup, whereas the TreeMap stores its keys in a binary tree structure for lookup. The advantage of a HashMap is that its operations are much faster.\n\nSyntax\nimport java.util.HashMap\n\n\nHashMap<KeyDatatype, ValueDatatype> myHashMap = new HashMap<KeyDatatype, ValueDatatype>();\n\nThe HashMap class comes from the java.util package. Therefore, it must be imported in order to be used. The HashMap is initialized with two generic types inside angle brackets < ... >. The generic data types for KeyDatatype and ValueDatatype can either be different or the same.\n\nAccessing Items\n\nKeys are used for uniquely identifying a value in a HashMap. This allows for efficient data storage and easy access. In the example below, the course names are the keys and the teachers assigned are the values that can be accessed by passing the corresponding key into the .get() method.\n\n// Import the HashMap class\nimport java.util.HashMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    HashMap<String, String> courseTeacher = new HashMap<String, String>();\n\n\n    // Add keys and values (CourseNames, Teacher)\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    System.out.println(courseTeacher.get(\"Physics\"););\n    System.out.println(courseTeacher.get(\"History\"););\n  }\n}\n\nThis will print the following output:\n\nLily\nBen\nAdding Items\n\nItems can be added to a HashMap using the .put() method. It accepts two attributes, a key and a value, and stores them as a pair ({ key=value }).\n\nimport java.util.HashMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    HashMap<String, String> courseTeacher = new HashMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    System.out.println(courseTeacher);\n  }\n}\n\nThis will output the following “course=teacher” assignments:\n\n{History=Ben, Mathematics=Jeanette, Physics=Lily}\nRemoving Items\n\nItems can be removed from a HashMap using the .remove() method. It accepts one parameter, the key, and removes the corresponding key-value pair from the HashMap.\n\nimport java.util.HashMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    HashMap<String, String> courseTeacher = new HashMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    courseTeacher.remove(\"Physics\");\n    System.out.println(courseTeacher);\n  }\n}\n\nThe following output will look like this:\n\n{History=Ben, Mathematics=Jeanette}\nRemoving All Items\n\nThe .clear() method can be used to remove all the items from the HashMap.\n\nimport java.util.HashMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    HashMap<String, String> courseTeacher = new HashMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    courseTeacher.clear();\n    System.out.println(courseTeacher);\n  }\n}\n\nAn empty HashMap will be displayed in the output below:\n\n{}\nTraversing a HashMap\n\nA HashMap can be traversed with the for-each loop. The .keySet() method can be used to obtain only the keys while the .values() method can be used to obtain only values.\n\nimport java.util.HashMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    HashMap<String, String> courseTeacher = new HashMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    System.out.println(\"Courses offered at our Institute:\");\n\n\n    for (String i : courseTeacher.keySet()) {\n      System.out.println(i);\n    }\n\n\n    System.out.println(\"\\nTeachers teaching at our Institute:\");\n\n\n    for (String i : courseTeacher.values()) {\n      System.out.println(i);\n    }\n  }\n}\n\nThe output will be:\n\nCourses offered at our Institute:\nMathematics\nHistory\nPhysics\n\n\nTeachers teaching at our Institute:\nJeanette\nBen\nLily"},{"title":"HashSet","description":"A HashSet is used to store an unordered set of unique items of a given data type.\n\nSyntax\nimport java.util.HashSet;\n\n\nHashSet<DataType> h = new HashSet<DataType>();\n\nWhere h is a HashSet created with the new keyword and DataType is the data type that will be stored in it. HashSet is a member of the java.util package which must be imported first.\n\nAdding Items\n\nNew items can be added to the HashSet with the .add() method.\n\nSyntax\nhashset.add(item)\n\nWhere item is the item to be added, which should match the data type hashset was defined with.\n\nExample\nimport java.util.HashSet;\n\n\npublic class Main {\n public static HashSet<String> SetupHashSet() {\n   HashSet<String> result = new HashSet<String>();\n   result.add(\"Cabbage\");\n   result.add(\"Pizza\");\n   result.add(\"Sausage\");\n   result.add(\"Potatoes\");\n   result.add(\"Salad\");\n   return result;\n }\n public static void main(String[] args) {\n   HashSet<String> food = SetupHashSet();\n   food.add(\"Sausage\");\n   System.out.println(food);\n }\n}\n\nThis will output:\n\n[Pizza, Sausage, Potatoes, Cabbage, Salad]\n\nNote: Members of the HashSet must be unique, so adding the same item twice will have no effect, like in the example above where “Sausage” is added a second time. Also, the HashSet items have no particular order, regardless of when they were inserted.\n\nRemoving Items\n\nItems can be removed from the HashSet with the .remove() method.\n\nSyntax\nhashset.remove(item)\n\nWhere item is the item to be removed from hashset. If item is not part of hashset the method has no effect.\n\nExample\n\nChanging the .main() method of the above example:\n\n public static void main(String[] args) {\n   HashSet<String> food = SetupHashSet();\n   food.remove(\"Sausage\");\n   System.out.println(food);\n }\n\nThis will output:\n\n[Pizza, Potatoes, Cabbage, Salad]\nChecking For Existence of an Item\n\nThe HashSet can be checked if it contains a particular item with the .contains() method.\n\nSyntax\nboolean result = hashset.contains(item);\n\nWhere result will be true if hashset contains item as one of its members.\n\nExample\n\nChanging the .main() method of the above example:\n\n public static void main(String[] args) {\n   HashSet<String> food = SetupHashSet();\n   if (food.contains(\"Nuts\")) {\n     System.out.println(\"Allergen warning!\");\n   } else {\n     System.out.println(\"Safe to eat.\");\n   }\n }\n\nThis will output:\n\nSafe to eat.\nReturning the Size of a HashSet\n\nThe number of items in a HashSet can be returned with the .size() method.\n\nSyntax\nint ItemCount = hashset.size()\n\nWhere ItemCount is the number of items in hashset.\n\nExample\n\nChanging the .main() method of the above example:\n\n public static void main(String[] args) {\n   HashSet<String> food = SetupHashSet();\n   System.out.println(food.size());\n   food.remove(\"Sausage\");\n   System.out.println(food.size());\n }\n\nThis will output:\n\n5\n4\nTraversing a HashSet\n\nA HashSet can be traversed with a for-each loop. Note that when doing so, the items will not be returned in any particular order.\n\nExample\n\nChanging the .main() method of the above example:\n\n public static void main(String[] args) {\n   HashSet<String> food = SetupHashSet();\n   for (String i : food) {\n     System.out.println(i);\n   }\n }\n\nThis will output:\n\nPizza\nSausage\nPotatoes\nCabbage\nSalad"},{"title":"Inheritance","description":"Inheritance is an object-oriented programming (OOP) concept by which the properties and behaviors from a parent class are passed on to a child class.\n\nIn day-to-day life, when something gets passed from a parent to a child, it is said that child inherits from their parent. Similarly, in Java, when some properties or behaviors get passed from parent class to the child class, it is said that child class inherits from a parent class.\n\nChild classes can have properties and methods of its own as well.\n\nThey can also override the behaviors (methods) of the parent class. This is called polymorphism (another OOP concept).\n\nWe can implement inheritance by using the extends keyword.\n\nSyntax\n\nHere’s the basic syntax for implementing inheritance:\n\npublic class Child extends Parent {\n  // Class body\n}\nExample\npublic class Vehicle {\n  private int numWheels;\n  private String engineNum;\n  private String maker;\n  private String color;\n\n\n  public int getNumWheels() {\n    return numWheels;\n  }\n\n\n  public void setNumWheels(int wheels) {\n    this.numWheels = wheels;\n  }\n\n\n  public String getEngineNum() {\n    return engineNum;\n  }\n\n\n  public void setEngineNum(String engineNum) {\n    this.engineNum = engineNum;\n  }\n  // Similar getters and setters for other properties\n}\n\nIn the code above, Vehicle is a class that has properties and behaviors. This is more of a generic class.\n\nWhile creating a specific class, for example, Car which has these properties and behaviors and some extra properties, instead of defining all these properties again in the new class, we can make use of inheritance to pass on the properties defined in Vehicle class and access them in Car class. This would make code written in Vehicle class reusable.\n\nSimilarly, we can make another class, for example, Airplane, which can access the properties present in Vehicle class.\n\nHere’s a Car class which inherits Vehicle class:\n\npublic class Car extends Vehicle {\n  // Vehicle class properties and methods accessible here\n  private int airbagCount;\n\n\n  public int getAirbagCount() {\n    return airbagCount;\n  }\n\n\n  public void setAirbagCount(int airbagCount) {\n    this.airbagCount = airbagCount;\n  }\n}\n\nBelow is how you can access properties and methods of parent class:\n\npublic static void main(String args[]) {\n  Car car = new Car();\n  car.setNumWheels(4); // Parent class method. This would set the wheel count to 4\n  System.out.println(car.getNumWheels()); // Parent class method. Prints numWheels\n\n\n  car.setAirbagCount(2); // Child class method. This would set the airbag count\n  System.out.println(car.getAirbagCount()); // Child class method. Prints airbag count\n}\nTypes of Inheritance\nSingle Inheritance\n\nSingle inheritance is when a child class inherits from a parent class.\n\npublic class Parent {\n  // Parent class properties and methods\n}\n\n\npublic class Child extends Parent {\n  // Parent class properties and methods accessible here due to inheritance\n  // Child class properties and methods\n}\nMultilevel Inheritance\n\nMultilevel inheritance is when a child class inherits from a parent class which in turn inherits from another parent class.\n\npublic class Parent {\n  // Parent class properties and methods\n}\n\n\npublic class Child extends Parent {\n  // Parent class properties and methods accessible here due to inheritance\n  // Child class properties and methods\n}\n\n\npublic class GrandChild extends Child {\n  // Parent class and Child class properties and methods accessible here due to inheritance\n  // GrandChild class properties and methods\n}\nHierarchical Inheritance\n\nHierarchical inheritance is when a child class inherits from a parent class and there is another sibling class that also inherits from the same parent class.\n\npublic class Parent {\n  // Parent class properties and methods\n}\n\n\npublic class Child extends Parent{\n  // Parent class properties and methods accessible here due to inheritance\n  // Child class properties and methods\n}\n\n\npublic class Sibling extends Parent{\n  // Parent class properties and methods accessible here due to inheritance\n  // Child class properties and methods are not accessible here\n  // Sibling class properties and methods\n}\nAdvantages of Inheritance\nCode reusability: Same properties and methods of a class can be used by inheriting that class.\nLower maintenance cost: If a piece of code needs to be updated, it can be done at minimal place if inheritance is used.\nEasier to add new features: If a same new feature needs to be added to multiple classes, through inheritance it can be added in parent class and all the child classes inheriting this parent class would get that feature instantly."},{"title":"Loops","description":"While Loop\n\nThe while loop loops through a block of code as long as a specified condition is true:\n\nwhile (condition) {\n  // Code block to be executed\n}\n\nIn this example, the code in the loop will run again and again, as long as variable i is still less than 10:\n\nint i = 0;\n\n\nwhile (i < 10) {\n  System.out.println(i);\n  i = i + 2;\n}\n\nThe output would be:\n\n0\n2\n4\n6\n8\nFor Loop\n\nA for loop iterates over a range of values. Its declaration is made up of the following three parts, each separated by a semicolon:\n\nThe initialization of the loop control variable.\nA conditional expression.\nAn expression that modifies the loop control variable.\n\nIn this example, the loop control variable starts at 3 and decrements. The loop will continue iterating until the conditional expression is no longer true:\n\nfor (int i = 3; i > 0; i--) {\n  System.out.println(i);\n}\n\n\nSystem.out.println(\"Liftoff!\");\n\nThe output would be:\n\n3\n2\n1\nLiftoff!\nFor-Each Loop\n\nIn Java, the for-each loop allows you to directly loop through each item in an array or ArrayList and perform some action with each item.\n\nWhen creating a for-each loop, you must include the for keyword and two expressions inside of parentheses, separated by a colon. These include:\n\nThe data type and handle for an element we’re currently iterating over.\nThe source array or ArrayList we’re iterating over.\n// Array of numbers\nint[] numbers = {1, 2, 3, 4, 5};\n\n\n// For-each loop that prints each number in numbers\n// int num is the handle while numbers is the source array\nfor (int num : numbers) {\n    System.out.println(num);\n}"},{"title":"Math Methods","description":"The Java Math class provides several methods that allows us to work on mathematical calculations with numbers.\n\nMath.method();\n\nHere are the Math methods in alphabetical order:"},{"title":"Map","description":"The Map interface is found in java.util and it allows collections to store items as key-value pairs. It is implemented in the HashMap and TreeMap classes. A Map allows its contents to be accessed as a set of keys, a set of values, or a set of key-value pairs. The data types of the keys and values are set when the Map is declared, and each can be any data type.\n\nSyntax\nMapClass<KeyDataType,ValueDataType> myMap = new MapClass<KeyDataType,ValueDataType>\n\nThe MapClass is a class that implements the Map interface, and is initialized with two generic types inside angle brackets < ... >. The generic data types for KeyDatatype and ValueDatatype can either be different or the same.\n\nMethods\n\nA Map class will implement the following methods:\n\n.clear(): removes all key-value pairs from the Map.\n.containsKey(key): returns true if key is one of the keys in the Map.\n.containsValue(value): returns true if value is one of the values in the Map.\n.get(key): returns the value of the given key from the Map.\n.put(key,value): adds a key-value pair to the Map.\n.remove(key): removes the key-value pair associated with key from the Map.\n.size(): returns an int that represents the number of key-value pairs in the Map."},{"title":"Operators","description":"Arithmetic Operators\n\nBasic math operations can be applied to int, double, and float data types:\n\n+ addition\n- subtraction\n* multiplication\n/ division\n% modulo (yields the remainder)\n\nThese operations are not supported for other data types.\n\nint a = 20;\nint b = 10;\n\n\nint result;\n\n\nresult = a + b;  // 30\nresult = a - b;  // 10\nresult = a * b;  // 200\nresult = a / b;  // 2\nresult = a % b;  // 0\nComparison Operators\n\nComparison operators can be used to compare two values:\n\n> greater than\n< less than\n>= greater than or equal to\n<= less than or equal to\n== equal to\n!= not equal to\n\nThey are supported for primitive data types and the result of a comparison is a boolean value true or false:\n\nint a = 5;\nint b = 3;\n\n\nboolean result = a > b;\n// result now holds the boolean value true\nBitwise Operators\n\nBitwise operators are used to manipulate individual bits of a number.\n\n& Bitwise AND\n| Bitwise OR\n^ Bitwise XOR\n~ Bitwise complement\n<< Signed right shift operator\n>> Signed left shift operator\n>>> Unsigned right shift operator\n<<< Unsigned left shift operator\n\nThey can only be operated on data of int, char, byte, long, and short.\n\nint a = 5;\nint b = 3;\n\n\nint bitwiseAnd = a & b;\n// 1\n\n\nint bitwiseOr = a | b;\n// 7\n\n\nint bitwiseXor = a ^ b;\n// 6\n\n\nint bitwiseComplement = ~a;\n// -6\n\n\nint bitwiseRightShift = a >> b;\n// 0\n\n\nint bitwiseLeftShift = a << b;\n// 40"},{"title":"Methods","description":"Methods are reusable pieces of code in classes. The difference between a method and a function is that methods are always related to a class or an object. Since in Java there is no possibility of defining logic outside of a class, there are no real functions given this definition. In that case, static methods can be used to have reusable logic without an object instance.\n\nMethods consist of at least the following elements:\n\nReturn type: The type of the value that is returned from the method\nName: The name of the method\n\nAdditionally, they optionally include:\n\nParameters: Methods can have no, one, or multiple parameters which consist of a data type and a name. Parameters make it possible to provide values to the method which can be used inside the body of a method.\nModifier: Modifiers define in which way and from which context a method is callable.\nExceptions: Exceptions can be thrown by method to make the caller react to unexpected situations (i.e. a non-existing file).\nBody: The body of a method contains all statements the method should execute when being called. The body is only optional in interfaces and abstract classes.\nA Minimal Signature\n\nCreating a method called .getOneNumber():\n\nint getOneNumber() {\n  return 1;\n};\nReturn type: int\nName: getOneNumber\nModifier: package private (the default)\nReturn Type\n\nMethods can return any type listed under data types. Additionally, they can return instances of any class. If a method shouldn’t return a value, it has to be defined with the return type void.\n\nName\n\nThe name of a method should describe as much as possible what the method is doing. Ideally, the programmer calling the method knows what the method does without needing to look at the body. By following the rule that a method should only do one thing, it’s also easier to give it a concise name.\n\nA valid name must follow the rules:\n\nIt has to start with a letter or an underscore (_) and can contain digits.\nIt could also start with a $ but the specification of the language says that this shouldn’t be done\nIt can’t have a name of keyword (i.e. return or while) however keywords can be within the name\n\nExamples for valid method names:\n\ngetObject\nsetNumber\ncountUntil300\n_isValidCharacter\nGET_MAX_VALUE\n\nExamples for invalid method names:\n\n123number (method names mustn’t start with a number)\nget-object (hyphens are not allowed inside a method name)\nsum_number1&number2 (ampersands are not allowed inside a method name)\nassert (method names mustn’t have the name of a keyword)\n\nBy convention, method names start with a verb, and each word after the first word starts with a capitalized letter.\n\nParameters\n\nA parameter is described by a data type and a name. With that name, the parameter can be used to access the value inside the method body. A method without any parameters must have empty parenthesis () after the method name. Multiple parameters have to be separated by a comma ,.\n\nParameters are the definitions inside the parenthesis of a method while arguments are the values provided, when the method is called. The values of the arguments are made available via the parameter names inside the method body.\n\nBy convention, a method should have a maximum of three parameters. If it’s necessary to have more than three it makes sense to create an object which is passed and contains the data.\n\nModifier\n\nModifiers can change how a method is allowed to be called (public, protected, private, package private), if the method is working on object state or should be executable without creating an object out of a class (static), or if the method is allowed to be replaced by inherited classes (final).\n\npublic int sum(int number1, int number2) {\n  return number1 + number2;\n}\nModifier: public\nReturn type: int\nName: sum\nParameters: int number1, int number2\nPody: return number1 + number2;\nVisibility Modifiers\npublic: Methods declared as public can be called from everywhere, inside and outside of the object or the class.\nprivate: Methods declared as private can only be called from inside the object or the class.\npackage private: Methods declared as package private can only be called from classes within the same package.\nprotected: Methods declared as protected can only be called from inside the class or from inside classes inherited from that class.\nAdditional Modifiers\nstatic\n\nStatic methods can be called in classes without creating an object instance out of that class. That’s why the object state in those methods can’t be accessed with this. The static modifier can be combined with visibility modifiers.\n\npublic static void main(String[] args) {\n  System.out.println(\"Hello world\");\n}\nModifiers: public static\nReturn type: void\nName: main\nParameters: String[] args\nBody: System.out.println(\"Hello world\");\nfinal\n\nThe final keyword prevents methods from being overwritten in inherited classes. It can be combined with other modifiers.\n\nExceptions\n\nMethods can throw Exceptions. An example of this is trying to access a file that doesn’t exist. When calling a method, which throws an exception, the calling method has to take care of that exception or has to throw an Exception as well.\n\nHere is an example of how Java throws an exception in a method that could execute a division by 0 and therefore the method has to throw an exception.\n\npublic float divide(float dividend, float divisor) throws ArithmeticException {\n  return dividend / divisor;\n}\nModifiers: public\nReturn type: float\nName: divide\nParameters: float dividend, float divisor\nThrown exception: throws ArithmeticException\nBody: return dividend / divisor\nBody\n\nEverything between { and } is called the body of the method. The body contains the actual code, statements, or logic that is executed when the method is called.\n\nIf the method has a return type there needs to be at least one line in the body which returns a value of that type (i.e. return a+b;).\n\nMethods also have access to values of the instance of a class when using the word this. With this other methods of that same class can be called or instance fields of the class can be accessed which hold values that are accessible through all methods of the class."},{"title":"Queue","description":"A Queue is an interface provided in the java.util package that extends collections to provide additional methods to access or manipulate items at the head of the queue. Where the “head” of the queue is defined by the particular implementation.\n\nQueue elements are commonly accessed in a FIFO (first-in-first-out) manner. In a priority queue implementation, the first item out will be defined by its specified priority.\n\nSyntax\nimport java.util.Queue;\n\n\nQueue<DataType> q = new QueueClass<DataType>();\n\nWhere DataType is the data type to be stored in the queue, and QueueClass is some class implementing the Queue interface.\n\nMethods\n\nThe Queue interface utilizes the following methods:\n\n.add() : .add(item) adds item to the Queue if possible, otherwise it throws an exception.\n.offer() : .offer(item) adds item to the Queue if possible, otherwise it returns false.\n.remove() : removes and returns the head item of the Queue, throwing an exception when the Queue is empty.\n.poll() : removes and returns the head item of the Queue, returning null if the Queue is empty.\n.element() : returns the head of the Queue without removing it.\n.peek() : returns the head of the Queue without removing it.\nExample\n\nThis is an example of the Queue interface implemented by a LinkedList:\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\npublic class Main {\n public static void main(String[] args) {\n   Queue<String> food = new LinkedList<String>();\n   food.offer(\"Cabbage\");\n   food.offer(\"Pizza\");\n   food.offer(\"Sausage\");\n   food.offer(\"Potatoes\");\n   food.offer(\"Salad\");\n   System.out.println(food.peek());\n   System.out.println(food.poll());\n   System.out.println(food);\n }\n}\n\nThis will output the following:\n\nCabbage\nCabbage\n[Pizza, Sausage, Potatoes, Salad]"},{"title":"Random","description":"The Random class is present in the java.util package. It is used to generate random values or streams of random values of specific data types.\n\nUsage\n\nThe Random class can be accessed by importing it as follows:\n\nimport java.util.Random;\n\nWhen an instance of the Random class is created, either a seed value is passed to the constructor or no values are passed at all.\n\nThe seed is a value that gets manipulated (using a linear congruential formula) to produce a stream of pseudorandom values. The Random class uses a 48-bit seed.\n\nIn this code, objects rand1 and rand2 of the Random type are created using the new keyword. While no parameters are passed during the creation of rand1, a seed value is used during the creation of rand2.\n\nRandom rand1 = new Random();\n\n\nlong seed = (long)3.142;\nRandom rand2 = new Random(seed);\n\nThe value of the seed can be set or modified at any point during the execution of the program using the .setSeed() method.\n\nlong newseed = (long)2.7182;\nrand2.setSeed(newseed);\n\nNote: If two objects of type Random are created with the same seed, they will generate the same sequence of numbers, provided they are subject to the same sequence of method calls.\n\nGenerating Individual Values\n\nThe following methods can be used to generate the next pseudorandom number from the generator’s sequence.\n\nThe .nextDouble() and .nextFloat() methods return values in range [0,1). This means that the range is inclusive of zero (indicated by the square bracket) and exclusive of 1 (indicated by the parenthesis).\nThe .nextInt() and .nextLong() methods have no such limits.\n\nNote: In the absence of a seed, these methods return different values every time they are called or even for separate instances:\n\nfloat f = rand1.nextFloat();\ndouble d = rand1.nextDouble();\nint i = rand1.nextInt();\nlong l = rand1.nextLong();\nboolean b = rand1.nextBoolean();\n\n\nSystem.out.println(\"Random float: \" + f);\nSystem.out.println(\"Random double: \" + d);\nSystem.out.println(\"Random integer: \" + i);\nSystem.out.println(\"Random long: \" + l);\nSystem.out.println(\"Random boolean: \" + b);\n\nThe output will look like this:\n\nRandom float: 0.13293427\nRandom double: 0.900476085026994\nRandom integer: 152429987\nRandom long: -4775630185711902523\nRandom boolean: 1\n\nThe .nextInt() method can also be used with an upper bound so that the generated value is between 0 and that upper bound.\n\ni = rand1.nextInt(25);\nSystem.out.println(\"Random integer in range [0,25): \" + i);\n\nThe output will be:\n\nRandom integer in range [0,25): 16\n\nA byte array can also be filled with random elements using the .nextBytes() method.\n\nbyte[] b = new byte [5];\nrand1.nextBytes(b);\n\n\nSystem.out.print(\"Random byte array: \");\n\n\nfor (byte j: b)\n  System.out.print(j + \" \");\n\nThe output looks like this:\n\nRandom byte array: -44 -82 44 62 -111\nGenerating Streams\n\nIntStream, DoubleStream and LongStream objects can be produced using the .ints(), .doubles() and .longs() methods, respectively.\n\nThe following example illustrates the generation of a DoubleStream object and can be extrapolated for the other two object types as well.\n\nTo use an object of this type, the following import statement must be used:\n\nimport java.util.stream.DoubleStream;\n\nAn unlimited stream of pseudorandom double values, each in the range [0,1), can be generated using the following code snippet. A DoubleStream is a stream over objects of double type:\n\nDoubleStream stream;\nstream = rand1.doubles();\n\nAn effectively unlimited stream of pseudorandom double values, each in the range specified, can be generated using the following code snippet. The parameters are the lower bound and the upper bound, respectively:\n\nstream = rand1.doubles(0,10);\n\nNote: In the above method, the lower bound is inclusive but the upper bound is exclusive.\n\nA stream of specified size of values in range [0,1) can be generated using the following code snippet. The parameter represents the size of the stream:\n\nstream = rand1.doubles(5);\n\nA stream of specified size with values in a specified range can be generated using the following code snippet. The parameters are the size of stream, the lower bound and the upper bound, respectively:\n\nstream = rand1.doubles(5, 0, 10);"},{"title":"Strings","description":"A String in Java is an object that holds a sequence of characters contained within a pair of double quotes (\"). It is not a primitive datatype.\n\nJava strings provide a way to store something like a word, sentence, or whole paragraph. They can be any length and can contain letters, numbers, symbols, and spaces.\n\n// Creating a String variable\nString name = \"Codecademy\";\n\n\n// Creating another String variable\nString address = \"575 Broadway #5, New York, NY 10012\";\n\nTo compare Strings, the .equals() method must be used instead of the primitive equality comparator ==. .equals() will compare the values of the strings, while == compares the references (location in memory) of the strings.\n\nString name = \"Bob\";\n\n\n// The following will print \"false\" because strings are case-sensitive\nSystem.out.println(name.equals(\"bob\"));"},{"title":"Set","description":"A Set is an interface provided in the java.util package that implements collections with zero duplicate elements. Some implementations will have restrictions on the elements the Set can contain, such as excluding null elements. Adding an ineligible element will typically throw an unchecked NullPointerException or a ClassCastException.\n\nExamples of classes implementing the Set interface are HashSet and TreeSet.\n\nSyntax\nSetClass<DataType> mySet = new SetClass<DataType> ();\n\nThe SetClass is a class that implements the Set interface, and is initialized with a generic type inside angle brackets < ... >.\n\nMethods\n\nThe Set interface utilizes the following methods:\n\n.add() : .add(item) adds item to the Set if it is not already present.\n.clear() : Removes all the elements from the Set\n.contains() : .contains(item) returns true if item is a member of the Set.\n.remove() : .remove(item) will remove item from the Set.\n.size() : Returns the number of items in the Set.\nExample\n\nThis is an example of a Set interface being implemented by a HashSet:\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n\npublic class Main {\n public static void main(String[] args) {\n   Set<String> food = new HashSet<String>();\n   food.add(\"Cabbage\");\n   food.add(\"Pizza\");\n   food.add(\"Sausage\");\n   food.add(\"Potatoes\");\n   food.add(\"Salad\");\n   food.remove(\"Sausage\");\n   System.out.println(food.contains(\"Sausage\"));\n   System.out.println(food);\n   System.out.println(food.size());\n }\n}\n\nThis will output the following:\n\nfalse\n[Pizza, Potatoes, Cabbage, Salad]\n4"},{"title":"Switch","description":"A switch statement provides a means of checking an expression against various case statements. If there is a match, the code within starts to execute. The break keyword can be used to terminate a case.\n\nThere’s also an optional default statement marking code that executes if none of the case statements are true.\n\nSyntax\n\nA switch statement looks like:\n\nswitch (expression) {\n  case x:\n    // Code block\n    break;\n  case y:\n    // Code block\n    break;\n  default:\n    // Code block\n}\n\nSo here’s an example:\n\nswitch (grade) {\n  case 9:\n    System.out.println(\"Freshman\");\n    break;\n  case 10:\n    System.out.println(\"Sophomore\");\n    break;\n  case 11:\n    System.out.println(\"Junior\");\n    break;\n  case 12:\n    System.out.println(\"Senior\");\n    break;\n  default:\n    System.out.println(\"Invalid\");\n    break;\n}\nThe switch keyword initiates the statement and is followed by (), which contains the value that each case will compare. In the example, the value or expression of the switch statement is grade.\nInside the block, {}, there are multiple cases.\nThe case keyword checks if the expression matches the specified value that comes after it. The value following the first case is 9. If the value of grade is equal to 9, then the code that follows the : would run.\nThe break keyword tells the computer to exit the block and not execute any more code or check any other cases inside the code block.\nAt the end of each switch statement, there is a default statement. If none of the cases are true, then the code in the default statement will run. It’s essentially the else part in an if/else if/else statement.\n\nIn the code above, suppose grade is equal to 10, then the output would be “Sophomore”.\n\nNote: Without the break keyword at the end of each case, the program would execute the code for the first matching case and all subsequent cases, including the default code. This behavior is different from if/else conditional statements which execute only one block of code.\n\nExample\nint rating = 3;\n\n\nswitch (rating) {\n  case 5:\n    System.out.println(\"Exceptional\");\n    break;\n  case 4:\n    System.out.println(\"Good\");\n    break;\n  case 3:\n    System.out.println(\"Fair\");\n    break;\n  default:\n    System.out.println(\"Poor\");\n    break;\n}"},{"title":"TreeMap","description":"A TreeMap uses the Map interface, which means it stores items as key-value pairs.\n\nThey are like the HashMap. However, a HashMap, the TreeMap stores its items sorted by the natural ordering of its keys. This is due to the differing means of storage each type of collection uses internally. The HashMap stores its keys as hashes for lookup, whereas the TreeMap stores its keys in a binary tree structure for lookup. The tradeoff for this natural ordering of the TreeMap is that its operations are slower than a HashMap.\n\nSyntax\nimport java.util.TreeMap\n\n\nTreeMap<KeyDatatype, ValueDatatype> myTreeMap = new TreeMap<KeyDatatype, ValueDatatype>();\n\nThe TreeMap class comes from the java.util package. Therefore, it must be imported in order to be used. The TreeMap is initialized with two generic types inside angle brackets < ... >. The generic data types for KeyDatatype and ValueDatatype can either be different or the same.\n\nAccessing Items\n\nKeys are used for uniquely identifying a value in a TreeMap. This allows for efficient data storage and easy access. In the example below, the course names are the keys and the teachers assigned are the values that can be accessed by passing the corresponding key into the .get() method.\n\nimport java.util.TreeMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    TreeMap<String, String> courseTeacher = new TreeMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    System.out.println(courseTeacher.get(\"Physics\"));\n    System.out.println(courseTeacher.get(\"History\"));\n  }\n}\n\nThe following will be printed in the output below:\n\nLily\nBen\nAdding Items\n\nItems can be added to a TreeMap using the .put() method. It accepts two parameters, a key and a value, and stores them as a pair ({ key=value }).\n\nimport java.util.TreeMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeMap<String, String> courseTeacher = new TreeMap<String, String>();\n\n\n    // Add keys and values (CourseNames, Teacher)\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    System.out.println(courseTeacher);\n  }\n}\n\nThis will output the following “course=teacher” assignments:\n\n{History=Ben, Mathematics=Jeanette, Physics=Lily}\nRemoving Items\n\nItems can be removed from a TreeMap using the .remove() method. It accepts one parameter, the key, and removes the corresponding key-value pair from the HashMap.\n\nimport java.util.TreeMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    TreeMap<String, String> courseTeacher = new TreeMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    courseTeacher.remove(\"Physics\");\n    System.out.println(courseTeacher);\n\n\n  }\n}\n\nThis will output the following:\n\n{History=Ben, Mathematics=Jeanette}\nRemoving All Items\n\nThe .clear() method can be used to remove all the items from the TreeMap.\n\nimport java.util.TreeMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    TreeMap<String, String> courseTeacher = new TreeMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    courseTeacher.clear();\n    System.out.println(courseTeacher);\n  }\n}\n\nThe emptied TreeMap will be displayed in the output below:\n\n{}\nTraversing a TreeMap\n\nA TreeMap can be traversed with the for-each loop. The .keySet() method can be used to obtain only the keys while the .values() method can be used to obtain only values.\n\nimport java.util.TreeMap;\n\n\npublic class Main {\n  public static void main(String[] args) {\n\n\n    TreeMap<String, String> courseTeacher = new TreeMap<String, String>();\n\n\n    courseTeacher.put(\"History\", \"Ben\");\n    courseTeacher.put(\"Mathematics\", \"Jeanette\");\n    courseTeacher.put(\"Physics\", \"Lily\");\n\n\n    System.out.println(\"Courses offered at our Institute:\");\n\n\n    for (String i : courseTeacher.keySet()) {\n      System.out.println(i);\n    }\n\n\n    System.out.println(\"\\nTeachers teaching at our Institute:\");\n\n\n    for (String i : courseTeacher.values()) {\n      System.out.println(i);\n    }\n  }\n}\n\nThe following output will look like this:\n\nCourses offered at our Institute:\nMathematics\nHistory\nPhysics\n\n\nTeachers teaching at our Institute:\nJeanette\nBen\nLily"},{"title":"User Input","description":"The Scanner class is used to get user input, and it is found in the java.util package.\n\nTo use the Scanner class:\n\nImport the Scanner class at the top of the file.\nCreate a Scanner object.\nUse a method from the Scanner class.\n\nTo import the Scanner class, add at the top of the file:\n\nimport java.util.Scanner;\n\nIn our example, we will use the .nextLine() method, which is used to read Strings:\n\nimport java.util.Scanner;                         // 1. Import the Scanner class\n\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);       // 2. Create a Scanner object\n\n\n    System.out.println(\"Enter your user name\");\n\n\n    String userName = myObj.nextLine();           // 3. Read the user input with .nextLine()\n\n\n    System.out.println(\"The username is: \" + userName);\n  }\n}\n\nHere, the user can enter some text in the terminal, press enter, and that string will get stored in the variable userName.\n\nInput Types\n\nIn the example above, we used the .nextLine() method, which is used to read Strings. To read other types, look at the table below:\n\nMethod\tDescription\n.nextBoolean()\tReads a boolean value from the user\n.nextByte()\tReads a byte value from the user\n.nextDouble()\tReads a double value from the user\n.nextFloat()\tReads a float value from the user\n.nextInt()\tReads a int value from the user\n.nextLine()\tReads a String value from the user\n.nextLong()\tReads a long value from the user\n.nextShort()\tReads a short value from the user"},{"title":"Type Conversion","description":"Type conversion is the process of converting a value of one data type into another data type. There are many situations where data is available in one type and the program needs to treat it as another type. Common instances are situations where a mathematical operation needs a float value and one of the operands needed is an integer, or when processing user input that comes in as String data and it needs to be interpreted as some sort of number.\n\nConverting Between Numeric Types\n\nIn certain situations, where the data types are compatible, Java can do type conversion automatically. This happens when a smaller data type, like int, is assigned to a variable of a longer data type, like long.\n\n// Automatic type conversion\nint x = 15;\nlong y = 0L;\ny = x; // y is now 15L\n\nThis process is also known as widening and follows the following pattern:\n\nbyte -> short -> int -> long -> float -> double\n\nAny data type can be “widened” to a data type to the right on this list.\n\nConverting to a smaller data type, i.e. going to the left on this list, requires explicit conversion or type casting.\n\n// Explicit type casting\nlong x = 15L;\nint y = 0;\ny = (int)x; // y is now 15\nConverting Strings to Numeric Types\n\nString values are not directly compatible with numeric values. However, Java provides Number subclasses for the primitive numeric types; Byte, Integer, Double, Float, Long and Short. Each of these provides a .parseXXXX() method that takes a string and provides the equivalent data type.\n\n// Convert a string into a number using .parseXXXX()\nString s = \"15\";\n// Convert a string into an integer.\nint x = Integer.parseInt(s); // x is now 15\n// Convert a string into a float.\nfloat y = Float.parseFloat(s); // y is now 15f\nConverting Numeric Types Into Strings\n\nConverting numbers to strings can occur in a few different ways.\n\nWhen a number is concatenated with a string, it will be converted automatically:\n\n// Automatically convert an integer to a string\nint i = 15;\nString s = \"\" + i; // s now has the value \"15\"\n\nThe String.valueOf() method can be used:\n\n// Convert an integer to a string using the .valueOf() method.\nint i = 15;\nString s = String.valueOf(i); // s now has the value \"15\"\n\nAlso, each of the Number subclasses has a .toString() method that converts its associated primitive numeric type into a String:\n\n// Convert an integer to a string using the .toString() method.\nint i = 15;\nString s = Integer.toString(i); // s now has the value \"15\""},{"title":"Variables","description":"Variables are used whenever there’s a need to store a piece of data. A variable contains data that can be used in the program elsewhere. Using variables also ensures code re-usability since it can be used to replace the same value in multiple places.\n\nDeclaring a Variable\n\nTo declare a variable in Java, any of these three keywords can be used along with a variable name:\n\nThe data type.\nThe variable name.\nThe value.\nint age = 28;\nchar grade = 'A';\nboolean late = true;\nbyte b = 20;\nlong num1 = 1234567;\nshort no = 10;\nfloat k = (float)12.5;\ndouble pi = 3.14;\n\nThe equal sign = is used to assign a value to a variable. After the initial assignment is made, the value of a variable can be updated to new values as needed."}],"JavaScript":[{"title":"AJAX","description":"Asynchronous JavaScript and XML (AJAX) is a programmng technique that allows web developers to fetch server data without having to wait for the page to reload first.\n\nSyntax\n\nAJAX requests can be used in all modern web browsers and utliizes the built-in XMLHttpRequest object:\n\nconst request = new XMLHttpRequest();\nExample\n\nListeners can be attached to the request to execute when certain events take place:\n\nconst request = new XMLHttpRequest();\n\n\nfunction requestListener() {\n  console.log(this.responseText());\n}\n\n\nrequest.addEventListener('load', requestListener);\n\nThe next step is to use this object to open a request to a server using the .open() method, which accepts two parameters. The first is the HTTP request method to use like “GET”, “POST”, and “DELETE”. The second is the resource being fetched, usually a URL. Then, the request can be sent with the .send() method:\n\nrequest.open('GET', 'http://www.example.org/example.txt');\n\n\n// For just retreiving data\nrequest.send();\n\n\n// For updating data (POST, PUTS, etc.)\nrequest.send(OUR_DATA_VARIABLE);\nHistory\n\nDuring the 1990s, when the Web was still in its infancy, most websites returned complete web pages when first loaded on the browser. To reload any data, users had to reload the entire page. This proved to be inefficient and not good for the user experience. It also increased the load on servers and the bandwidth needed to serve data, causing longer loadtimes.\n\nBetween 1996 and 2005, Microsoft and Google began introducing asynchronous data fetches in their products:\n\nThe <iframe> tag was introduced to Internet Explorer to allow data to be fetched asynchronously.\nAsync data fetches were soon added to Gmail, Google Maps, and Google Suggest.\n\nThis technique was eventually labeled “AJAX” in a 2005 article by Jesse James Garrett, formerly of Google. It quickly became the most popular way to build web applications."},{"title":"Arrays","description":"Arrays are lists of ordered, stored data. They can hold items that are of any data type.\n\nSyntax\n\nArrays can be created by using square brackets, with individual elements separated by commas.\n\n// An array containing numbers\nconst numberArray = [0, 1, 2, 3];\n\n\n// An array containing different data types\nconst mixedArray = [1, 'chicken', false];\n\nAnother way to creating a new instance of the Array class and passing the elements as a comma-separated list of arguments:\n\nconst classArray = new Array(0, 1, 2, 3);\nCreating an Array\n\nThe most straightforward way to create an array is using an array literal as in the above example.\n\nconst fruit = ['Apple', 'Orange', 'Banana'];\n\nWhitespace is ignored and declarations can span multiple lines.\n\nArrays can also be created with the Array class by using the new keyword and passing in the elements as arguments:\n\nconst fruit = new Array('Apple', 'Orange', 'Banana');\n\nThough, because the effect is exactly the same, it is preferable to use the literal method for simplicity and execution speed.\n\nAccessing the Elements of an Array\n\nArray elements are ordered by index values, starting at 0:\n\nIndex 0 has the first element.\nIndex 1 has the second element.\nIndex 2 has the third element.\nIndex n-1 has the nth element.\n\nIndividual elements in the array can be accessed using the array name and the element’s index surrounded by square brackets.\n\nThis code accesses the value of the first element in the fruit array:\n\nconst fruit = ['Apple', 'Orange', 'Banana'];\n\n\nconsole.log(fruit[0]);\n// Output: Apple\n\nArray elements can be changed by accessing the element and assigning a new value to it.\n\nconst fruit = ['Apple', 'Orange', 'Banana'];\n\n\nfruit[1] = 'Mango';\n\n\nconsole.log(fruit[1]);\n// Output: Mango\n\nAccessing an array using an unused index will return undefined. However, a new value can still be assigned to an unused index of an array. When doing so, any gaps in the assigned indices will remain undefined.\n\nconst fruit = ['Apple', 'Orange', 'Banana'];\n\n\nfruit[4] = 'Mango'; // a valid assignment\n\n\nconsole.log(fruit[3]);\n// Output: undefined\nNested Arrays\n\nAny object can be an element of an array, including other arrays. Arrays with one or more arrays as elements are referred to as “nested arrays”. Similar to accessing the elements of a regular array, accessing elements within nested arrays requires the additional indices for referencing inner array elements.\n\n// Create a nested array\nconst food = [\n  ['Apple', 'Orange', 'Banana'],\n  ['Strawberry', 'Blueberry', 'Raspberry'],\n  ['Potato', 'Carrot', 'Broccoli'],\n];\n\n\n// Retrieve the food string at index 2 of the array at index 1\nconsole.log(food[1][2]);\n// Output: Raspberry\n\n\n// Retrieve the food string at index 1 of the array at index 0\nconsole.log(food[0][1]);\n// Output: Orange\n\nThe same process applies to nested arrays that themselves contain nested arrays. The more “nested” the array, the more indices, or bracket pairs [ ], are required for accessing their elements."},{"title":"Arrow Functions","description":"Arrow function expressions were introduced in ES6. These expressions are a clean and concise alternative to the traditional function syntax. The syntax for an arrow function expression does not require the function keyword and uses a fat arrow => to separate the parameter(s) from the body. However, they are limited and can’t be used in all situations.\n\nThere are several variations of arrow functions:\n\nArrow functions with a single parameter do not require () around the parameter list.\nArrow functions with a single expression can use the concise function body which returns the result of the expression without the return keyword.\nSyntax\n\nArrow function with no arguments:\n\nconst printHello = () => {\n  console.log('hello');\n};\n\n\nprintHello();\n// Output: hello\n\nArrow functions with a single argument:\n\nconst checkWeight = (weight) => {\n  console.log(`Baggage weight: ${weight} kilograms.`);\n};\n\n\ncheckWeight(25);\n// Output: Baggage weight: 25 kilograms.\n\nArrow function with two arguments:\n\nconst sum = (firstParam, secondParam) => {\n  return firstParam + secondParam;\n};\n\n\nconsole.log(sum(2, 5));\n// Output: 7\n\nConcise arrow functions:\n\nconst multiply = (a, b) => a * b;\n\n\nconsole.log(multiply(2, 30));\n// Output: 60\nLimitations\nArrow functions do not have their own bindings to this or super, and should not be used as methods.\nArrow functions cannot be used as constructors.\nArrow functions cannot use yield, within its body.\nArrow functions cannot use the special arguments keyword."},{"title":"Callbacks","description":"Callback functions are functions that are passed as arguments in other functions. A callback function can then be invoked during the execution of that higher order function (that it is an argument of).\n\nIn JavaScript, functions can be passed as arguments because functions are objects.\n\nSuppose there are two functions, functionA() and functionB():\n\nfunction functionA(num1, num2) {\n  return num1 + num2;\n}\n\n\nfunction functionB(callback) {\n  return callback(2, 4) * 2;\n}\n\n\nconsole.log(functionB(functionA)); // Output: 12\n\nIn the code above, functionA() accepts two arguments num1 and num2. The other function, functionB(), accepts a single argument callback. When functionB() is executed, the value of the executed callback argument is returned.\n\nIn the log statment, we pass functionA() as the callback to functionB() and 12 is logged to the console."},{"title":"Bitwise Operators","description":"Bitwise operators in JavaScript operate on 32-bit operands. Internally, JavaScript converts 64-bit floating point numbers into 32-bit signed integers before performing the operation, it then converts back to 64-bit numbers to return the result.\n\nJavaScript uses the following bitwise operators:\n\nOperator\tName\tDescription\n&\tAND\tIf both bits are 1, result is 1; otherwise 0.\n|\tOR\tIf either bit is 1, result is 1; otherwise 0.\n^\tXOR\tIf bits are different, result is 1; otherwise 0.\n~\tNOT\tIf bit is 0, result is 1; otherwise 0.\n<<\tZero fill left shift\tPushes zeros in from right, leftmost bits fall off.\n>>\tSigned right shift\tPushes copies of leftmost bit in from left, rightmost bit falls off (preserves sign).\n>>>\tZero fill right shift\tPushes zeros in from left, rightmost bits fall off.\nExamples\nAND\nconsole.log(19 & 7); // Output: 3\n\n\n// 10011 = 19\n// 00111 =  7\n// 00011 =  3\nOR\nconsole.log(19 | 7); // Output: 23\n\n\n// 10011 = 19\n// 00111 =  7\n// 10111 = 23\nXOR\nconsole.log(19 ^ 7); // Output: 20\n\n\n// 10011 = 19\n// 00111 =  7\n// 10100 = 20\nNOT\n\nBecause integers are stored in two’s complement (to change the sign, invert the binary digits and add one) a ~ operation will change the sign of the number and change the absolute value by one.\n\nconsole.log(~19); // Output: -20\n\n\n// 00000000000000000000000000010011 =  19\n// 11111111111111111111111111101100 = -20\nZero fill left shift\nconsole.log(19 << 3); // Output: 152\n\n\n// 00000000000000000000000000010011 =  19\n// 00000000000000000000000010011000 = 152\nSigned right shift\n\nThe >> operator preserves the sign of the operand by pushing copies of the leftmost bit in from the left.\n\nconsole.log(19 >> 3); // Output: 2\n\n\n// 00000000000000000000000000010011 =  19\n// 00000000000000000000000000000010 =   2\n\n\nconsole.log(-20 >> 3); // Output: -3\n\n\n// 11111111111111111111111111101100 = -20\n// 11111111111111111111111111111101 =  -3\nZero fill right shift\n\nThe >>> operator does not preserve the sign. It pushes zeros in from the left, pushing the sign bit out of its leftmost position.\n\nconsole.log(19 >>> 3); // Output: 2\n\n\n// 00000000000000000000000000010011 =  19\n// 00000000000000000000000000000010 =   2\n\n\nconsole.log(-20 >>> 3); // Output: 536870909\n\n\n// 11111111111111111111111111101100 = -20\n// 00011111111111111111111111111101 = 536870909"},{"title":"Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.\n\nSingle-line Comments\n\nIn JavaScript, single-line comments are created with two consecutive forward slashes //.\n\n// Prints 5 to the console\nconsole.log(5);\n\nA single-line comment can also be used to comment after a line of code:\n\nconsole.log(5); // Prints 5\nMulti-line Comments\n\nMulti-line comments are created by surrounding the lines with /* at the beginning and */ at the end. Comments are good ways for a variety of reasons like explaining a code block or indicating some hints, etc.\n\n/*  \nThe below configuration must be \nchanged before deployment. \n*/\n\n\nlet baseUrl = 'localhost/taxwebapp/country';\n\nThis syntax can also be used to comment something out in the middle of a line of code:\n\nconsole.log(/* IGNORED! */ 5); // Still prints 5\nCodebyte Example\n\nTry commenting and uncommenting the code below:"},{"title":"Closures","description":"Closures are functions that can refer to variables and other bindings beyond their scope, even after being called.\n\nExample\n\nEach time a new function is defined, a closure is created.\n\nlet myGlobalString = 'World';\n\n\nfunction outer() {\n  let myLexicalString = 'Hello';\n\n\n  function inner() {\n    myLocalString = `${myGlobalString}, ${myLexicalString}!`;\n    return myLocalString;\n  }\n\n\n  return inner;\n}\n\nThis example describes the three primary scopes visible to closures:\n\nmyGlobalString exists in the global scope since it is not defined inside something else, like a function.\nFrom the point-of-view of the inner() function, everything outside its scope (outer functions, the global environment, etc.) is in the lexical environment, including myLexicalString and myGlobalString.\nInside the inner() function is a locally-bound variable, myLocalString, that uses all the variables from its lexical environment.\nCodebyte Example\n\nAnother common instance of JavaScript closures is with callbacks.\n\nIn the example below, the setInterval() function creates a closure in the count() callback that captures the references to the global variables myInterval and counter. Each second, counter is incremented by one, with its value preserved from the previous call. After it gets to seven, myInterval is cleared and reset to null:"},{"title":"Constructors","description":"A constructor is a function that does initialization of an object when the object is created. Arguments are passed to the constructor function when you use the new keyword. There are two types of constructors, one defined as a function, and one defined with the constructor method in a class.\n\nThe Object Constructor Function\n\nTo use a constructor function to create objects, simply define a JavaScript function with any number of arguments. Inside the function, the keyword this is used as a placeholder for the object being created. If the constructor function is used by itself, without the new statement, this will have no value.\n\nIt’s preferred to capitalize a constructor function.\n\nExample\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n\n\nvar car1 = new Car('Chevy', 'Blazer', 2015);\nvar car2 = new Car('Ford', 'Taurus', 2018);\n\n\nconsole.log('Car 1 is a ' + car1.year + ' ' + car1.make + ' ' + car1.model);\n// Output: Car 1 is a 2015 Chevy Blazer\n\n\nconsole.log('Car 2 is a ' + car2.year + ' ' + car2.make + ' ' + car2.model);\n// Output: Car 2 is a 2018 Ford Taurus\nThe Class constructor Method\n\nWhen defining a class in javascript, there is a special constructor method defined within it. Like the object constructor function, the constructor method can be defined with any number of arguments, and the this keyword can be used as a placeholder for the object being created.\n\nExample\nclass Car {\n  constructor(make, model, year) {\n    this.make = make;\n    this.model = model;\n    this.year = year;\n  }\n}\n\n\nvar car1 = new Car('Chevy', 'Blazer', 2015);\nvar car2 = new Car('Ford', 'Taurus', 2018);\n\n\nconsole.log('Car 1 is a ' + car1.year + ' ' + car1.make + ' ' + car1.model);\n// Output: Car 1 is a 2015 Chevy Blazer\n\n\nconsole.log('Car 2 is a ' + car2.year + ' ' + car2.make + ' ' + car2.model);\n// Output: Car 2 is a 2018 Ford Taurus"},{"title":"Conditionals","description":"Conditionals take an expression, which is code that evaluates to determine a value, and checks if it is true or false. If it’s true, we can tell our program to do one thing — we can even account for false to do another.\n\nIf Statement\n\nAn if statement accepts an expression with a set of parentheses:\n\nIf the expression evaluates to a truthy value, then the code within its code body executes.\nIf the expression evaluates to a falsy value, its code body will not execute.\nconst isMailSent = true;\n\n\nif (isMailSent) {\n  console.log('Mail sent to recipient 💌');\n}\n\nThe output would be:\n\nMail sent to recipient 💌\n\nNote: if is in lowercase letters. Uppercase letters will generate a JavaScript error.\n\nElse Statement\n\nAn else block can be added to an if block or series of if-else if blocks. The else block will be executed only if the if condition fails.\n\nconst isTaskCompleted = false;\n\n\nif (isTaskCompleted) {\n  console.log('Task completed');\n} else {\n  console.log('Task incomplete');\n}\n\nIf the hour is less than 18, create a “Good day” greeting, otherwise “Good evening”:\n\nif (hour < 18) {\n  greeting = 'Good day 🌤';\n} else {\n  greeting = 'Good evening 🌙';\n}\nElse If Statement\n\nAfter an initial if block, else if blocks can each check an additional condition. An optional else block can be added after the else if block(s) to run by default if none of the conditionals evaluated to truthy.\n\nIf time is less than 10:00, create a “morning” greeting, if not, but time is less than 20:00, create a “day” greeting, otherwise a “Good evening”:\n\nif (time < 10) {\n  greeting = 'Good morning 🌄';\n} else if (time < 20) {\n  greeting = 'Good day 🌁';\n} else {\n  greeting = 'Good evening 🌉';\n}\n\nHere, the result of greeting will be: Good day 🌁.\n\nCodebyte Example\n\nWhat do you think will happen when pH is changed to 7?"},{"title":"Data Types","description":"Data types are how data in programming is classified. In JavaScript, there are eight fundamental data types:\n\nData Type\tDescription\nNumber\tAny number, including numbers with decimals: 1, -2, 99, 3.14.\nBigInt\tAny number, greater than 2^53-1 or less than -(2^53-1) with n appended to the number: 1234567890123456n.\nString\tAny grouping of characters on your keyboard (letters, numbers, spaces, symbols, etc.) surrounded by single quotes '' or double quotes \"\".\nBoolean\tThis data type only has two possible values — either true or false.\nNull\tThis data type represents the intentional absence of a value, and is represented by the keyword null.\nUndefined\tThis data type is denoted by the keyword undefined. It also represents the absence of a value though it has a different use than null.\nSymbol\tA newer feature to the language, symbols are unique identifiers, useful in more complex coding. No need to worry about these for now.\nObject\tCollections of related data.\n\nThe first 7 of those types are considered primitive data types. They are the most basic data types in the language. Objects are a little more complex.\n\nAt first, eight types may not seem like that many, but they are the foundation that helps programmers build a whole new world.\n\nNumber and BigInt\nvar num = 7;\nvar bigNum = 9999999999999999n;\n\nBigInt is necessary for big numbers because they are unreliable with Number type:\n\nString\n\nStrings in JavaScript can be defined with either ' ' or \" \".\n\nvar greeting = 'Hi buddy';\nvar message = 'You are doing great! Keep studying!';\nBoolean\n\nBoolean is for truthy or falsy values:\n\nvar lateToWork = true;\nvar isTheEarthFlat = false;\nNull and Undefined\n\nNull and Undefined are both for the absence of a value, but they have different meanings.\n\n// Undefined means there should be some values, but it is undefined now\nvar finishCourseTime = undefined;\n\n\n// Null means there is no value here\nvar finishStudyingDate = null;\nObject\n\nObjects can have fields with different values and types inside:\n\nconst user = {\n  name: 'Jane',\n  age: 20,\n  isActive: true,\n};"},{"title":"Dates","description":"Date objects in JavaScript represent a single moment in time stored as a number that represents the number of milliseconds since midnight on January 1st 1970 UTC. Note that this is different from the UNIX epoch, the number of seconds since midnight on January 1st 1970 UTC.\n\nAlso note that, even though the representation of a Date is in UTC, the methods to fetch a date or its components work in the host system’s local time zone.\n\nThe defined range for a Date value is between April 20, 271821 BCE to September 13, 275760 CE.\n\nSyntax\n\nWhen used as a function, Date() returns the current date and time. When used as a constructor, Date() returns a new date object.\n\nvar now = Date();\n\n\nconsole.log(now);\n// Output: Current date as a string\n// Wed July 28 2021 16:47:34 GMT+0000 (Coordinated Universal Time)\n\n\nvar then = new Date();\n\n\nconsole.log(then);\n// Output: Current date as a Date object\n// 2021-07-28T16:47:34.616Z\n\nThe date constructor can take several different parameters to create a new Date object.\n\nvar d = new Date();\n\nNo parameter creates Date object with current date.\n\nvar d = new Date(milliseconds);\n\nmilliseconds creates Date object based on milliseconds from midnight 1/1/1970 UTC.\n\nvar d = new Date(dateString);\n\ndateString creates a Date object based on converting the sting to a date value.\n\nvar d = new Date(year, month, day, hour, minute, second, millisecond);\n\nOr you can specify the date referred to by the Date object by specifying the numeric value for each component of the date.\nDate Methods\nStatic Methods\nMethod\tDescription\n.now()\tReturns the number of milliseconds elapsed since midnight 1/1/1970 UTC.\n.parse()\tParses a string representation of a date and returns the number of milliseconds represented by that date.\n\nThe instance methods are listed at the bottom of the page.\n\nExamples\nvar d = new Date('2019-05-01 12:00:00.000');\n\n\nconsole.log(d.toDateString());\n// Output: Wed May 01 2019\n\n\nconsole.log(d.getFullYear());\n// Output: 2019\n\n\nconsole.log(d.toISOString());\n// Output: 2019-05-01T12:00:00.000Z\n\n\nconsole.log(d.toUTCString());\n// Output: Wed, 01 May 2019 12:00:00 GMT\n\n\nd.setFullYear(2020);\nd.setHours(16);\nd.setMinutes(30);\n\n\nconsole.log(d.toISOString());\n// Output: 2020-05-01T16:30:00.000Z\n\n\nconsole.log(d.getTime());\n// Output: 1588350600000"},{"title":"Errors","description":"When JavaScript throws an error it throws an error object that consists of a name and a message property. The name is the general type of the error, and the message is a human-readable description of the specific error that happened.\n\nThrown errors are caught by the next outer catch block of a try...catch...finally statement. They can also be thrown intentionally by the throw statement.\n\nThe Error Object\n\nThe error object holds information about the exception that was thrown in its two properties:\n\nname Sets or returns an error name. (Type of Error)\nmessage Sets or returns an error message. (Description of specific instance.)\n\nThe following types of error can be returned by the name property:\n\n“EvalError” An error has occurred in the eval() function (Note: Depreciated in newer versions of JavaScript)\n“RangeError” A number “out of range” has occurred\n“ReferenceError” An illegal reference has occurred\n“SyntaxError” A syntax error has occurred\n“TypeError” A type error has occurred\n“URIError” An error in encodeURI() has occurred\n\nThese are some example messages for various types of errors:\n\nRangeError\ninvalid array length\ninvalid date\nReferenceError\n“x” is not defined\nassignment to undeclared variable “x”\nSyntaxError\n“x” is a reserved identifier\na declaration in the head of a for-of loop can’t have an initializer\nTypeError\n“x” is not a function\n“x” is read-only\nURIError\nmalformed URI sequence"},{"title":"Events","description":"Events are things that happen in HTML objects that can trigger scripting code. JavaScript can be executed by events in HTML via two methods:\n\nThe JavaScript code can appear within the appropriate HTML attribute in the HTML object.\nOr a separate script can define an event handler on the object that executes when the event is fired.\nSyntax 1\n\nYou can assign JavaScript code to an event attribute in an HTML object.\n\n<!-- Clicking pops up a \"Hello World!\" dialog box -->\n<button onclick=\"window.alert('Hello World!');\">Click Me!</button>\nSyntax 2\n\nThere’s HTML on the page with the object of interest.\n\n<button id=\"hello-button\">Click Me!</button>\n\nIn a separate script the object is referred to and assigned an event handler.\n\n// Clicking the \"hello-button\" button pops up a \"Hello World!\" dialog box\nvar btn = document.getElementById('hello-button');\n\n\nbtn.addEventListener('click', () => {\n  window.alert('Hello World!');\n});"},{"title":"Hash Tables","description":"A hash table is an implementation of an associative array, a list of key-value pairs that allow you to retrieve a value via a key. Internally a hash table utilizes a hash function to transform a key value into an index that points to where the value is stored in memory. Hash tables have fast search, insertion and delete operations.\n\nThere are two main ways to implement a hash table/associative array in JavaScript.\n\nUsing the Object Data Type\n\nThe simplest implementation is using the Object data type. This is because all non-scalar objects in JavaScript behave as associative arrays, a mapping from property keys to values. So an Object itself can behave as a basic hash table.\n\nvar simplehash = new Object();\n// or\n// var simplehash = {};\n\n\nsimplehash['key1'] = 'value1';\nsimplehash['key2'] = 'value2';\nsimplehash['key3'] = 'value3';\n\n\nfor (var key in simplehash) {\n  // use hasOwnProperty() to filter out properties from Object.prototype\n  if (simplehash.hasOwnProperty(key)) {\n    console.log('key is: ' + key + ', value is: ' + simplehash[key]);\n  }\n}\n\nThe output would look like:\n\nkey is: key1, value is: value1\nkey is: key2, value is: value2\nkey is: key3, value is: value3\n\nThere are some downsides to this approach:\n\nThe Object comes with its own properties which could collide with potential key names.\nThere no easy way to get the size of a Hash Table stored in an Object, so it must be tracked manually.\nSince they are also property names, the keys used are limited to String or Symbol types.\nObject isn’t optimized for frequent additions and removals of key-value pairs\nUsing a Map Object\n\nThe Map object was created to implement this type of associative array without some of the downsides of using a basic Object:\n\nThere are no pre-existing keys that could result in a collision\nA Map object has a size property to track its contents.\nA Map object can have keys that are any data type.\nA Map has been optimized for repeated addition and insertion of key-value pairs.\n\nA Map object also comes with the following methods:\n\n.clear() Removes all key-value pairs from the Map object.\n.delete(key) Deletes the key-value pair and returns true if the key exists. Returns false otherwise.\n.get(key) Returns the value associated with key, or undefined if key doesn’t exist.\n.has(key) Returns true if key exists, false otherwise.\n.set(key,value) Sets the value for the key in the Map object and returns the Map object.\n\nNote: Key-value pairs must be set with the set method in order for the Map object to behave as expected. Using the syntax for Object above will appear to work, but will not associate the key-value pair to its internal collection.\n\nvar maphash = new Map();\n\n\nmaphash.set('key1', 'value1');\nmaphash.set('key2', 'value2');\nmaphash.set('key3', 'value3');\n\n\nconsole.log(maphash.get('key3'));\n// Output: value3\n\n\nmaphash.set('key1', 'new value');\n\n\nconsole.log(maphash.get('key1'));\n// Output: new value\n\n\nconsole.log(maphash.size);\n// Output: 3\n\n\nmaphash.delete('key2');\n\n\nconsole.log(maphash.size);\n// Output: 2\n\n\nfor (const [key, value] of maphash) {\n  console.log(key + ' = ' + value);\n}\n// Output: key1 = new value\n//         key3 = value3"},{"title":"Functions","description":"Functions are one of the fundamental building blocks in JavaScript. A function is a reusable set of statements to perform a task or calculate a value. Functions can be passed one or more values and can return a value at the end of their execution. In order to use a function, you must define it somewhere in the scope where you wish to call it.\n\nFunction Declaration\n\nFunction declarations are used to create named functions. These functions can be called using their declared name. Function declarations are built from:\n\nThe function keyword.\nThe function name.\nAn optional list of parameters separated by commas enclosed by a set of parentheses ().\nA function body enclosed in a set of curly braces {}.\n\nThe example code provided contains a function named sum() that takes in two values and prints their sum:\n\nfunction sum(number1, number2) {\n  console.log(number1 + number2);\n}\nCalling Functions\n\nFunctions can be called, or executed, elsewhere in code using parentheses following the function name. When a function is called, the code inside its function body runs. Arguments are values passed into a function when it is called.\n\n// Defining the function\nfunction sum(num1, num2) {\n  return num1 + num2;\n}\n\n\n// Calling the function\nsum(2, 4);\n\nThe output would be:\n\n6\nReturn Keyword\n\nFunctions return (pass back) values using the return keyword. return ends function execution and returns the specified value to the location where it was called.\n\nA common mistake is to forget the return keyword, in which case the function will return undefined by default.\n\n// With return\nfunction sum(num1, num2) {\n  return num1 + num2;\n}\n\n\n// Without return, so the function doesn't output the sum\nfunction sum(num1, num2) {\n  num1 + num2;\n}\nArrow Functions\n\nArrow function expressions were introduced in ES6. These expressions are clean and concise. The syntax for an arrow function expression does not require the function keyword and uses a fat arrow => to separate the parameter(s) from the body.\n\nThere are several variations of arrow functions:\n\nArrow functions with a single parameter do not require () around the parameter list.\nArrow functions with a single expression can use the concise function body which returns the result of the expression without the return keyword.\n\nArrow function with no arguments:\n\nconst printHello = () => {\n  console.log('hello');\n};\n\n\nprintHello();\n// Output: hello\n\nArrow function with a single argument:\n\nconst checkWeight = (weight) => {\n  console.log(`Baggage weight : ${weight} kilograms.`);\n};\n\n\ncheckWeight(25);\n// Output: Baggage weight : 25 kilograms.\n\nArrow function with two arguments:\n\nconst sum = (firstParam, secondParam) => {\n  return firstParam + secondParam;\n};\n\n\nconsole.log(sum(2, 5));\n// Output: 7\n\nConcise arrow function:\n\nconst multiply = (a, b) => a * b;\n\n\nconsole.log(multiply(2, 30));\n// Output: 60\nAnonymous Functions\n\nAnonymous functions in JavaScript do not have a name property. They can be defined using the function keyword, or as an arrow function. See the code example for the difference between a named function and an anonymous function.\n\n// Named function\nfunction rocketToMars() {\n  return 'BOOM!';\n}\n\n\n// Anonymous function\nconst rocketToMars = function () {\n  return 'BOOM!';\n};\nVoid Functions\n\nJavaScript uses the void keyword for denoting expressions that return a value of undefined. These expressions can be in the form of variables or functions. This allows functions to work as expressions and not declarations:"},{"title":"Iterators","description":"Iterators are used to loop over a group of data members, or a collection.\n\nAn iterator is an object that implements the iteration protocols. Many built-in data types (Strings, Arrays, Maps, Sets, etc.) have an iterator property that make them iterable.\n\nIterable Protocol\n\nAll iterable objects implement the @@iterator method. In other words, an object must have or inherit, via its prototype chain, the @@iterator property key.\n\nWhen an object is to be iterated, the @@iterator method is called without any arguments, and the returned iterator obtains the values or elements to be looped through.\n\nIterator Protocol\n\nThe iterator protocol, by definition, implements the next() method and returns an object with at least two properties:\n\ndone is a boolean that determines whether the sequence has been completed or consumed. Its value is false if incomplete and true otherwise.\nvalue is any type of value the iterator returns.\nExample\n\nThis range-based iterator, loops through a collection of integers and satisfies the iteration protocols.\n\nfunction createRangeIterator(min = 0, max = Infinity, step = 1) {\n  let nextNum = min;\n  let numCount = 0;\n\n\n  const rangeIterator = {\n    next: function () {\n      let result;\n      if (nextNum < max) {\n        result = { value: nextNum, done: false };\n        nextNum += step;\n        numCount++;\n        return result;\n      }\n      return { value: numCount, done: true };\n    },\n  };\n\n\n  return rangeIterator;\n}\nThe rangeIterator object is an iterator object that satifies the iterator protocol.\nWhen all elements in the range collection are iterated over, done becomes true and is returned.\n\nTo use the createRangeIterator():\n\nconst useCase = createRangeIterator(2, 8, 2);\n\n\nlet result = useCase.next();\n\n\nwhile (!result.done) {\n  console.log(result.value);\n  result = useCase.next();\n}\n\nThis will output:\n\n2\n4\n6\n{ value: 3, done: true }"},{"title":"Hoisting","description":"Hoisting is a default process where JavaScript “splits” var and function declarations from their definitions. These declarations are “moved up” to the top of the file above where they were defined and/or used. This means that JavaScript knows about these declarations before the rest of the code is executed.\n\nVariables\n\nIn JavaScript, variables declared with the var keyword are hoist-able. For example:\n\nconsole.log(`My name is ${myName}.`); // Output: My name is undefined.\n\n\nvar myName = 'Brandon';\n\nIn the code block, we are logging myName to the console before it is declared and assigned. Doing so will yield undefined. While JavaScript’s compiler has stored the declaration for myName in memory, its definition is still not known. Therefore, its value and type is undefined.\n\nDuring the execution phase, the code will refactor like this:\n\nvar myName;\n\n\nconsole.log(`My name is ${myName}.`); // Output: My name is undefined.\n\n\nmyName = 'Brandon';\n\nIf we tried to log a variable that hasn’t been defined yet, we’d get a ReferenceError:\n\nconsole.log(`My name is ${name}.`); // --> ReferenceError\n\n\nvar myName = 'Brandon';\nFunctions\n\nIn addition to variables, functions can be hoisted in JavaScript. This is mainly because they are “first-class objects” and they can be stored as variables. The declarations for functions, like the ones for variables, are hoisted during the execution phase:\n\nconsole.log(greetings()); // Output: Hi! My name is Brandon.\n\n\nfunction greetings() {\n  var myName = 'Brandon';\n  console.log(`Hi! My name is ${myName}.`);\n}\n\nThe output would be:\n\nHi! My name is Brandon.\nundefined\n\nIn the code above, we wrote a log statement for executed greetings() function, which is defined below. Inside greetings(), we declare a local variable myName defined as a string. Next, we finish the function by logging a phrase to the console (with myName interpolated within). Notice how even though greetings() was logged before it was completely defined, the body of the function run anyways. If we try logging just the function without parentheses:\n\nconsole.log(`${greetings}`);\n\n\nfunction greetings() {\n  var myName = 'Brandon';\n  console.log(`Hi! My name is ${myName}.`);\n}\n\nThe output would be:\n\nfunction greetings() {\n   var myName = \"Brandon\";\n   console.log(`Hi! My name is ${myName}.`);\n}\n\nBecause greetings was defined as function declaration, the entire function was hoisted into memory by JavaScript. However, if greetings were written as a function stored in a variable (a function expression), then the function definition would not be accessible. Its value and type would be undefined like any other hoisted variable.\n\nconsole.log(greetings);\n\n\nvar greetings = function () {\n  var myName = 'Brandon';\n  console.log(`Hi! My name is ${myName}.`);\n};\n\nThe output would be:\n\nundefined\n\nIf we try to execute greetings and log the result to the console, JavaScript does something interesting:\n\nconsole.log(typeof greetings); // undefined\n\n\nconsole.log(greetings());\n\n\nvar greetings = function () {\n  var myName = 'Brandon';\n  console.log(`Hi! My name is ${myName}.`);\n};\n\nIt returns an error:\n\nTypeError: greetings is not a function\n   at Object.<anonymous> ...\n\nFirst, we logged the type of greetings just to remind what the type for the hoisted variable is. Next, we attempted to log the executed greetings() function to the console and received a TypeError stating that we are not dealing with a function.\n\nHow is that possible? Again, at this point in the execution phase, the hoisted greetings variable is of type undefined. The definition of greetings as a function doesn’t happen until the next line. Therefore, JavaScript threw the TypeError.\n\nlet and const\n\nHoisting is a great way of understanding how the execution context in JavaScript affects variable and function declarations. However, with the introduction of new syntax in ES2015 (ES6), hoisting treats variables declared with let or const differently.\n\nAs of ES6, let and const are recommended for replacing var when declaring variables. In the context of hoisting, all three of these keywords are moved to the top of their scopes during the execution phase. But let and const behave differently where, if no definition was provided before hoisting, the hoisted declaration won’t be initialized with undefined or any other value. This will, in turn, throw a ReferenceError.\n\n// Before hoisting\n\n\nconsole.log(`My name is ${myName}.`);\nlet myName = 'Brandon';\n\n\n// After hoisting\n\n\nlet myName;\nconsole.log(`My name is ${myName}.`); // ReferenceError: Cannot access 'myName' before initialization\nmyName = 'Brandon';\n\nIn the code above, we logged the phrase with myName to the console. On the next line, we declared and defined myName using let and “Brandon”, respectively. During the execution phase, the let myName declaration is hoisted up, but the initialization is left below. Because of how let works, the log statement threw the ReferenceError. This can be avoided if initialization occurs before the log statement.\n\n// Before hoisting\n\n\nlet myName = 'Brandon';\nconsole.log(`My name is ${myName}.`);\n\n\n// After hoisting\n\n\nlet myName;\nmyName = 'Brandon';\nconsole.log(`My name is ${myName}.`); // Output: My name is Brandon.\n\nWith const declarations, initialization is required before execution. Unlike var and let, these variables can’t be declared and defined separately.\n\n// This will work\n\n\nvar name1;\nname1 = \"Megan\";\nconsole.log(name1); // Output: Brandon\n\n\n// This will also work\n\n\nlet name2;\nname2 = \"Joe\";\nconsole.log(name2); // Output: Joe\n\n\n// This will not work\n\n\nconst name3;\nname3 = \"James\";\nconsole.log(name3); // SyntaxError: Missing initializer in const declaration\n\nThe reason let and const variables cannot be used before they have been initialized is that they will be in a “Temporal Dead Zone” (TDZ). For a given variable declared with let or const, TDZ is the scope which is from the start of the block to the initialization line of that variable.\n\n/* Line 1 in TDZ, cannot read or write the variable foo */\n/* Line 2 */ let foo = 4;\n/* Line 3 Now, can read and write the variable foo */\n\nAccessing variables and functions before they are declared is bad practice because it is hard to understand and confusing for people who read your code. With var, you may read or change the variable unintentionally before initialization, but JavaScript doesn’t give you an error that you may be doing something wrong. Thanks to let, const, and TDZ, we can avoid and catch many potential bugs."},{"title":"Loops","description":"A loop is a programming tool that is used to repeat a set of instructions. Iterate is a generic term that means “to repeat” in the context of loops. A loop will continue to iterate until a specified condition, commonly known as a stopping condition, is met.\n\nWhile Loop\n\nThe while loop creates a loop that is executed as long as a specified condition evaluates to true. The loop will continue to run until the condition evaluates to false. The condition is specified before the loop, and usually, some variable is incremented or altered in the while loop body to determine when the loop should stop.\n\nwhile (condition) {\n  // Code block to be executed\n}\n\nFor example:\n\nlet i = 0;\n\n\nwhile (i < 5) {\n  console.log(i);\n  i++;\n}\nDo…While Loop\n\nA do…while statement creates a loop that executes a block of code once, checks if a condition is true, and then repeats the loop as long as the condition is true. They are used when you want the code to always execute at least once. The loop ends when the condition evaluates to false.\n\nx = 0;\ni = 0;\n\n\ndo {\n  x = x + i;\n  console.log(x);\n  i++;\n} while (i < 5);\n\n\n// Output: 0 1 3 6 10\nFor Loop\n\nA for loop declares looping instructions, with three important pieces of information separated by semicolons ;:\n\nThe initialization defines where to begin the loop by declaring (or referencing) the iterator variable\nThe stopping condition determines when to stop looping (when the expression evaluates to false)\nThe iteration statement updates the iterator each time the loop is completed\nfor (let i = 0; i < 4; i += 1) {\n  console.log(i);\n}\n\n\n// Output: 0, 1, 2, 3\nfor...of Loop\n\nA for...of loop iterates over an object’s values rather than their keys. This allows for direct access to the items, as opposed to index-reference. Examples of iterable objects include:\n\nAn Array of elements.\nA String of characters.\nA Map of key/value pairs.\nconst items = ['apple', 'banana', 'cherry'];\n\n\nfor (const item of items) {\n  console.log(item);\n}\n\nThe output would be:\n\napple\nbanana\ncherry\nfor...in Loop\n\nA for..in.. loop iterates over any object with string type keys and allows for access to the values by index-reference.\n\nconst shoppingCart = { banana: 2, apple: 5, cherry: 0 };\n\n\nfor (const fruit in shoppingCart) {\n  console.log(fruit);\n}\n\nThe output would be:\n\nbanana\napple\ncherry\nfor (const fruit in shoppingCart) {\n  console.log(shoppingCart[fruit]);\n}\n\nThe output would be:\n\n2\n5\n0\nReverse Loop\n\nA for loop can iterate “in reverse” by initializing the loop variable to the starting value, testing for when the variable hits the ending value, and decrementing (subtracting from) the loop variable at each iteration.\n\nconst items = ['apricot', 'banana', 'cherry'];\n\n\nfor (let i = items.length - 1; i >= 0; i -= 1) {\n  console.log(`${i}. ${items[i]}`);\n}\n\nThe output should look like:\n\n2. cherry\n1. banana\n0. apricot\nLooping Through Arrays\n\nAn array’s length can be evaluated with the .length property. This is extremely helpful for looping through arrays, as the .length of the array can be used as the stopping condition in the loop.\n\nfor (let i = 0; i < array.length; i++) {\n  console.log(array[i]);\n}\n\n\n// Output: Every item in the array\nLooping Through Objects\n\nThe Object.entries() method can be used to loop through an object’s key-value pairs as an array. It returns an array of arrays, each of which represents a key-value pair. In the example below, Object.entries() is used to define a variable called myEntries:\n\nconst objectK = {\n  name: 'Codecademy',\n  age: 10,\n};\n\n\nconst myEntries = Object.entries(objectK);\n\n\nconsole.log(myEntries);\n// Output: [ [ 'name', 'Codecademy' ], [ 'age', 10 ] ]\n\nNext, a for..of loop can be used to print the key‘s and value‘s for myEntries:\n\nfor (const [key, value] of myEntries) {\n  console.log(`${key}: ${value}`);\n}\n\nThe output will look like this:\n\nname: Codecademy\nage: 10\nBreak Keyword\n\nWithin a loop, the break keyword may be used to exit the loop immediately, continuing execution after the loop body.\n\nHere, the break keyword is used to exit the loop when i is greater than 5.\n\nfor (let i = 0; i < 99; i += 1) {\n  if (i > 5) {\n    break;\n  }\n  console.log(i);\n}\n\n\n// Output: 0 1 2 3 4 5\nNested For Loop\n\nA nested for loop is when a for loop runs inside another for loop.\n\nThe inner loop will run all its iterations for each iteration of the outer loop.\n\nfor (let outer = 0; outer < 2; outer += 1) {\n  for (let inner = 0; inner < 3; inner += 1) {\n    console.log(`${outer}-${inner}`);\n  }\n}\n\nThe output should look like:\n\n0-0\n0-1\n0-2\n1-0\n1-1\n1-2"},{"title":"Map","description":"A Map is an object in JavaScript that stores entries of key-value pairs in their original insertion order.\n\nValues mapped to existing keys can be overwritten later.\nKeys/values can either be an object or a variable of any data type.\nMaps are directly iterable whereas objects are not.\nSyntax\n\nA map can be defined with the new keyword. The example below creates an empty Map object, map:\n\nconst map = new Map();\nExample\n\nTo create a non-empty Map object, an array of arrays is passed into Map(). Each inner array represents a key-value pair:\n\nconst hogwartsStudents = new Map([\n  ['Gryffindor', 'Harry Potter'],\n  ['Slytherin', 'Draco Malfoy'],\n  ['Hufflepuff', 'Cedric Diggory'],\n]);\n\n\nconsole.log(hogwartsStudents);\n\nThe output will be:\n\nMap(3) {\n  'Gryffindor' => 'Harry Potter',\n  'Slytherin' => 'Draco Malfoy',\n  'Hufflepuff' => 'Cedric Diggory'\n}\nCodebyte Example\n\nIn the example below, an addressBook maps a person’s name to a phone number. By the end of the program:\n\nTom has moved and deleted their phone number with the .delete() method.\nPaul has changed their phone number using the .set() method."},{"title":"Memoization","description":"In JavaScript, memoization can be used to improve a program’s performance.\n\nThis is ideal whenever the same calculations (with the same inputs and outputs) are known to take place. Memoization helps by saving, or caching, these results in computer memory for later use. It can be applied to many contexts, including:\n\nMaking calls to recursive or pure functions where some calculations use the same inputs and return the same outputs.\nFetching from the server with the same base API endpoints.\nSyntax\nmemo = []\n\nfunction memoFunction(arg) {\n  if(memo[arg]) {\n    return memo[arg]\n  } else {\n    // Do this and update memo.\n  }\n}\n\nMemoized results can be represented with arrays or objects. In a given function, if a previously calculated result exists in the memo array, it is returned. Otherwise, normal calculations take place and the memo array is updated.\n\nExample\n\nIn the example below, the getSquare() function accepts a parameter n and returns the square of it. With small inputs, this function takes little to no time to process. But as the inputs get larger, the timelapse becomes more noticeable. This point is further shown with the calls to console.time() and console.timeEnd().\n\nTo address this, memoization is used in the getSquareMemo() function where such calculations are skipped if they have already been made and stored in memo."},{"title":"Methods","description":"In JavaScript methods are object properties containing a function definition. Within the function definition, this can be used to refer to the containing object as long as the function is defined within the object.\n\nNote: If a function is assigned to a property later, any reference to this will reflect the context of the new function. Also, if the object’s function is assigned to a variable and executed via the variable, this will reflect the variable’s execution context.\n\nSyntax\n\nA method of an object is called via the following syntax:\n\nobjectName.methodName();\n\nIf a method is called without parenthesis, it is being called as a property, which means it will return the function definition, not execute the method.\n\nExample\nconst car = {\n  make: 'Honda',\n  model: 'Civic',\n  year: 2019,\n  printOut: function () {\n    console.log(this.year + ' ' + this.make + ' ' + this.model);\n  },\n};\n\n\ncar.printOut();\n// Output: 2019 Honda Civic\n\n\n// Referenced as a property\nvar method = car.printOut;\n\n\ncar.year = 2020;\n\n\nmethod();\n// Output: undefined undefined undefined;\n// 'this' is being referenced outside an object context\n// can be fixed by explicitly setting the object context with 'bind()'\n\n\nmethod = car.printOut.bind(car);\n\n\nmethod();\n// Output: 2020 Honda Civic"},{"title":"NPM","description":"Node Package Manager (NPM) is a large collection of JavaScript packages. This makes adding complexity and funcionality to JavaScript project seamless. NPM is also the official package manager of Node.js. Therefore, if Node.js was previously downloaded, NPM is already installed!\n\nPackages\n\nPackages are tools composed of files and folers of JavaScript code. They provide one or more operations that can be installed, imported and used in a separate project. Thanks to NPM, the installation process for packages is uniform.\n\nThe NPM Registry\n\nNPM comes as two primary tools:\n\nA command-line tool with abilities that include installing and uninstalling packages.\nAn online registry of all packages registered with NPM.\n\nOn the NPM registry, all public packages can be searched and reviewed before installing. Most packages come with a README.md file with instructions for installation and usage.\n\nCommon Commands\n\nAs a command-line tool, NPM comes with a litany of commands for working with packages. One of the most common NPM commands is:\n\nnpm install <package-name-here>\n\nThis is used to install packages from the NPM registry and add them to a JavaScript project. Running the command as npm install with no specific package will (re)install all the packages for the project.\n\nTo learn more, run the following to get a brief overview of common commands:\n\nnpm --help\n\nnpm -h works, too.\n\nAlternatively, run the following to display a (long) list of all NPM commands paired with brief descriptions:\n\nnpm -l"},{"title":"Modules","description":"As the program grows bigger, it may contain many lines of code. Instead of putting everything in a single file, modules can be used to separate codes in separate files as per their functionality. This makes the code more organized and easier to maintain.\n\nA module is a file that contains code that performs a specific task. A module may contain variables, functions, classes, etc.\n\nSuppose, a file named greetPerson.js contains the following code:\n\n// Exporting a function\nexport function greetPerson(name) {\n  return `Hi, ${name}`;\n}\n\nNow, to use the code of greetPerson.js in another file main.js, the following code can added to the other file:\n\n// Importing greetPerson from greetPerson.js file\nimport { greetPerson } from './greetPerson.js';\n\n\n// Using greetPerson() defined in greetPerson.js\nlet displayName = greetPerson('Codecademy');\n\n\nconsole.log(displayName);\n// Output: Hi, Codecademy\n\nTwo things happened:\n\nIn the greetPerson.js file, the greetPerson() function is exported using the export keyword.\n\nexport function greetPerson(name) {\n  ...\n}\n\nIn the main.js file, the greetPerson() function is imported using the import keyword.\n\nimport { greetPerson } from '/.greetPerson.js';\n\nNote that there are { } wrapped around the function in the import syntax.\n\nExport Multiple Objects\n\nIt is also possible to export multiple objects from a module.\n\nFor example, suppose there’s a module.js file:\n\n// Exporting the variable\nexport const name = 'Codecademy Docs';\n\n\n// Exporting the function\nexport function difference(x, y) {\n  return x - y;\n}\n\nIn main file main.js:\n\nimport { name, difference } from './module.js';\n\n\nconsole.log(name); // Output: Codecademy Docs\n\n\nlet diff = difference(9, 5);\n\n\nconsole.log(diff); // Output: 4\n\nHere, both the name variable and the difference() function from the module.js file are imported to main.js.\n\nRenaming Imports and Exports\n\nIf the objects (variables, functions, etc.) that you want to import are already present in your main file, the program may not behave as you want. In this case, the program takes value from the main file instead of the imported file.\n\nTo avoid naming conflicts, you can rename these objects during the export or during the import.\n\nRename in the export file (the module)\n// In module.js\nexport { function1 as newName1, function2 as newName2 };\n// In main.js\nimport { newName1, newName2 } from './module.js';\n\nHere, while exporting the function from module.js file, new names (here, newName1 & newName2) are given to the function. Hence, when importing that function, the new name is used to reference that function.\n\nRename in the import file (the main file)\n// In module.js\nexport { function1, function2 };\n// In main.js\nimport { function1 as newName1, function2 as newName2 } from './module.js';\n\nHere, while importing the function, the new names (here, newName1 & newName2) are used for the function name. Now you use the new names to reference these functions.\n\nDefault Export\n\nYou can also perform default export of the module. In the file greetPerson.js:\n\n// Default export\nexport default function greetPerson(name) {\n  return `Hi, ${name}`;\n}\n\n\nexport const age = 23;\n\nThen when importing, you can use:\n\nimport random_name from './greetPerson.js';\n\nWhile performing default export,\n\nrandom_name is imported from greetPerson.js. Since random_name is not in greetPerson.js, the default export (greetPerson() in this case) is exported as random_name.\nYou can directly use the default export without enclosing curly brackets {}.\nModules Always use Strict Mode\n\nBy default, modules are in strict mode. For example:\n\n// In greetPerson.js\nfunction greetPerson() {\n  // Strict by default\n}\n\n\nexport greetPerson();"},{"title":"Number Methods","description":"JavaScript treats primitive values as objects when it’s executing methods and properties.\n\nThe Number object is used to represent numbers, like 3.14, -10, or 2022, and it comes with a handful of methods that’s useful for handling with numbers."},{"title":"Objects","description":"A JavaScript object can be created or defined with an object literal:\n\nconst person = {\n  firstName: 'Elizabeth',\n  lastName: 'Harmon',\n  age: 22,\n  eyeColor: 'Hazel',\n};\n\nSpaces and line breaks are not important. An object definition can span multiple lines:\n\nconst person = {\n  firstName: 'Elizabeth',\n  lastName: 'Harmon',\n  age: 22,\n  eyeColor: 'Hazel',\n};\nObject Properties\n\nThe key: value pairs in JavaScript objects are called properties:\n\nProperty Key\tProperty Value\nfirstName\t\"Elizabeth\"\nlastName\t\"Harmon\"\nage\t22\neyeColor\t\"Hazel\"\nAccessing Object Properties\n\nObject properties can be accessed using the dot notation:\n\nobjectName.propertyName\nperson.lastName;\n\nOr using square brackets:\n\nobjectName[\"propertyName\"]\nperson['lastName'];\nObject Methods\n\nObject methods are actions that can be performed on objects.\n\nMethods are stored in properties as function definitions.\n\nconst person = {\n  firstName: 'Elizabeth',\n  lastName: 'Harmon',\n  age: 22,\n  eyeColor: 'Hazel',\n  greeting: function () {\n    return `Hi, I am ${this.firstName} ${this.lastName}.`;\n  },\n};\n\n\nconsole.log(person.greeting());\nThe greeting key holds a function value that returns a template literal using backticks.\nWhen person.greeting value is invoked, the corresponding function will run.\n\nThis will output:\n\nHi, I am Elizabeth Harmon.\nObject Classes\n\nClasses are essentially boilerplate object templates. If a car was an object, then a car factory is an object class.\n\nA class can be constructed with the following notation. The person object example will be used.\n\nNote: Anonymous functions can’t be used in classes.\n\nclass Person {\n  greeting() {\n    return `Hi, I am ${this.firstName} ${this.lastName}.`;\n  }\n}\n\nTo use a class, an instance of it needs to be created. To demonstrate how an instance of a class is an object, its properties will be defined using the dot notation.\n\nconst person = new Person();\nperson.firstName = 'Elizabeth';\nperson.lastName = 'Harmon';\nperson.age = 22;\nperson.eyeColor = 'Hazel';\nconsole.log(person);\n/*  \nOutput: \nPerson {\n  firstName: 'Elizabeth',\n  lastName: 'Harmon',\n  age: 22,\n  eyeColor: 'Hazel'\n} \n*/\n\nAn additional step can be made to optimize this procedure through the use of a constructor. A constructor function initializes a set of variables at the creation of a class. Thanks to constructors, object properties can be defined when a new instance is made. This makes code precise and concise.\n\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n  greeting() {\n    return `Hi, I am ${this.firstName} ${this.lastName}.`;\n  }\n}\n\nTo summarize what’s been done, when making a new instance, the constructor assigns the new object the two new properties ‘firstName’ and ‘lastName’ whose values are inputted at the time of creating the instance.\n\nconst person = new Person('Elizabeth', 'Harmon');\nconsole.log(person);\n/*\nOutput:\nPerson {\n  firstName: 'Elizabeth',\n  lastName: 'Harmon',\n  __proto__: {\n    constructor: ƒ Person(),\n    greeting: ƒ greeting()\n  }\n} \n*/\n\n\nperson.greeting();\n// Output: \"Hi, I am Elizabeth Harmon\""},{"title":"Promise","description":"A JavaScript Promise is an object that can be used to get the outcome of an asynchronous operation when that result is not instantly available.\n\nSince JavaScript code runs in a non-blocking manner, promises become essential when we have to wait for some asynchronous operation without holding back the execution of the rest of the code. Some common use cases for promises include using data from APIs and downloading images.\n\nPromise object state\n\nPromises are ideal for performing asynchronous JavaScript operations. This is supported by their use of three states:\n\nA pending state, where the promise has yet to resolve or be rejected.\nA fulfilled status, where asynchronous operations are complete and a value has been returned.\nA rejected state, where asynchronous operations have failed at some point.\nSyntax\n\nA Promise object is returned from a function that accepts two unique functions: resolve and reject:\n\nlet myPromise = new Promise((resolve, reject) => {\n  // Promise code here\n});\n\nIf myPromise yields a legitimate value, it will execute the resolve() function. However, if something were to go awry, such as bad data or a server error, the reject() function would execute, instead.\n\nChaining\n\nChaining is a technique used to perform additional operations against a “fulfilled” promise. The following methods are used for promise chaining:\n\n.then(), which performs operations on a fulfilled promise object and returns a new value.\n.catch(), which handles any anticipated promise rejections and throws an error.\n.finally(), which executes without regard to whether the promise was fulfilled or rejected.\n\nBelow is a brief example of using chaining to produce a success message after the promise is fulfilled:\n\nconst promise = new Promise((resolve, reject) => {\n  const term1 = 2;\n  const term2 = 2;\n  const expression = term1 + term2;\n  const answer = 4;\n  const expressionIsCorrect = expression === answer;\n\n\n  // 2 + 2 = 4, and 4 = 4, so this is true!\n  if (expressionIsCorrect) {\n    resolve('The promise was fulfilled!');\n  } else {\n    reject({\n      errorType: 'ArithmeticError',\n      message: \"The expression didn't evaluate correctly.\",\n      originalExpression: `${term1} + ${term2} === ${answer}`,\n    });\n  }\n});\n\n\npromise\n  .then((message) => {\n    console.log(`Success: ${message}`);\n  })\n  .catch((err) => {\n    console.log(\n      `${err.errorType}: ${err.message} \\nOriginal Expression: ${err.originalExpression}`\n    );\n  })\n  .finally((message) => {\n    console.log('Operations finished');\n  });\n\n\n// Output: Success: The promise was fulfilled!"},{"title":"Operators","description":"An operator is a special character or series of characters that perform a task in JavaScript.\n\nAssignment Operator\n\nThe assignment operator (=) assigns a value to a variable.\n\nvar x = 10;\nArithmetic Operators\n\nArithmetic operators are used to perform arithmetic on numbers:\n\n+ addition\n- subtraction\n* multiplication\n/ division\n% modulo\n// Addition\n5 + 5;\n// Subtraction\n10 - 5;\n// Multiplication\n5 * 10;\n// Division\n10 / 5;\n// Modulo\n10 % 5;\nAssignment Operators\n\nAn assignment operator assigns a value to its left operand based on the value of its right operand. Here are some of them:\n\n+= addition assignment\n-= subtraction assignment\n*= multiplication assignment\n/= division assignment\nlet number = 100;\n\n\n// Both statements will add 10\nnumber = number + 10;\nnumber += 10;\n\n\nconsole.log(number);\n// Output: 120\nComparison Operators\n== equal to\n=== equal value and equal type\n!= not equal\n!== not equal value or not equal type\n> greater than\n< less than\n>= greater than or equal to\n<= less than or equal to\n? ternary operator"},{"title":"Requests","description":"XMLHttpRequest is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nIt is basically used to fetch data from API’s.\n\nThere’s another, modern method fetch, that somewhat deprecates XMLHttpRequest but the focus of this post will be on XMLHttpRequest only.\n\nGetting Started\n\nXMLHttpRequest can be used in two modes: synchronous and asynchronous.\n\n1. Asynchronous Method\n\nThere are 4 steps to do this:\n\nCreate XMLHttpRequest:\n\nlet xhr = new XMLHttpRequest();\n\nThe constructor has no arguments.\n\nInitialize it:\n\nxhr.open(method, URL, [async, user, password]);\n\nThis method specifies the main parameters of the request:\n\nmethod: HTTP-method. Usually \"GET\" or \"POST\".\nURL: The URL to request, a string, can be URL object.\nasync: If explicitly set to false, then the request is synchronous.\nuser, password: login and password for basic HTTP auth (if required).\n\nPlease note that open call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of send.\n\nSend it out.\n\nxhr.send([body]);\n\nThis method opens up the connection and sends the request to server. The optional body parameter contains the request body.\n\nSome request methods like GET do not have a body. And some of them like POST use body to send the data to the server.\n\nListen to xhr events for response.\n\nThese three events are the most widely used:\n\nload: When the request is complete and the response is fully downloaded.\nerror: When the request couldn’t be made successfully, For example, network down or invalid URL.\nprogress: Triggers periodically while the response is being downloaded, reports how much has been downloaded.\nxhr.onload = function () {\n  alert(`Progress: ${xhr.status} ${xhr.response}`);\n};\n\n\nxhr.onerror = function () {\n  alert(`Network Error Occured`);\n};\n\n\nxhr.onprogress = function (event) {\n  // Triggers periodically\n  // event.loaded - how many bytes downloaded\n  // event.lengthComputable = true if the server sent Content-Length header\n  // event.total - total number of bytes (if lengthComputable)\n  alert(`Received ${event.loaded} of ${event.total}`);\n};\n\nOnce the server has successfully responded, we can receive the result in the following xhr properties:\n\nstatus\n\nHTTP status code (a number): 200, 404, 403 and so on, can be 0 in case of a non-HTTP failure.\n\nstatusText\n\nHTTP status message (a string): usually OK for 200, Not Found for 404, Forbidden for 403 and so on.\n\nresponse (old scripts may use responseText)\n\nThe server response body.\n\nWe can also specify a timeout using the corresponding property:\n\nxhr.timeout = 10000; // Timeout in ms, 10 seconds\n\nIf the request does not succeed within the given time, it gets canceled and timeout event triggers.\n\n2. Synchronous Method\n\nIf in the .open method the third parameter async is set to false, the request is made synchronously.\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.\n\nResponse Type\n\nxhr.responseType property can be used to set the response format:\n\n\"\" (default): get as string,\n\"text\": get as string,\n\"arraybuffer\": get as ArrayBuffer\n\"blob\": get as Blob,\n\"document\": get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),\n\"json\": get as JSON (parsed automatically)."},{"title":"RegExp","description":"The RegExp object is used for matching strings with Regular Expressions. A Regular Expression is a special string, called a pattern, that uses various character sequences to define the characteristics to match a character sequence within another string.\n\nA RegExp object can also have flags set along with a pattern to change how matches are performed.\n\nSyntax\n\nThere are two methods of creating a RegExp object. The first method is literal notation using slashes to delimit the pattern, followed by any flags. The second method uses the RegExp constructor which takes the pattern as the first argument and any flags as the second.\n\n// Using literal notation\nlet re1 = /foo?/i;\n\n\n// Using RegExp constructor\nlet re2 = new RegExp('foo?', 'i');\n\n\n// Both create a RegExp object with a pattern = \"foo?\" and a flag = \"i\"\n\nThere is a difference between the methods. Literal notation compiles when the expression is evaluated. It should be used when the pattern will remain constant, so it won’t be recompiled unnecessarily, such as in a loop.\n\nUsing the object constructor means the expression will be compiled at runtime. It should be used when the pattern of the RegExp object would be subject to change, or the pattern is obtained during runtime, such as from user input.\n\nRegExp Properties\nProperty\tDescription\n.flags\tReturns a string containing the flags of the RegExp object.\n.dotAll\tDoes . match newlines or not?\n.global\tDoes the RegExp object test against all matches in a string, or only the first?\n.hasIndices\tDoes the Regular Expression result expose the start and end indices of captured substrings?\n.ignoreCase\tDoes the RegExp object ignore case when performing a match?\n.multiline\tDoes the RegExp object perform matches across multiple lines?\n.source\tThe text of the pattern used by the RegExp object.\n.sticky\tIs the search sticky? (Does the next match have to occur at lastIndex, or can we match the next occurrence after lastIndex?)\n.unicode\tAre Unicode features enabled?\n.lastIndex\tThe index at which to start the next match.\nRegExp Methods\nMethod\tDescription\n.exec(str)\tExecute a search on its str string parameter.\n.test(str)\tTests for a match in its str string parameter.\nString Methods that Can Use RegExp Objects\n\nIn the following re is a RegExp object.\n\nMethod\tDescription\n.match(re)\tReturns the array result of match(es) against the string.\n.matchAll(re)\tReturns an iterator of all the matches found within the string.*\n.replace(re, substr)\tReplaces match(es) in the string with a given substring, substr.\n.search(re)\tReturns the index of the first match in the string.\n.split(re)\tSplits string into an array using the match(es) as a delimiter.\n\n* The RegExp object must have the g flag set or an exception is thrown.\n\nRegExp Flags\n\nWhen specified, these flags change the default match behavor of the RegExp object.\n\nFlag\tDescription\ng\tPerforms a global match, finding all matches rather than just the first.\ni\tMakes matches case-insensitive. Matches both uppercase and lowercase.\nm\tPerforms multiline matches. (Changes behavior of ^,$)\ns\tAllows . to match newline characters.\nu\tEnables Unicode support.\ny\tMatches are sticky, looking only at exact position in the text.\n\nUsage:\n\nlet re1 = /foo?/gim;\nlet re2 = new RegExp('foo?', 'gim');\n\n\n// Create a RegExp object that performs a global, case-insensitive, multiline search\nRegular Expressions\n\nThe following characters are used to define a Regular Expression string.\n\nAssertions\n\nThe following match the boundries between characters, not the characters themselves.\n\nCharacters\tMeaning\n^\tMatches the beginning of input. In multiline search, matches immediately after a line break character.\n$\tMatches the end of input. In multiline search matches immediately before a line break character.\n\\b\tMatches a word boundary. Point where a word character is not followed by a word character, or the point where a word character is not preceded by another word character\n\\B\tMatches a non-word boundary. Point where preceding and following character are of the same type.\n\nThe following match a character or expression based on what follows or precedes it.\n\nCharacters\tMeaning\nx(?=y)\tMatch x only if x is immediately followed by y. y is not part of the match results.\nx(?!y)\tMatch x only if x is not immediately followed by y. y is not part of the match results.\n(?<=y)x\tMatch x only if x is immediately preceded by y. y is not part of the match results.\n(?<!y)x\tMatch x only if x is not immediately preceded by y. y is not part of the match results.\nExamples\nlet str = 'Sally sells seashells by the seashore';\n\n\nlet re = /s(?=e)/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Sally xells xeashells by the xeashore\n\n\nre = /s(?!e)/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: xally sellx seaxhellx by the seaxhore\n\n\nre = /^s/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: xally sells seashells by the seashore\n\n\nre = /\\Bs/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Sally sellx seaxhellx by the seaxhore\nCharacter Classes\n\nCharacter classes specify a given type of character to match.\n\nCharacters\tMeaning\n.\tMatches any character except line terminators. When s flag set, it also matches line terminators.\n\\d\tMatches any digit (Arabic numeral).\n\\D\tMatches any character that is not a digit (Arabic numeral).\n\\w\tMatches any alphanumeric character from Latin alphabet, including underscore.\n\\W\tMatches any character that is not an alphanumeric character from Latin alphabet or underscore.\n\\s\tMatches any whitespace character (space, tab, newline, non-breaking space, and similar).\n\\S\tMatches any character that isn’t a whitespace character.\n\\t\tMatches a horizontal tab.\n\\r\tMatches a carriage return.\n\\n\tMatches a linefeed.\n\\v\tMatches a vertical tab.\n\\f\tMatches a form-feed.\n[\\b]\tMatches a backspace.\n\\0\tMatches a NUL character (when not followed by another digit).\n\\xnn\tMatches the character code nn (two hexadecimal digits).\n\\unnnn\tMatches a UTF-16 code unit with the value nnnn (four hexadecimal digits).\n\\\tFollowed by a special character, means that the character should be matched literally.\nExamples\nlet str = '2001: A Space Odyssey';\n\n\nlet re = /\\W/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: 2001xxAxSpacexOdyssey\n\n\nre = /\\d/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: xxxx: A Space Odyssey\n\n\nre = /\\d\\D/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: 200x A Space Odyssey\nGroups and Ranges\n\nIndicate groups and ranges of characters to match.\n\n| Characters | Meaning | | ———————————— | ————————————————————————————————————————————————- | ————————– | | x | y | Matches either x or y. | | [xyz] | Matches the character x, y or z. | | [a-c] | Matches the character that falls between a and c inclusive (a, b and c).* | | [^xyz] | Matches the character that is not x, y or z. | | [^a-c] | Matches the character that does not fall between a and c inclusive (not a, b or c).* | | (x) | Matches x and remembers the match, capturing the group. | | \\n | Where n is a positive integer, represents a back refrence to the last substring matching the nth captured group. | | (?<Name>x) | Matches x and stores it in the groups property of the returned matches under the name Name. | | \\k<Name> | Represents a back refrence to the last substring matched in the named capturing group specified by Name. | | (?:x) | Represents a non-capturing group. Matches x but does not remember the match. |\n\n* If the hyphen falls at the start or end of the sequence in brackets, it is treated as a literal hyphen.\n\nExamples\nlet str = 'Peter Piper picked a peck of pickled peppers.';\n\n\nlet re = /[aeiou]/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Pxtxr Pxpxr pxckxd x pxck xf pxcklxd pxppxrs.\n\n\nre = /[^p]/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: PxxxxxPxpxxxpxxxxxxxxpxxxxxxxpxxxxxxxpxppxxxx\n\n\nre = /pi(ck|pe)/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Peter xr xed a peck of xled peppers.\nQuantifiers\n\nQuantifiers specify the number of characters or expressions to match.\n\nCharacters\tMeaning\nx*\tMatches the preceding item x zero or more times.\nx+\tMatches the preceding item x one or more times.\nx?\tMatches the preceding item x zero or one times.\nx{n}\tMatches the preceding item x n times, where n is a positive integer.\nx{n,}\tMatches the preceding item x n or more times, where n is a positive integer.\nx{n,m}\tMatches the preceding item x at least n times and at most m times where n and m are positive integers and n is less than m.\n\nBy default, these quatifiers are greedy, matching as much of the string as possible. By following the quantifer with ? (x*?) the match will stop at its first occurrence.\n\nExamples\nlet str = 'Billy bought a bushel of blue baloons.';\n\n\nlet re = /b.?l+/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: xy bought a bushel of xue xoons.\n\n\nre = /[olu]{2}/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Bixy bxght a bushel of bxe baxons.\n\n\nre = /l\\w*/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Bix bought a bushex of bx bax.\n\n\nre = /o\\w+?/gi;\nconsole.log(str.replace(re, 'x'));\n// Output: Billy bxght a bushel x blue balxns."},{"title":"Sort","description":"In JavaScript, the .sort() method of an array sorts the contents of an array and returns the sorted array. This sorting is done in place and affects the original array. No copy is made. The default sort is in ascending string order.\n\nThe .sort() method allows the passing of a comparison function to change the ordering of the sort.\n\nSyntax\n// Preform the default sort\nsomearray.sort()\n\n\n// Perform the sort using an arrow function for comparisons\nsomearray.sort((A, B) => { ... } )\n\n\n// Perform the sort with an inline compare function\nsomearray.sort(function compareFn(A, B) { ... })\n\n\n// Perform the sort with a compare function\nsomearray.sort(compareFn)\ncompareFn is the optional comparison function\nA is the first array item being compared\nB is the second array item being compared\nDefault Sort Order\n\nIf no comparison function are provided, the .sort() method will sort the array in ascending string order. For items that are not strings, .sort() will convert them into strings before comparing them. This can lead to unexpected results:\n\nlet numbers = [33, 16, 156, 2, 9, 5, 10];\n\n\nnumbers.sort();\n\n\nconsole.log(numbers);\n// Output: [10, 156, 16, 2, 33, 5, 9]\nComparison Function\n\nThe comparison function, if provided, will determine the sorting of all non-undefined items in the array. All undefined items are sorted to the end of the array, and no undefined items are passed to the comparison function. The comparison function determines the sort order as follows:\n\nFor the function CompareFn(A, B):\n\nIf the function returns a value greater than zero, sort B before A.\nIf the function returns a value less than zero, sort A before B.\nIf the function returns a value of zero, the positions of A and B remain unchanged.\nThe function must return the same result for any specific pair of values A & B provided. Otherwise, the sort order is undefined.\n\nTo sort an array in numeric order rather than string order, the following function can be used as long as the array doesn’t contain Infinity or NaN:\n\nfunction compareFn(A, B) {\n  return A - B;\n}\n\nSo we can fix the prior example:\n\nlet numbers = [33, 16, 156, 2, 9, 5, 10];\n\n\nnumbers.sort(function compareFn(A, B) {\n  return A - B;\n});\n\n\nconsole.log(numbers);\n// Output: [2, 5, 9, 10, 16, 33, 156]"},{"title":"Sets","description":"A Set is an object in JavaScript that is a collection of unique values.\n\nA Set object can be created with the Set() constructor function.\n\nconst mySet = new Set();\nMain methods\nmySet.add(value): Adds a value to the set. If the value is already in the set, it doesn’t do anything.\nmySet.delete(value): Removes the given value, returns true if the value existed in the set, otherwise false.\nmySet.has(value): Returns true if the value exists in the set, otherwise false.\nmySet.clear(): Deletes everything from the set.\nmySet.size: Returns the number of elements in the set.\nAdding value to a Set\nmySet.add(1); // Set { 1 }\nmySet.add('text'); // Set { 1, 'text' }\nmySet.add(1); // Still, Set { 1, 'text' } because 1 is already in the set\nDetermining whether a value is in a set\nconsole.log(mySet.has(1)); // Output: true\nconsole.log(mySet.has('text')); // Output: true\nconsole.log(mySet.has(5)); // Output: false\nRetrieving the size of a set\nconsole.log(mySet.size); // Output: 2\n\nThere are 2 values in mySet: 1 and text\n\nRemoving values from a set\nconsole.log(mySet.delete(1)); // Output: true, Set { 'text' }\nconsole.log(mySet.delete(5)); // Output: false, Set { 'text' }\n\nThe first statement returns true because mySet contain 1 as a value and has removed it. The second statement returns false because 5 is not a value in mySet.\n\nRemoving everything from a set\nmySet.size; // 1, Set { 'text' }\nmySet.clear(); // undefined, Set { size: 0 } in chrome\nInitializing a set using iterables (e.g. arrays)\nconst newSet = new Set([2, true, 2, 'some string', { name: 'John' }]);\nconsole.log(newSet); // Set { 2, true, 'some string', { name: 'John' } }\nnewSet.size; // 4\nCodebyte Example\n\nAn interesting usage of Set is that we can use it to filter out duplicate values from an array."},{"title":"Substring","description":"The .substring() method returns part of a string. If given two arguments, they are the start and end indexes of the characters returned. If given one argument, it returns characters from that point to the end of the string.\n\nSyntax\n// Returns characters from startIndex to end of string\nstring.substring(startIndex);\n\n\n// Returns characters from startIndex to endIndex\nstring.substring(startIndex, endIndex);\nDetails\n\n.substring() returns characters at the start index up to, but not including, the character at the end index.\n\nIf the end index is omitted .substring() returns characters at the start index up through the end of the string.\n\nIf the start and end indexes are equal, .substring() returns an empty string.\n\nIndexes less than zero are interpreted as zero.\n\nIndexes that are NaN are treated as zero.\n\nIndexes that are greater than string.length are treated as string.length.\n\nIf the first argument is greater than the second argument, the first argument is treated as the end index and the second argument is treated as the start index.\n\nExample 1\n\nUsing .substring() to display characters from a given string.\n\nconst str = 'Codecademy';\n\n\nconsole.log(str.substring(0, 4));\nconsole.log(str.substring(4, 0));\nconsole.log(str.substring(-4, 4));\n// Output: \"Code\"\n\n\nconsole.log(str.substring(4));\nconsole.log(str.substring(4, 99));\n// Output: cademy\nExample 2\n\nUsing .substring() to display the last 6 characters from a given string.\n\nconst str = 'Codecademy';\n\n\nconsole.log(str.substring(str.length - 6));\n// Output: cademy"},{"title":"Strings","description":"Strings are a primitive data type. They are any grouping of characters (letters, spaces, numbers, or symbols) surrounded by single quotes ' or double quotes \".\n\nlet question = 'Wheres my bandit hat?';\nLength Property\n\nThe .length property of a string returns the number of characters that make up the string.\n\nlet message = 'good nite';\nconsole.log(message.length);\n// Output: 9\n\n\nconsole.log('howdy'.length);\n// Output: 5\nString Concatenation\n\nIn JavaScript, multiple strings can be concatenated together using the + operator.\n\nIn the example, multiple strings and variables containing string values have been concatenated. After execution of the code block, the displayText variable will contain the concatenated string.\n\nlet service = 'credit card';\nlet month = 'May 30th';\nlet displayText = 'Your ' + service + ' bill is due on ' + month + '.';\n\n\nconsole.log(displayText);\n// Output: Your credit card bill is due on May 30th.\nString Interpolation\n\nString interpolation is the process of evaluating string literals containing one or more placeholders (expressions, variables, etc).\n\nIt can be performed using template literals: text ${expression} text.\n\nlet age = 7;\n\n\n// String concatenation\n'Tommy is ' + age + ' years old.';\n\n\n// String interpolation\n`Tommy is ${age} years old.`;"},{"title":"this","description":"In JavaScript, the this keyword can have several meanings depending on the execution context. Most often it is used within a method of an object to return the instance of the object whose function is being executed, but what this returns can vary depending on the context.\n\nthis Called Within a Global Context\n\nUsed within a global context, this will return the global object. Either the window object in a web browser, or the global object on Node.js. Assigning a property to this will assign it to the global object.\n\n// Outputs assume this is run in global context in a browser\n\n\nconsole.log(this === window);\n// Output: true\n\n\nthis.prop = 'value';\n\n\nconsole.log(window.prop);\n// Output: value\nthis Called Within a Function\n\nIn JavaScript, there are several different ways to invoke a function:\n\nFunction invocation\nMethod invocation\nConstructor invocation\nIndirect invocation\nArrow functions\n\nEach has its own context, causing this to behave differently.\n\nBasic Function Invocation\n\nthis behaves differently in strict vs. non-strict mode. In non-strict mode, this returns the global object.\n\nExamples\n// Non-strict mode in browser\nfunction example() {\n  console.log(this === window);\n}\n\n\nexample();\n// Output: true\n\nIn strict mode, this is undefined.\n\n// Strict mode in browser\nfunction example() {\n  console.log(this === undefined);\n}\n\n\nexample();\n// Output: true\nMethod Invocation\n\nWithin the method of an object,this returns the object that is currently calling the function. This is the same as its behavior in other languages.\n\nExamples\nconst obj = {\n  someValue: 100,\n  someFunc: function () {\n    return this.someValue;\n  },\n};\n\n\nconsole.log(obj.someFunc());\n// Output: 100\n\n\nobj.someValue = 23;\n\n\nconsole.log(obj.someFunc());\n// Output: 23\n\nHowever, if you execute the function outside the object it will behave as function invocation above. In the example below, this refrences the global object, without a someValue property.\n\nconst obj = {\n  someValue: 100,\n  someFunc: function () {\n    return this.someValue;\n  },\n};\n\n\nlet getValue = obj.someFunc;\n\n\nconsole.log(getValue());\n// Output: undefined\n\nThere is a .bind() method that can be used to alter this behavor. .bind() can be used when creating a function to specify the object that this will refer to.\n\nconst obj = {\n  someValue: 100,\n  someFunc: function () {\n    return this.someValue;\n  },\n};\n\n\nlet getValue = obj.someFunc.bind(obj);\n// Tells getValue that its 'this' will refer to obj\n\n\nconsole.log(getValue());\n// Output: 100\nConstructor Invocation\n\nWhen you use the new keyword to create an instance of a function object, you use the function as a constructor. In this case this will refer to the new object being created.\n\nExample\nfunction Obj(value) {\n  this.someValue = value;\n}\n\n\nlet obj = new Obj(100);\n\n\nconsole.log(obj.someValue);\n// Output: 100\nIndirect Invocation\n\nThere are two methods of the Function type named .call() and .apply() which, like the .bind() method allows the this object to be set to a given object within a particular function. Unlike .bind() which returns a function, .call() and .apply() execute the function.\n\nExample\nfunction showProp(prefix) {\n  console.log(prefix + this.someProperty;\n}\n\n\nlet obj1 = {\n  someProperty:23\n};\n\n\nlet obj2 = {\n  someProperty:37\n};\n\n\nshowProp.call(obj1,\"The property is\");\n// Output: The property is 23\n\n\nshowProp.call(obj2,\"The property is\");\n// Output: The property is 37\n\n\n// The .apply() method takes an array as its second argument\n\n\nshowProp.apply(obj1,[\"The property is\"]);\n// Output: The property is 23\n\n\nshowProp.apply(obj2,[\"The property is\"]);\n// Output: The property is 37\nArrow Functions\n\nThe arrow function doesn’t have its own context for this. The this value within an arrow function is inherited from the containing function.\n\nExamples\n// Using the global context\nlet someFunction = () => this;\n\n\nconsole.log(someFunction() === window);\n// Output: true\n// Using the constructor context\nfunction Obj() {\n  let someFunction = () => this;\n  someFunction().someProperty = 25;\n}\n\n\nvar o1 = new Obj();\n\n\nconsole.log(obj.someProperty);\n// Output = 25;"},{"title":"Switch","description":"The switch statement evaluates an expression and allows different blocks of code to execute depending on the result of that expression. It contains any number of case clauses marking code to execute based on values returned by the expression, and an optional default statement marking code that executes if none of the case clauses are true.\n\nThe code following a matching case clause will execute until it encounters a break statement, a return statement, or the end of the switch block.\n\nThis means that if a break is omitted at the end of one case block, subsequent case blocks and/or the default block will be executed regardless of the value of the original expression.\n\nSyntax\nswitch (expression) {\n  case value1:\n    // Statements executed when expression = value1\n    break;\n  case value2:\n    // Statements executed when expression = value2\n    break;\n  case value3:\n    // Statements executed when expression = value3\n    break;\n  default:\n  // Statements executed when expression not equal to value1, value2 or value3\n}\n\nWith break statements omitted:\n\nswitch (expression) {\n  case value1:\n  // Statements executed when expression = value1\n  case value2:\n  // Statements executed when expression = value2 or value1\n  case value3:\n  // Statements executed when expression = value3, value2 or value1\n  default:\n  // Statements always executed\n}\nExample\n\nDetermine whether a rating is a 5, 4, 3, or something else:\n\nswitch (rating) {\n  case 5:\n    console.log('Excellent 👏');\n    break;\n  case 4:\n    console.log('Good 👍');\n    break;\n  case 3:\n    console.log('Fair 👌');\n    break;\n  default:\n    console.log('Poor 👎');\n}\nIf rating is 5, print \"Execellent 👏\".\nIf rating is 4, print \"Good 👍\".\nIf rating is 3, print \"Fair 👌\".\nElse, print \"Poor 👎\".\nCodebyte Example\n\nHere, an expression is used to find whether a number is even, odd, or not a number:"},{"title":"Variables","description":"Variables are used whenever there’s a need to store a piece of data. A variable contains data that can be used in the program elsewhere. Using variables also ensures code re-usability since it can be used to replace the same value in multiple places.\n\nconst currency = '$';\nlet userIncome = 85000;\n\n\nconsole.log(currency + userIncome + ' is more than the average income.');\n// Output: $85000 is more than the average income.\nDeclaring a Variable\n\nTo declare a variable in JavaScript, any of these three keywords can be used along with a variable name:\n\nvar is used in pre-ES6 versions of JavaScript. It is function scoped.\nlet is the preferred way to declare a variable when it can be reassigned. It is block scoped.\nconst is the preferred way to declare a variable with a constant value. It is also block scoped.\nvar age;\nlet weight;\nconst numberOfFingers = 20;"},{"title":"Try/Catch","description":"The try...catch...finally statement defines one block of code to execute, a second block of code to be executed if the first block throws an exception, and a third block of code to be executed regardless of the error status.\n\nThe catch and finally blocks of code are optional, but any try blocks must be followed by one or the other.\n\nSyntax\ntry {\n  // Statements here are executed until an exception is thrown\n} catch (err) {\n  // Statements here are executed once an exception is thrown in the try block\n} finally {\n  // Statements here are always executed regardless of any exception\n}\nThe Error Object\n\nIn the above, err is an optional variable that holds an error object for the associated catch block. This object contains information about the exception that was thrown, and is only available in the scope of the catch block.\n\nThe error object has two properties:\n\nname: Sets or returns an error name. (Type of error)\nmessage: Sets or returns an error message. (Description of specific instance)\n\nThe following types of error can be returned by the name property:\n\nRangeError: A number “out of range” has occurred\nReferenceError: An illegal reference has occurred\nSyntaxError: A syntax error has occurred\nTypeError: A type error has occurred\nURIError: An error in encodeURI() has occurred\nThe throw Statement\n\nExceptions can be thrown intentionally by the throw statement. This can be a custom exception consisting of a String, Number, Boolean or Object which will be caught by the next outer catch block.\n\nThis can be useful for things like validating input:\n\nvar input = 25;\n\n\ntry {\n  if (input < 10) {\n    throw 'too small!';\n  } else if (input > 20) {\n    throw 'too big!';\n  } else {\n    console.log('Input was ' + input);\n  }\n} catch (e) {\n  console.log('Input was ' + e);\n}\n\n\n// Output: Input was too big!\n\nThe throw statement can also re-throw an error object caught by a catch block. This can be useful if only certain types of error should be handled:\n\ntry {\n  // Series of statements\n} catch (e) {\n  if (e instanceof RangeError) {\n    // Here any instance of a RangeError exception is handled\n  } else {\n    // We re-throw any other exceptions\n    throw e;\n  }\n}"}],"Markdown":[{"title":"Blockquotes","description":"Blockquotes indicate that the enclosed text is an extended quotation. They can also be used to bring attention to a thought-provoking quote. Any quotation that is 50 words or longer should be formatted as a blockquote.\n\nTo create a blockquote, add a right angle bracket > in front of a paragraph.\n\n> Context and memory play powerful roles in all the truly great meals in one's life.\n\nThe output would be:\n\nContext and memory play powerful roles in all the truly great meals in one’s life.\n\nMultiple Paragraphs\n\nBlockquotes can contain multiple paragraphs by having a chevron > on the blank lines between them:\n\n> The first rule about fight club is you don’t talk about fight club.\n>\n> The second rule about fight club is you don’t talk about fight club.\n\nThe output would be:\n\nThe first rule about fight club is you don’t talk about fight club.\n\nThe second rule about fight club is you don’t talk about fight club.\n\nNested Blockquotes\n\nBlockquotes can also be nested by adding two chevrons >> in front of it:\n\n> Dorothy followed her through many of the beautiful rooms in her castle.\n>\n> > The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\nBlockquotes with Other Elements\n\nBlockquotes can contain other Markdown formatted elements, though, not all elements can be used — you’ll need to experiment to see which ones work with your .md processor.\n\n> ### The quarterly results look great\n>\n> - Sales were off the chart!\n> - Morale is strong!\n> - Poised to go public next spring!\n>\n> > _Everything_ is going according to **the plan**.\n\nThe output would be:\n\nThe quarterly results look great\nSales were off the chart!\nMorale is strong!\nPoised to go public next spring!\n\nEverything is going according to the plan."},{"title":"Emphasis","description":"Emphasis can be added by making text bold or italic.\n\nBold\n\nTo bold text, add two asterisks ** or underscores __ before and after a word or phrase. To bold the middle of a word for emphasis, add two asterisks without spaces around the letters.\n\n**bold text**\n\nFor example:\n\nPlease do **NOT** touch your pimples.\n\nThe output would be:\n\nPlease do NOT touch your pimples.\n\nItalic\n\nText can be italicized by surrounding with either one asterisk * or one underscore _ on each side. Parts of a word can even be italicized by surrounding the letters with one asterisk, no spaces.\n\n_Italic text_ is *awe*some!\n\nFor example:\n\nThis avocado egg sandwich is _very_ good.\n\nThe output would be:\n\nThis avocado egg sandwich is very good.\n\nStrikethrough\n\nA strikethrough can be applied to text by surrounding with two tildes ~~, like in the example below:\n\nI did ~~not~~ build a website.\n\nThe output would be:\n\nI did not build a website.\n\nEmphasis Combinations\n\nDifferent formatting options can be combined:\n\n**This is in bold, _italics_, ~~and strikethrough~~**\n\nThis is in bold, italics, and strikethrough"},{"title":"Headings","description":"Headings are titles or subtitles that can be used with Markdown. There is a total of 6 different heading options.\n\nTo create a heading, add pound symbols # to the front of a word or phrase.\n\nThe number of number signs used should correspond to the heading level. For example, to create a heading level three <h3>, use three number signs (e.g., ### My Header).\n\nSyntax\n# Heading level 1\n\n\n## Heading level 2\n\n\n### Heading level 3\n\n\n#### Heading level 4\n\n\n##### Heading level 5\n\n\n###### Heading level 6\n\nAlternate Syntax\n\nAlternatively, on the line below the text:\n\nAdd any number of == characters for heading level 1\nAdd any number or -- characters for heading level 2.\n# Heading level 1\n\n\n## Heading level 2\nBest Practices\n\nMarkdown applications don’t agree on how to handle a missing space between the number signs (#) and the heading name.\n\nFor compatibility, always put a space between the number signs and the heading name.\n\n✅ Do: # Breaking News\n\n🚫 Don’t: #Breaking News\n\nHeadings should have a blank line above and below for compatibility and readability:\n\n... text ends here.\n\n\n# Heading\n\n\nMore text starts here.\nExample\n# Headings\n\n\nThis page is about headings.\n\n\n## The cool things about headings\n\n\nHeadings are a great way to format the page.\n\n\n## Example\n\n\nHere's an example of headings."},{"title":"Images","description":"Embedding an image is very similar to adding a link in Markdown:\n\n![Alt text](URL or file path)\nAdd an exclamation mark !\nFollowed by the alt text in square brackets [Alt text]\nAnd the path or URL to the image asset in parentheses ( ).\n\nFor example:\n\n![Sonny and Mariel high fiving.](https://content.codecademy.com/courses/learn-cpp/community-challenge/highfive.gif)\n\nThe output would be:\n\nAn optional title can also be added after the URL, still in the parentheses:\n\n![Sonny and Mariel high fiving.](https://content.codecademy.com/courses/learn-cpp/community-challenge/highfive.gif 'High Five')\nLinked Images\n\nTo add a link to an image, enclose the Markdown for the image in brackets, and then add the link in parentheses.\n\n[![A mushroom-head robot](/assets/images/codey.jpg 'Codey the Codecademy mascot')](https://codecademy.com)"},{"title":"Links","description":"In Markdown, a link is created by enclosing the link text in square brackets [Link text] and then following it immediately with the URL in parentheses (https://website-name.com).\n\n[Link text](https://website-name.com)\n\nFor example:\n\nWe just launched [Codecademy Docs](https://producthunt.com) on Product Hunt!\n\nThe output would look like:\n\nWe just launched Codecademy Docs on Product Hunt!\n\nAccessibility: Link Titles\n\nA title for a link can be optionally added. This will appear as a tooltip when the user hovers over the link. To add a title, enclose it in parentheses () after the URL.\n\nLinks should have link titles so that screenreaders can narrate them as well as a user can Tab through the page.\n\n[Link text](https://website-name.com 'Link title')\n\nFor example:\n\nMy favorite Craigslist category is [Missed Connections](https://newyork.craigslist.org/d/missed-connections/search/mis 'The best place on the internet').\n\nThe output would look like:\n\nMy favorite Craigslist category is Missed Connections.\n\nURLs and Email Addresses\n\nTo quickly turn a URL or email address into a link, enclose it in angle brackets < >.\n\n<https://www.codecademy.com/resources/docs>\n<hotmale@hotmail.com>\n\nThe rendered output looks like this:\n\nhttps://www.codecademy.com/resources/docs\nhotmale@hotmail.com"},{"title":"Lists","description":"In Markdown, items can be organized into ordered and unordered lists.\n\nOrdered Lists\n\nTo create an ordered list, add numbers followed by periods.\n\n1. 🌡 Preheat oven to 325°F\n2. 🍪 Drop cookie dough\n3. ⏰ Bake for 15 min\n\nThe numbers don’t have to be in numerical order, but the list should start with the number one.\n\nIt will look like:\n\n🌡 Preheat oven to 325°F\n🍪 Drop cookie dough\n⏰ Bake for 15 min\nUnordered Lists\n\nTo create an unordered list, add dashes -, asterisks *, or plus signs + in front of line items.\n\n- 🎸 Play more music\n- 📚 Read more books\n- 👩 Code more stuff\n\nIt will look like:\n\n🎸 Play more music\n📚 Read more books\n👩 Code more stuff\n\nIndent one or more items to create a nested list.\n\n- First item\n- Second item\n- Third item\n  - Indented item\n  - Indented item\n- Fourth item"},{"title":"Tables","description":"A table is an arrangement of data in rows and columns.\n\nTo add a table in Markdown, use the vertical line | to separate each column, and use three or more dahses --- to create each column’s header. A vertical line should also be added at either end of the row.\n\n| Month    | Savings |\n| -------- | ------- |\n| January  | $250    |\n| February | $80     |\n| March    | $420    |\n\nThe output would look like:\n\nMonth\tSavings\nJanuary\t$250\nFebruary\t$80\nMarch\t$420\n\nCell widths can vary, as shown below:\n\n| Month | Savings |\n| -------- | ------- |\n| January | $250 |\n| February | $80 |\n| March | $420 |\n\nThe output will look exactly the same.\n\nText Alignment\n\nAlign text in the columns to the left, right, or center by adding a colon : to the left, right, or on both side of the dashes --- within the header row.\n\n| Item              | In Stock | Price |\n| :---------------- | :------: | ----: |\n| Python Hat        |   True   | 23.99 |\n| SQL Hat           |   True   | 23.99 |\n| Codecademy Tee    |  False   | 19.99 |\n| Codecademy Hoodie |  False   | 42.99 |\n:-- means the column is left aligned.\n--: means the column is right aligned.\n:-: means the column is center aligned.\nText Formatting\n\nText can be formatted within tables. For example, links, emphasis, and inline code (words or phrases in backticks only, not code blocks) are all readily available for use within a table.\n\nSeveral formatting options are not available within tables, including:\n\nHeadings\nBlockquotes\nHorizontal rules\nImages\nLists\nHTML tags\nEscaping Characters\n\nPipe characters “|” can be displayed in a table with the HTML character code &#124;."},{"title":"Paragraphs","description":"A paragraph is a block of text with one or more blank lines between them.\n\nSyntax\nLolita, light of my life, fire of my loins. My sin, my soul. Lo-lee-ta: the tip of the tongue taking a trip of three steps down the palate to tap, at three, on the teeth.\n\n\nLo. Lee. Ta.\n\nThis would output:\n\nLolita, light of my life, fire of my loins. My sin, my soul. Lo-lee-ta: the tip of the tongue taking a trip of three steps down the palate to tap, at three, on the teeth.\n\nLo. Lee. Ta.\n\nLine Breaks\n\nLine breaks in pargraphs can be created with double newlines or using a \\ symbol.\n\nSuccess seems to be connected with action. Successful people keep moving.\n\n\nThey make mistakes, but they don’t quit.\nThis is a\\\nline break\nBest Practices\n\nMake sure to not add tabs or spaces in front of the paragraph text, because they will create unwanted indentation."}],"PHP":[{"title":"Classes","description":"A class is a definition of the properties and methods of a particular type of object. When a class is used to define a new object, the resultant object is referred to as an instance of that class.\n\nIn a PHP class definition, properties are variables, methods are functions.\n\nSyntax\n<?php\nclass Car {\n  // Properties\n  public $make;\n  public $model;\n  public $year;\n\n\n  // Methods\n  function set_year($year) {\n    $this->year = $year;\n  }\n  function get_year() {\n    return $this->year;\n  }\n}\n?>\n\nThis defines the class Car which has the properties make, model and year, and the methods set_year() and get_year().\n\nThe $this Keyword\n\nInside methods of a class, the $this keyword can be used to return a reference to the object instance that’s executing the method. An example of this is shown above. When the method refers to $this->year, it is referring to the year property of the particular object instance that is executing the method.\n\nThe new Keyword\n\nAn object is created from a class definition by using the new keyword.\n\nExample\n<?php\n  class Car {\n    // Properties\n    public $make;\n    public $model;\n    public $year;\n\n\n    // Methods\n    function set_year($year) {\n      $this->year = $year;\n    }\n    function get_year() {\n      return $this->year;\n    }\n  }\n\n\n  // Create object instances\n  $honda = new Car();\n  $ford = new Car();\n\n\n  // Use class properties\n  $honda->make = 'Honda';\n  $honda->model = 'Accord';\n  $ford->make = 'Ford';\n  $ford->model = 'Explorer';\n\n\n  // Use class methods\n  $honda->set_year(2019);\n  $ford->set_year(2020);\n\n\n  echo $honda->get_year() . ' ' . $honda->make . ' ' . $honda->model . '<br/>';\n  // Output: 2019 Honda Accord\n\n\n  echo $ford->get_year() . ' ' . $ford->make . ' ' . $ford->model . '<br/>';\n  // Output: 2020 Ford Explorer\n\n\n?>\nThe instanceof Operator\n\nThe instanceof operator returns true when the operand on the left belongs to the class in the right operand.\n\nExample\n<?php\n  $ford = new Car;\n  if ($ford instanceof Car) {\n    echo 'It is a Car!'; } else {\n    echo 'It is not a Car!'; }\n  // Output: It is a Car!\n?>"},{"title":"Arrays","description":"An array is a variable that can hold more than one value. Arrays in PHP are stored as value pairs that in other languages would be called a dictionary or a hashtable. Keys can be strings or integers.\n\nSyntax\n\nThere are several methods of declaring an array in PHP. The array() function can be used, either with key-value pairs, or with values alone. Single brackets, [...] can also be used in place of the array() keyword. If any key value is omitted, the key will be found by incrementing the largest prior integer key. If a key is repeated, the new value will overwrite the prior key.\n\n<?php\n// The last comma can be omitted\n$array1 = array( \"item 1\" => \"one\", \"item 2\" => \"two\", \"item 3\" => \"three\", );\n\n\necho $array1[\"item 1\"], \";\", $array1[\"item 2\"], \";\", $array1[\"item 3\"];\n// Output: one;two;three\n\n\n$array2 = array(\"one\", \"two\", \"three\");\n\n\necho $array2[0], \";\", $array2[1], \";\", $array2[2];\n// Output: one;two;three\n\n\n$array3 = [\"one\", 5 => \"two\", \"three\"];\n\n\necho $array3[0], \";\", $array3[5], \";\", $array3[6];\n// Output: one;two;three\n\n\n$array4 = [5 => \"one\", 5.7 => \"two\", \"5\" => \"three\"];\n\n\necho $array4[5];\n// Output: three\n?>\n\nAdditionally, when defining an array, the following key casts will occur:\n\nStrings containing valid int types, unless preceded by a + sign, will be cast to an int type key. As in the above example \"5\" is treated as 5.\nfloat types will be cast to int types, truncating the fractional part. As in the above example 5.7 is treated as 5.\nbool types are cast to int types. true is stored as 1 and false stored as 0.\nnull will be cast as the empty string, \"\".\nArrays and objects cannot be used as keys and will result in an error: Illegal offset type."},{"title":"Conditionals","description":"if Statement\n\nAn if statement takes an expression as an argument:\n\nIf the expression evaluates to true its associated code block executes.\nIf the expression evaluates to false its associated code block is skipped.\n<?php\n  $x = 10;\n\n\n  if ($x > 20) {\n    echo x$ . \"is too much\";\n  }\n\n\n  if ($x <= 20) {\n    echo x$ . \"is within limits.\";\n  }\n\n\n  // Output: 10 is within limits.\n?>\n\nThe braces {...} are optional when the associated code blocks are only a single line. The above code can be rewritten:\n\n<?php\n  $x = 10;\n\n\n  if ($x > 20)\n    echo x$ . \"is too much.\";\n\n\n  if ($x <= 20)\n    echo x$ . \"is within limits.\";\n\n\n  // Output: 10 is within limits.\n?>\nelse Statement\n\nAn else statement can immediately follow the if block. The code block following the else only executes if the if‘s expression evaluates to false. The above code can be rewritten:\n\n<?php\n  $x = 10;\n\n\n  if ($x > 20) {\n    echo x$ . \"is too much.\";\n  } else {\n    echo x$ . \"is within limits.\";\n  }\n  // Output: 10 is within limits.\n?>\nelseif Statement\n\nBetween an if block and an else block, any number of elseif statements and associated code blocks can occur. Each elseif has its own expression to evaluate. The code block associated with the first if or elseif to have a true expression will be the code block to execute. Subsequent elseif blocks will not execute, even if their own expressions are true. The else block will only execute if all if and elseif expressions evaluate false.\n\n<?php\n  $x = -10;\n\n\n  if ($x > 20) {\n    echo $x . \"is too much.\";\n  }\n  elseif ($x < 0) {\n    echo \"Negative numbers are illegal!\";\n  }\n  elseif ($x < 5) {\n    echo $x . \" is too little.\";\n  }\n  else\n  {\n    echo x$ . \"is within limits.\";\n  }\n  // Output: Negative numbers are illegal!\n?>\n\nNote in the above, if the elseif clauses were swapped, then the block where $x < 0 would never execute.\n\nThe Ternary Operator\n\nThere is a compact version of an if expression called the ternary operator which has the following syntax:\n\nexpression ? true value : false value\n\nAn example:\n\n<?php\n  $x = 10;\n\n\n  echo ($x > 20) ? $x . \" is too much.\" : $x . \" is within limits.\";\n\n\n  // Output: 10 is within limits.\n?>"},{"title":"Comments","description":"Comments are text placed inside code that is not executed. They are intended as documentation or explanation of the code they are a part of.\n\nSyntax\n\nPHP marks comments in three different ways:\n\n// will mark a comment from where it appears until the end of the line (or code block).\n# will also mark a comment from where it appears until the end of the line (or code block).\nMulti-line comments are marked by /* … */ with everything in between marked as a comment.\n\nSingle line comments extend to the end of the line, or the end of the PHP block. ?> will not be commented out, instead, ?> will terminate the comment.\n\n<?php\n  echo 'Testing 1, 2, 3...' // This is a single line comment\n\n\n  /* This\n     is\n     a multi-line comment */\n\n\n  echo 'Hello World!' # This is another single-line comment\n\n\n// This comment ends with the enclosing block ?>\n\nNote that attempting to nest multi-line comments will result in an error. The first comment ends when the first */ is encountered, leaving the remaining comment(s) to be executed.\n\n<?php\n  /* This is one multi-line comment\n    /* But this inner comment will cause problems */\n       This part of the comment will be executed\n       since the end of the inner comment ended the outer\n       comment as well. */\n?>"},{"title":"Functions","description":"Functions are blocks of code that can be repeatedly called by other code when it executes. A function is not called when it is defined, but only when another part of the code executes the function.\n\nSyntax\n\nThe syntax for a user defined function in PHP is similar to other languages:\n\nfunction functionName(parameters) {\n  code to execute;\n}\nfunctionName: The name of the function. It must start with an alphabetic character or an underscore, and must consist only of alphanumeric characters or underscores.\nparameters: Zero or more comma-separated variables that will be passed on to the code block when the function is called.\ncode to execute: The code that executes when the function is called.\nExample\n\nThe following function takes a numeric argument and returns a string saying if it is even or odd:\n\n<?php\n\n\n  function oddOrEven($x) {\n    if ($x % 2 == 1) {\n      return 'Odd';\n      } else {\n      return 'Even';\n      }\n    }\n\n\n    echo oddOrEven(15) . '<br />';\n    // Output: Odd\n\n\n    echo oddOrEven(20) . '<br />';\n    // Output: Even\n?>\nThe return Keyword\n\nThe return keyword in a function ends execution of the function and returns an optional value. If the value is omitted, the function returns a null value.\n\n<?php\n  function example() {\n    $x = 1;\n    $x++;\n    return $x; // Execution stops and $x is returned to the caller\n    $x = 15; // This is never executed\n  }\n\n\n  echo example();\n  // Output: 2;\n?>\nPassing Parameters by Reference\n\nParameters are usually passed to PHP functions “by value.” This means that when a variable is passed to the function, its value is copied and any change of the parameter variable does not affect the original variable. When a parameter is passed “by reference”, changes to the variable inside the function will affect the variable being passed to the function. A parameter is passed by reference when it is preceded by & in the function definition.\n\n<?php\n  function changeMe(&$x) {\n    $x++;\n    }\n\n\n  $y = 10;\n  changeMe($y);\n  echo $y;\n  // Output: 11;\n?>\nDefault Parameter Value\n\nPHP functions can be defined with default values for parameters that are omitted when the function is called. The syntax looks like this:\n\n<?php\n  function default10($x = 10) {\n    return $x;\n    }\n\n\n   echo default10(5) . '<br />';\n   // Output: 5\n   echo default10(125) . '<br />';\n   // Output: 125\n   echo default10() . '<br />';\n   // Output: 10\n?>\nType Declarations\n\nPHP is a loosely-typed language. That means that data types are not required when assigning values to variables and function parameters. PHP will manage type conversion by itself is situations such as trying to add an integer to a string. In PHP 7 it introduced type declarations so a function definition can define what data types it expects for parameters.\n\n<?php\n  function specifyTypes(int $x, int $y) {\n    echo $x . \"*\" . $y . \"=\" . ($x * $y) . '<br />';\n    }\n\n\n  specifyTypes(2, 3);\n  specifyTypes(2, 3.5);\n  specifyTypes(2, \"3.8\");\n  specifyTypes(2, \"3 apples\");\n  // All Output: 2*3=6\n?>\n\nPHP can also use strict mode, where if a function is passed a data type it isn’t explicitly expecting, an error will be thrown. strict is enabled when the statement declare(strict_types=1); is the first line of the PHP file. (It must be the first line, before any other PHP or HTML code.)\n\n<?php declare(strict_types=1);\n  function specifyTypes(int $x, int $y) {\n    echo $x . \"*\" . $y . \"=\" . ($x * $y) . '<br />';\n  }\n\n\n  specifyTypes(2,3); // Outputs 2*3=6\n  specifyTypes(2,3.5); // Throws error\n  specifyTypes(2,\"3.8\"); // Throws error\n  specifyTypes(2,\"3 apples\"); // Throws error\n\n\n?>\n\nIn PHP 7, the function definition can also declare the data type it expects for its return value. In strict mode an error will be thrown if there’s a type mismatch.\n\n<?php declare(strict_types=1);\n  function throwsError(float $x, float $y) : int {\n    return $x + $y;\n  }\n\n\n  function typeSafe(float $x, float $y) : int {\n    return (int)($x + $y);\n  }\n?>"},{"title":"Data Types","description":"PHP supports the following primitive data types:\n\nbool: a value that’s either true or false.\nint: a whole number value.\nfloat: a numeric value with decimal.\nstring: a series of characters.\narray: an ordered map of key/value pairs.\nobject: an instance of a pre-defined class.\ncallable: a reference to a PHP function.\niterable: represents any array or object implementing the Traversable interface.\nresource: a reference to an external resource.\nNULL: represents a variable with no value.\n\nRather than being declared in code, the data type is decided at runtime depending on the context. There are many ways to determine the type of a variable or expression.\n\nPrinting the Type and Value\n\nThe var_dump() function prints out the type and value of an expression.\n\nExample\n$text = \"PHP\";\nvar_dump($text);\n\nThe output looks like this:\n\nstring(3) \"PHP\"\nThe gettype() Function\n\nThe gettype() function returns a human readable string representing the data type of an expression.\n\nExample\n$text = \"PHP\";\necho(gettype($text));\n\nResults in the output:\n\nstring\nChecking Types\n\nPHP has a number of “is_type” functions to check the type of a variable.\n\nis_bool($value) returns true if $value is a bool value.\nis_int($value) returns true if $value is an int value. (Also is_integer().)\nis_float($value) returns true if $value is a float value.\nis_string($value) returns true if $value is a string.\nis_array($value) returns true if $value is an array value.\nis_object($value) rerurns true if $value is an object value.\nis_iterable($value) returns true if $value is an iterable value.\nis_resource($value) returns true if $value is a resource value.\nis_null($value) returns true if $value is a NULL value.\n\nThe is_callable() function has a slightly more complicated syntax:\n\nis_callable($value, $syntax_only, $callable_name)\n\nWhere $value is the value being checked. The $syntax_only parameter is an optional boolean flag that if set true will only check if $value is properly structured to be used as a callback. The $callable_name parameter is optional, and if included, will be set to the name of the callable function or method referred to by $value. The function will return true if $value is a callable value.\n\nCodebyte Example"},{"title":"Loops","description":"A loop allows a block of code to repeat some number of times. Depending on the type of loop, it can repeat a set number of times, until a particular condition is no longer met, or once for each member of an array. The process of repeating the code block is called iteration.\n\nfor Loop\n\nA for loop is used in PHP when it is known how many times its bock of code should execute. The syntax looks like this:\n\nfor (init; test; increment) {\n  code to execute;\n}\ninit: Initialize a counter variable.\ntest: Tests the counter variable. The loop continues to iterate as long as this test evaluates to true.\nincrement: Increment/decrements the counter variable. Executed on each loop iteration.\ncode to execute: Block of code to execute on each iteration. The counter variable is available inside this block.\n\nThe order these pieces are executed are: init, test, execute, increment, then back to test.\n\nNote that it’s possible to write a for loop that never executes if the initial test fails.\n\nExample\n<?php\nfor ($i = 1;$i <= 10; $i++) {\n    echo 'iteration #' . $i . '<br/>';\n    }\n?>\n\nOutput:\n\niteration #1\niteration #2\niteration #3\niteration #4\niteration #5\niteration #6\niteration #7\niteration #8\niteration #9\niteration #10\nforeach Loop\n\nA foreach loop iterates through a block of code once for each element of an array. The syntax is as follows:\n\nIterate through array values:\n\nforeach ($array as $value) {\n  code to execute;\n}\n$array: An array variable.\n$value: Variable to receive each value of array in turn.\nexecute: Block of code to execute on each iteration. The $value variable is available inside this block.\n\nIterate through array keys and values:\n\nforeach ($array as $key => $value) {\n  code to execute;\n}\n$array: An array variable.\n$key: Variable to receive each key of array in turn.\n$value: Variable to receive each value of array in turn.\ncode to execute: Block of code to execute on each iteration. The $key and $value variables are available inside this block.\nExamples\n\nValues only:\n\n<?php\n$a = ['one','two','three','four'];\n\n\nforeach ($a as $x) {\n  echo 'The value is ' . $x . '<br />';\n  }\n?>\n\nOutput:\n\nThe value is one\nThe value is two\nThe value is three\nThe value is four\n\nValues and keys:\n\n<?php\n$a = ['one' => 'green','two' => 'blue','three' => 'red','four' => 'yellow'];\n\n\nforeach ($a as $k => $x) {\n  echo 'The value for ' . $k . ' is ' . $x . '<br />';\n  }\n?>\n\nOutput:\n\nThe value for one is green\nThe value for two is blue\nThe value for three is red\nThe value for four is yellow\nwhile Loop\n\nThe while loop iterates through a block of code as long as a condition evaluates to true. The syntax looks like this:\n\nwhile (test) {\n  code to execute;\n}\ntest: The expression to evaluate on each iteration of loop. Iterations continue until this evaluates to false.\ncode to execute: Block of code to execute on each iteration.\nExample\n<?php\n$x = 0;\n$i = 2;\n\n\nwhile ($x <= 100) {\n    echo 'the number is ' . $x . '<br/>';\n    $x += $i;\n    $i *= 2;\n    }\n?>\n\nOutput:\n\nthe number is 0\nthe number is 2\nthe number is 6\nthe number is 14\nthe number is 30\nthe number is 62\ndo...while Loop\n\nThe do...while loop, like a while loop, iterates as long as a condition is true. But the do...while loop tests the condition after the iteration, not before, so the loop always executes at least once.\n\nThe syntax looks like this:\n\ndo {\n  execute;\n  } while (test);\ntest: The expression to evaluate on each iteration of loop. Iterations continue until this evaluates to false.\nexecute: Block of code to execute on each iteration.\nExample\n<?php\n$x = 125;\n\n\ndo {\n    echo 'the number is ' . $x . '<br/>';\n    $x++;\n    } while ($x <= 100);\n?>\n\nOutput:\n\nthe number is 125\nbreak Statement\n\nThe break statement can be used to prematurely jump out of a loop during execution.\n\nExample\n<?php\n$x = 0;\n$i = 2;\n\n\nwhile ($x <= 100) {\n    echo 'the number is ' . $x . '<br/>';\n    if ($x == 14) { break; }\n    $x += $i;\n    $i *= 2;\n    }\n?>\n\nOutput:\n\nthe number is 0\nthe number is 2\nthe number is 6\nthe number is 14\ncontinue Statement\n\nThe continue statement breaks out of the current loop and immediately starts the next iteration.\n\nExample\n<?php\nfor ($i = 1;$i <= 10; $i++) {\n    if ($i % 2 == 1) {continue; }\n    echo 'iteration #' . $i . '<br/>';\n    }\n?>\n\nOutput:\n\niteration #2\niteration #4\niteration #6\niteration #8\niteration #10"},{"title":"Operators","description":"Operators are used to perform operations on variables and values.\n\nArithmetic Operators\n\nPHP has the following basic arithmetic operators to perform common mathematical operations:\n\nOperator\tName\tDescription\n+\tAddition\t$x + $y returns the sum of $x and $y\n-\tSubtraction\t$x - $y returns the difference of $x and $y\n*\tMultiplication\t$x * $y returns the product of $x and $y\n/\tDivision\t$x / $y returns the quotient of $x and $y\n%\tModulo\t$x % $y returns the integer remainder of $x divided by $y\n**\tExponentiation\t$x ** $y returns $x raised to the power $y\n\nThe division operator returns a float unless its operands are integers and the result is a whole number, in which case it returns an integer.\n\nOperands of modulo are converted to integers before calculating. The modulo result will have the same sign as the dividend.\n\n<?php\n  $x = 0;\n  $x = $x + 4; // $x is now 4\n  $x = $x - 1; // $x is now 3\n  $x = $x * 8; // $x is now 24\n  $x = $x / 4; // $x is now 6\n  $x = $x % 4; // $x is now 2\n  $x = $x ** 3; // $x is now 8\n?>\nAssignment Operators\n\nThe basic assignment operator is =, which takes the right-hand operand and assigns it to the variable that is the left-hand operand. PHP also has a number of additional assignment operators that are shortcuts for longer expressions.\n\nArithmetic Assignment Operators\n\nThere is an assignment operator for each arithmetic operator above.\n\nOperator\tName\tDescription\n+=\tAddition Assignment\t$a += 3 is short for $a = $a + 3\n-=\tSubtraction Assignment\t$a -= 3 is short for $a = $a - 3\n*=\tMultiplication Assignment\t$a *= 3 is short for $a = $a * 3\n/=\tDivision Assignment\t$a /= 3 is short for $a = $a / 3\n%=\tModulo Assignment\t$a %= 3 is short for $a = $a % 3\n**=\tExponentation Assignment\t$a **= 3 is short for $a = $a ** 3\n<?php\n  $x = 0;\n  $x += 4; // $x is now 4\n  $x -= 1; // $x is now 3\n  $x *= 8; // $x is now 24\n  $x /= 4; // $x is now 6\n  $x %= 4; // $x is now 2\n  $x **= 3; // $x is now 8\n?>\nBitwise Assignment Operators\n\nThere is an assignment operator for each bitwise operator (see below).\n\nOperator\tName\tDescription\n&=\tAnd Assignment\t$a &= 3 is short for $a = $a & 3\n|=\tOr Assignment\t$a |= 3 is short for $a = $a | 3\n^=\tXor Assignment\t$a ^= 3 is short for $a = $a ^ 3\n<<=\tLeft Shift Assignment\t$a <<= 3 is short for $a = $a << 3\n>>=\tRight Shift Assignment\t$a >>= 3 is short for $a = $a >> 3\n<?php\n  $x = 19;\n  $x &= 7;\n  // $x is 3 : 10011 & 00111 = 00011\n\n\n  $x = 19;\n  $x |= 7;\n  // $x is 23 : 10011 | 00111 = 10111\n\n\n  $x = 19;\n  $x ^= 7;\n  // $x is 20 : 10011 ^ 00111 = 10100\n\n\n  $x = 7;\n  $x <<= 2;\n  // $x is 28 : 00111 << 2 = 11100\n\n\n  $x = 19;\n  $x >>= 2;\n  // $x is 4 : 10011 >> 2 = 00100\n?>\nBitwise Operators\n\nThe bitwise operators manipulate individual bits in an integer.\n\nOperator\tName\tDescription\n&\tAnd\tresult has bit set only where both operands have that bit set.\n|\tOr\tresult has bit set if either operand has that bit set.\n^\tXor\tresult has bit set only if only one operand has that bit set.\n~\tNot\ttakes a single operand and inverts each bit in it.\n<<\tLeft shift\t$a << $b means $a‘s bits are shifted to the left $b spaces. $b zeros are inserted from the right, and the leftmost $b bits are discarded.\n>>\tRight shift\t$a >> $b means $a‘s bits are shifted to the right $b spaces. $b copies of the leftmost bit are inserted from the left, and the rightmost $b bits are discarded.\n<?php\n  $x = 19 & 7;\n  // $x is 3 : 10011 & 00111 = 00011\n\n\n  $x = 19 | 7;\n  // $x is 23 : 10011 | 00111 = 10111\n\n\n  $x = 19 ^ 7;\n  // $x is 20 : 10011 ^ 00111 = 10100\n\n\n  $x = 7 << 2;\n  // $x is 28 : 00111 << 2 = 11100\n\n\n  $x = 19 >> 2;\n  // $x is 4 : 10011 >> 2 = 00100\n?>\nComparison Operators\nOperator\tName\tDescription\n==\tEqual\t$x == $y is true if $x and $y are equal after type juggling.\n===\tIdentical\t$x === $y is true if $x and $y are equal and the same type.\n!=\tNot Equal\t$x != $y is true if $x and $y are not equal after type juggling.\n<>\tNot Equal\t$x <> $y is true if $x and $y are not equal after type juggling.\n!==\tNot Identical\t$x !== $y is true if $x and $y are not equal or not the same type.\n<\tLess Than\t$x < $y is true if $x is less than $y.\n>\tGreater Than\t$x > $y is true if $x is greater than $y.\n<=\tLess Than or Equal to\t$x <= $y is true if $x is less than or equal to $y.\n>=\tGreater Than or Equal to\t$x >= $y is true if $x is greater than or equal to $y.\n<=>\tSpaceship\t$x <=> $y returns an integer greater than, less than or equal to zero when $x is greater than, less than, or equal to $y respectivly.\n<?php\n  $x = 5;\n  $y = '5';\n\n\n  if ($x == $y):\n    echo \"equal\";\n  else:\n    echo \"not equal\";\n  endif;\n  // Output: equal\n\n\n  echo \"<br/>\";\n\n\n  if ($x === $y):\n    echo \"identical\";\n  else:\n    echo \"not identical\";\n  endif;\n  // Output: not identical\n\n\n  echo \"<br/>\";\n\n\n  $y = 12;\n\n\n  if ($x > $y):\n    echo $x . \" is greater than \" . $y;\n  else:\n    echo $x . \" is not greater than \" . $y;\n  endif;\n  // Output: 5 is not greater than 12\n\n\n?>\nIncrementing/Decrementing Operators\nOperator\tName\tDescription\n++$x\tPreincrement\tIncrements $x by one then returns $x.\n$x++\tPostincrement\tReturns $x, then increments $x by one.\n--$x\tPredecrement\tDecrements $x by one, then returns $x.\n$x--\tPostdecrement\tReturns $x, then decrements $x by one.\n$x = 6;\n\n\necho \"Postincrement :\" . $x++ . \"<br />\\n\";\n// Output: Postincrement: 6\necho \"After postincrement :\" . $x . \"<br />\\n\";\n// Output: After postincrement: 7\n\n\necho \"Preincrement :\" . ++$x . \"<br />\\n\";\n// Output: Preincrement: 8\necho \"After preincrement :\" . $x . \"<br />\\n\";\n// Output: After preincrement: 8\n\n\necho \"Postdecrement :\" . $x-- . \"<br />\\n\";\n// Output: Postdecrement: 8\necho \"After postdecrement :\" . $x . \"<br />\\n\";\n// Output: After postdecrement: 7\n\n\necho \"Predecrement :\" . --$x . \"<br />\\n\";\n// Output: Predecrement: 6\necho \"After predecrement :\" . $x . \"<br />\\n\";\n// Output: After predecrement: 6\nLogical Operators\nOperator\tName\tDescription\nand\tAnd\tx$ and $y is true only if x$ and y$ are both true.\nor\tOr\t$x or $y is true if either $x or $y is true.\nxor\tXor\t$x xor $y is true only when only one of $x or $y is true.\n!\tNot\t!$x is true when $x is false and false when $x is true.\n&&\tAnd\tx$ && $y is true only if x$ and y$ are both true.\n||\tOr\t$x || $y is true if either $x or $y is true.\n\nWhile and and &&, and or and ||, have the same meaning, they operate at different precedences. Importantly, && and || have higher precedence than = while and and or do not.\n\n<?php\n  $x = false || true; // $x is assigned the value true ($x = (false || true))\n  $x = false or true; // $x is assigned the value false (($x = false) or true)\n?>\nString Operators\nOperator\tName\tDescription\n.\tConcatenate\tConcatenates the left and right operands\n.=\tConcatenate assignment\tConcatenates the left and right operands and assigns the value to the left operand.\n<?php\n  $x = 'this' . '&' . 'that';\n\n\n  echo $x; // Output: this&that;\n\n\n  $x .= '!';\n\n\n  echo $x; // Output: this&that!;\n?>\nArray Operators\nOperator\tName\tDescription\n+\tUnion\t$x + $y returns the union of arrays $x and $y.\n+=\tUnion Assignment\t$x += $y assigns the union of $x and $y to $x.\n==\tEqual\t$x == $y is true if $x and $y consist of the same key/value pairs.\n===\tIdentical\t$x === $y is true if $x and $y have the same key/value pairs, in the same order, and of the same types.\n!=\tNot Equal\t$x != $y is true if $x and $y do not have the same key/value pairs.\n<>\tNot Equal\t$x <> $y is true if $x and $y do not have the same key/value pairs.\n!==\tNot Identical\t$x !== $y is true if $x === $y is false.\n\nWhen using + with arrays, it returns an array of the right operand appended to the left operand. In cases where there are matching keys in the arrays, the elements from the left operand will be used and the matching elements from the right operand will be discarded.\n\nType Operators\nOperator\tName\tDescription\ninstanceof\tInstance of\t$x instanceof SomeClass returns true if $x is an instance of the class SomeClass.\n\nSomeClass can be a class name, a variable of the given class, or a string containing the class name."},{"title":"String Functions","description":"PHP has several built-in functions for text processing and the manipulation of strings.\n\nA list of PHP string and text processing functions can be found in the table below:"},{"title":"Variables","description":"Variables store data for later use, and allow their contents to be updated or changed. They’re needed when the same code needs to operate on different values at different times. They’re also used when the same value is needed at multiple places throughout the code.\n\nDeclaring a Variable\n\nA variable in PHP begins with the $ sign followed by the variable name. Unlike other languages, a variable is created as soon as you assign a value to it:\n\n<?php\n  $x = 1500;\n  $y = 3.1415;\n  $z = 'cheese';\n?>\n\nIn the above, $x is assigned the integer 1500, $y is assigned the float 3.1416, and $z is assigned the string 'cheese'.\n\nVariable names obey the following rules in PHP:\n\nVariable names are preceded by $.\nVariable names must start with a letter or the underscore character.\nVariable names can only contain alphanumeric characters and underscores.\nVariable names are case-sensitive."}],"Python":[{"title":"Built-in Functions","description":"The Python interpreter has a set of functions and types built into it (pre-defined). They are always ready at your disposal; you can use them without needing to import a library.\n\nThere are 68 built-in functions and they are listed here in alphabetical order."},{"title":"assert","description":"A keyword for confirming the truthiness of a given statement that is often used to facilitate development, document code, and debug.\n\nSyntax\nassert some_condition, assert_message\n\nThe assert keyword is followed by some_condition to be tested, such as validating a data type or membership within a given container. An optional assert_message can be added that will be printed when the assertion error is raised.\n\nExample\n\nThe assert keyword can be used to validate a value (or evaluate some other condition):\n\nfav_color = 'blue'\n\n\nassert fav_color == 'red'\n\n\n# Output: AssertionError\nCodebyte Example\n\nThe following example uses assert to evaluate if ‘mud’ is within the following list things_that_float:"},{"title":"Casting","description":"Casting, also known as type conversion, is a process that converts a variable’s data type into another data type. These conversions can be implicit (automatically interpreted) or explicit (using built-in functions).\n\nImplicit Type Conversion\n\nThe Python interpreter automatically performs type conversion on some operations without any user involvement.\n\nPython avoids data loss by converting lower data types to higher data types. For example, an integer, 7, is converted to a float when added with another float, 2.2:\n\ny = 7 + 2.2\n# Python automatically type casts y into float\n\n\nprint(y)\n# Output: 9.2\n\n\nprint(type(y))\n# Output: <class 'float'>\n\nSince the expression above represents the sum of two float values, the data type of y is also a float.\n\nExplicit Type Conversion\n\nExplicit type casting involves Python’s predefined functions that act as a constructor of another data type:\n\nThe str() function takes an integer or float as an argument and converts it to a string.\nThe int() function takes a string or float as an argument converts it to an integer.\nThe float() function takes an integer or string as an argument and converts it to a float.\nOperations on Different Types of Data\n\nWhen operating on data, it is important to be mindful of the data types associated with it. The following code is a flawed attempt to print the square of a number specified by the user. When run, a TypeError will be thrown:\n\nThe input() function takes input from the user and stores it in a variable as a string. However, the ** operator takes two numbers and returns the first number to the power of the second. In order to make the code work, the input variable must be cast to a number type. Try to edit the code above to successfully square a number inputted by the user."},{"title":"Classes","description":"Classes are templates used to define the properties and methods of objects in code. They can describe the kinds of information that the class holds, and also how a programmer interacts with that data.\n\nIt serves as a blueprint or template for the objects, or “instances” of the class.\n\nCreating a Class\n\nIn Python, classes are defined using the class keyword.\n\nclass Animal:\n  def __init__(self, name, leg_count):\n    self.name = name\n    self.leg_count = leg_count\n\nClass definitions cannot be empty, so the pass statement can be used as a placeholder to avoid errors.\n\nclass Home:\n  pass\nCreating Instances of a Class\n\nObjects can be created from classes. These objects are called instances of a class, and when we create an instance, that is known as instantiating a class.\n\nTo create an instance of a class, we can set a variable equal to the class name followed by parentheses ().\n\nmy_home = Home()\n\nHere, the instance name is my_home, and the class is Home.\n\nClass Methods\n\nMethods are functions defined as part of a class. The first parameter for any class method is the actual object calling the method, usually called self.\n\nFor example, the following class Home has a method called .paint_wall():\n\nThe first parameter is self.\nThe second parameter is color.\n\nWhen calling a class method, no argument is provided for the parameter self, but arguments must be provided for each following parameter.\n\nclass Home:\n  def paint_wall(self, color):\n    # Method body\n\n\n# Creating an instance of the class\nblue_home = Home()\n\n\n# Calling the method on the instance\nblue_home.paint_wall(\"blue\")\nClass Attributes\n\nClass attributes are variables that are defined outside of all methods and have the same value for every instance of the class.\n\nclass Bird:\n  # Class attribute\n  leg_count = 2\n\n\nparakeet = Bird()\nparrot = Bird()\n\n\nprint(parakeet.leg_count) # Output: 2\nprint(parrot.leg_count)   # Output: 2\nInstance Variables\n\nInstance variables are variables that are unique to each instance of a class. They can be set initially within the __init__() method when the instance is created, or instance variables can be added by setting them to values.\n\nclass Dog:\n  def __init__(self, breed):\n    # Instance variable:\n    self.breed = breed\n\n\ndog = Dog(\"Jindo\")\n\n\ndog.name = \"Ruff\"\n\nWe give the instance dog a new instance variable called name and set it to the value \"Ruff\".\n\ninit() Method\n\nThis method is used to initialize a newly created object. It is called each time a class is instantiated. Instance variables are set within the __init__() method block. Input parameters can be set for this method, which are passed during instantiation.\n\nclass Home:\n  def __init__(self, rooms, stories):\n    # Setting instance variables\n    self.rooms = rooms\n    self.stories = stories\n\n\nhome = Home(4, 2)\n\n\nprint(home.rooms)   # Output: 4\nprint(home.stories) # Output: 2\nrepr() Method\n\nThe __repr__() method returns the string representation of the class. One way to see the string representation is to call print() on the instance.\n\nclass Home:\n  def __init__(self, rooms, stories):\n    self.rooms = rooms\n    self.stories = stories\n\n\n  def __repr__(self):\n    return \"Home with {} rooms and {} stories\".format(self.rooms, self.stories)\n\n\nhome1 = Home(4, 2)\nprint(home1) # Output: Home with 4 rooms and 2 stories\n\n\nhome2 = Home(5, 2)\nprint(home2) # Output: Home with 5 rooms and 2 stories\nAccessing Methods and Variables in the Class\n\nWithin the code of the class, we can call its methods and access its variables. We do this by using self followed by a period . and then followed by the method or variable.\n\nclass Person:\n  def __init__(self, name):\n    self.name = name\n\n\n  def sayHi(self):\n    # Calls its method .getName()\n    print(\"Hi my name is {}\".format(self.getName()))\n\n\n  def getName(self):\n    # Accesses the name variable\n    return self.name\n\n\nbob = Person(\"Bob\")\nbob.sayHi()\n# Output: Hi my name is Bob\ntype() Function\n\nThe type() function returns the data type of the argument passed to it. When the argument is an instance of a class, it returns the class that it is an instance of.\n\nhome = Home(4, 2)\n\n\nprint(type(home))\n# Output: <class '__main__.Home'>\nhasattr() Function\n\nThe hasattr() function can be used to check if an instance of a class has an attribute. It returns True if it does have the attribute, and False otherwise.\n\nhome = Home(4, 2)\n\n\nprint(hasattr(home, 'rooms')) # Output: True\nprint(hasattr(home, 'year'))  # Output: False\nDeleting Objects\n\nObjects, or instances of classes, can be deleted using the del keyword.\n\ndel instance_name\nDeleting Attributes\n\nAttributes of objects can be deleted using the del keyword.\n\ndel instance_name.attribute_name\nExample\n\nLets demonstrate a class for an Employee:\n\nclass Employee(object):\n  name = \"Sam\"\n  company = \"ILoveCode Inc.\"\n  age = 30\n  is_on_vacation = True\n\n\n  def working(self, employee_name):\n    self.name = employee_name\n    print(employee_name + \" is working\")\n\nOnce we create an Employee class like we did above we can import the module in our code and create instances of it whenever and wherever we want, thereby enabling code reusablity and making our code more efficient and easier to maintain.\n\nfrom employee import Employee\n\n\ndef create_employee():\n  print(\"employee is starting thier job\")\n  employee1 = Employee(name=\"Blake\")\n  name = employee1.name\n\n\n  print(employee1.work(name))\n  # Output: Blake is working\n\nWhen creating applications classes are a great way to organize and improve the quality of your code."},{"title":"Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code.\n\nSingle-line Comments\n\nIn Python, the # character is used to start a comment. The comment continues after the # until the end of the line.\n\n# Comment on a single line\n\n\nname = \"Pied Piper\" # Comment after code\nMulti-line Comments\n\nPython does not have a specific syntax for multi-line comments, unlike some other languages.\n\nInstead, multiple # characters can be used:\n\n# This is a comment written over\n# more than one line\n\n\nprint(\"Hello, World!\")\n\nAnother, less official way of writing comments in Python is to use a multi-line string. Python will ignore string literals that are not assigned to a variable, so multi-line strings (created by surrounding text with triple quotes \"\"\") can be used as de facto comments:\n\n\"\"\"\nThis is a string written over\nmore than one line\n\"\"\"\n\n\nprint(\"Hello, World!\")\nCodebyte Example\n\nHere are some examples of comments in a Python program:"},{"title":"Command Line Arguments","description":"Python offers several methods of parsing command line arguments that are used when launching a program. The user has the option of passing various parameters to the program by adding them after the program name. These parameters can be accessed through various modules. The parameter names are left up to the programmer. By convention the parameter -h or --help (and /h and /help in Windows) is reserved to print a help message to the console listing the various command line options recognized by the program.\n\nArguments are passed differently depending on the operating system:\n\nUnix-like arguments are a single letter preceded by a dash (-h) or a word preceded by two dashes (--help).\nWindows arguments are a letter or a whole word preceded by a slash (/h or /help).\nParsing Command Line Arguments With sys.argv\n\nThe sys module offers the most straightforward method of accessing command line arguments, but it also requires the programmer to do most of the work interpreting them. With the sys module, the arguments are passed along in a simple list structure named sys.argv.\n\nThe first item in the list, sys.argv[0] is the name used to launch the Python program, along with the path used. Each subsequent item is a space-delimited argument from the command line used to launch the program. If an argument requires embedded spaces, it needs to be enclosed in quotes to be parsed correctly.\n\nExample\n\nThis prints the script name followed by a list of the command line arguments passed on to the program.\n\nimport sys\n\n\nprint(f\"The program name used to launch me is {sys.argv[0]}.\")\nprint(\"I was passed the following arguments:\")\nfor arg in sys.argv[1:]:\n  print(arg)\n\nIf this is named test.py it can be launched with the following result:\n\n$ test.py --arg1 --arg2 \"arg 3\"\nThe program name used to launch me is test.py.\nI was passed the following arguments:\n--arg1\n--arg2\narg 3\nParsing Command Line Arguments With getopt()\n\nUsing getopt() requires importing both the sys and getopt modules to work. With getopt, parameter validation is added to command line parsing. This is done by passing a list of the command line arguments themselves, a string of short (one character) options, and a list of long (full word) options. To indicate that the option requires a value to be passed along with it, the short option is followed by a colon (:), and the long option is followed by an equals sign (=).\n\nTo set up options for “help”, “argument”, and a “value” that requires an additional passed value, would look like this:\n\nThe short options would be a string like \"hav:\".\nThe long options would be a list like [\"help\",\"argument\",\"value=\"].\nSyntax\noptions, values = getopt.getopt(arguments, short_options, long_options)\n\nWhere the results of getopt() are options which is a list of option/value pairs, and values which is a list of arguments left after the option list was stripped. The parameters passed to getopt() are arguments, a list of the arguments as provided by sys.argv without the initial program name, the string short_options and the list long_options as described above.\n\nIf arguments contains an option that is not in short_options or long_options then an getopt.error exception is thrown.\n\nExample\n\nThis prints the option/value pairs passed as command line arguments.\n\nimport sys, getopt\n\n\narguments = sys.argv[1:]\nshort_options = \"hav:\"\nlong_options = [\"help\",\"argument\",\"value=\"]\n\n\noptions, values = getopt.getopt(arguments, short_options, long_options)\n\n\nfor o, v in options:\n  print(f\"Option is {o}. Value is {v}.\")\n\nIf this is named test.py it can be launched with the following results:\n\n$ test.py -a --value=test\nOption is -a. Value is .\nOption is --value. Value is test.\n\nNote: Since -a wasn’t defined as requiring a value passed to it, the corresponding value for the option is empty.\n\nOther Methods of Parsing the Command Line\n\nThere are other methods of parsing command line arguments in Python, which add varying functionality to the task. Some examples include:\n\nThe argparse module, that’s been available since Python 3.2, validates fixed and optional arguments and offers a default help message displaying the accepted arguments.\nThe docopt module, which is complex and versatile, provides its own language to describe command line options.\nThe click module provides arbitrary nesting of commands and automatic help page generation."},{"title":"Data Types","description":"Python is a strongly typed language, in the sense that at runtime it prevents typing errors and it engages in little implicit type conversion or casting, i.e. converting one type to another without a specific call to a conversion function.\n\ncodecademy = 575\ncodecademy = \"575 broadway\"\n\nAfter line 1, codecademy is an int. After line 2, codecademy is a str.\n\nPython includes the following categories of built-in data types:\n\nString type: str\nBoolean type: bool\nBinary types: bytes, bytearray, memoryview\nNumber types: int, float, complex\nSequence Types: list, range, tuple\nSet types: set, frozenset\nDictionary type: dict\ntype()\n\nThe type() function can be used to retrieve the data type of an object:\n\nmessage = \"Hello, world!\"\n\n\nprint(type(message))\n# Output: <class 'str'>\nisinstance()\n\nThe isinstance() function can be used to test if an object is an instance of a specified type. This will print a boolean value for each function call, indicating if the object is an instance of the given type:\n\nword = \"purple\"\nlanguages = (\"Python\", \"JavaScript\", \"Go\")\n\n\nprint(isinstance(word, str)) # Output: True\nprint(isinstance(languages, list)) # Output: False\nprint(isinstance(languages, tuple)) # Ouput: True"},{"title":"Conditionals","description":"Conditionals take an expression, which is code that evaluates to determine a value, and checks if it is True or False. If it’s True, we can tell our program to do one thing — we can even account for False to do another.\n\nAs we write more complex programs, conditionals allow us to address multiple scenarios and make our programs more robust.\n\nIf Statement\n\nThe Python if statement is used to determine the execution of code based on the evaluation of a Boolean expression.\n\nIf the if statement expression evaluates to True, then the indented code following the statement is executed.\nIf the expression evaluates to False then the indented code following the if statement is skipped and the program executes the next line of code which is indented at the same level as the if statement.\ntest_value = 100\n\n\nif test_value > 1:\n  print(\"This code is executed!\")\n\n\nif test_value > 1000:\n  print(\"This code is NOT executed!\")\n\n\nprint(\"Program continues at this point.\")\nElse Statement\n\nThe Python else statement provides alternate code to execute if the expression in an if statement evaluates to False.\n\nThe indented code for the if statement is executed if the expression evaluates to True. The indented code immediately following the else is executed if and only if the expression evaluates to False.\n\nTo mark the end of the else block, the code must be unindented to the same level as the starting if line.\n\ntest_grade = 61\n\n\nif test_grade > 60:\n  print(\"You passed.\")\nelse:\n  print(\"You failed.\")\n\n\n# Output: You passed.\nElif Statement\n\nThe Python elif statement allows for continued checks to be performed after an initial if statement. An elif statement differs from the else statement because another expression is provided to be checked, just as with the initial if statement.\n\nIf the expression is True, the indented code following the elif is executed. If the expression evaluates to False, the code can continue to an optional else statement.\n\nMultiple elif statements can be used following an initial if to perform a series of checks. Once an elif expression evaluates to True, no further elif statements are executed.\n\npet_type = \"fish\"\n\n\nif pet_type == \"dog\":\n  print(\"You have a dog.\")\nelif pet_type == \"cat\":\n  print(\"You have a cat.\")\nelif pet_type == \"fish\":\n  # This is performed\n  print(\"You have a fish\")\nelse:\n  print(\"Not sure!\")\nCodebyte Example\n\nWhat do you think will happen if pH is changed to 7?"},{"title":"Dates","description":"Python has a built-in module called datetime that can be used to create and modify datetime objects.\n\nBecause the module comes built-in with Python, installation is not required, but we do need to import it at top of a Python file.\n\nAs an example, the code below employs the .datetime.now() method to return the current date and time:\n\nThe result will be the current date and time, something like:\n\n2022-10-05 10:20:57.944968\n\nIt contains the year, month, day, hour, minute, second, and microsecond:\n\nYYYY-MM-DD hh:mm:ss.ffffff\nCreating New datetime Objects\n\nThe datetime module has three main types available:\n\ndate\ntime\ndatetime\nimport datetime\n\n\n# Create date object with year=2021, month=10, and day=5\nmeeting_date = datetime.date(2021, 10, 5)\n\n\n# Create time object with hour=10, minute=5, and seconds=31\nmeeting_time = datetime.time(10, 5, 31)\n\n\n# Create datetime object with year=2021, month=10, day=5, hour=10, minute=5 and seconds=31\nmeeting = datetime.datetime(2021, 10, 5, 10, 5, 31)\n\nFurthermore, we also have a timedelta type which is used to represent time difference.\n\ntimedelta(days, seconds, microseconds, milliseconds, minutes, hours, weeks)\n\nNote that all of the arguments are optional and have default value of 0.\n\nOperations on datetime Objects\n\nWe can perform different operations on a datetime object. For example, if we want to add 2 months to a current date, it can be done as below:\n\nDate and time differences can be calculated using the subtraction operator - on datetime objects."},{"title":"Dictionaries","description":"A dictionary is an ordered set of key-value pairs. It provides a way to map pieces of data to each other and allows for quick access to values associated with keys. Keys must be unique in dictionaries, but the values don’t have to be.\n\nPython dictionaries are dynamic and mutable, which means they can change.\n\nIf you assign a value to an already existing dictionary key, it does not add the key a second time. Instead, it replaces the existing value. Dictionaries also have several built-in methods which make it easier to manipulate the data structure and objects contained within.\n\nNote: As of Python version 3.7, dictionaries are ordered based on insertion, but this is not the case in Python 3.6 and earlier.\n\nSyntax\n\nThe syntax of a dictionary is as follows:\n\ndictionary_name = { key1: value1,  key2: value2,  key3: value3 }\n\nEach entry in a dictionary is a key-value pair. Each pair is separated by a comma.\n\nDictionary keys must be immutable types such as numbers and strings because keys should not change. Keys cannot be lists because lists are mutable, and it will raise a TypeError.\n\nValues can be any type, such as strings, numbers, lists, and even other dictionaries.\n\nCreating a Dictionary\n\nAn empty dictionary is created with curly braces:\n\ndiner = {}\n\nAn empty dictionary can also be created using the built-in function, dict(), with no arguments:\n\ndiner = dict()\n\nA dictionary with entries:\n\ncoffee_shop = { \"cold brew\": 3.50, \"latte\": 4.25, \"cappucino\": 3.99 }\n\nThe three key-value pairs in the coffee_shop dictionary:\n\n\"cold brew\": 3.50\n\"latte\": 4.25\n\"cappucino\": 3.99\nAccessing a Dictionary\n\nThe values in a dictionary can be accessed by passing the associated key name:\n\ncoffee_shop = { \"cold brew\": 3.50, \"latte\": 4.25, \"cappucino\": 3.99 }\n\n\nprint(coffee_shop[\"cold brew\"])\n# Output: 3.5\n\nWhen you try to access a key that does not exist, it will raise a KeyError.\n\nIterating Through a Dictionary\n\nThere are several ways to iterate through a dictionary depending on which data you want to access: keys, values, or both.\n\nThe following codebyte consists of four for loops that iterate through the coffee_shop dictionary:\n\nThe for loops access and print each key, value, key-value tuple, and individual key-values in coffee_shop, respectively.\n\nAdding an Entry\n\nTo add an entry, use square brackets to create an index into a new_key and assign it a new_value:\n\nmy_dict[new_key] = new_value\nCreating a Dictionary using Dictionary Comprehension\n\nLike a list comprehension, a dictionary comprehension is a Pythonic way to create a dictionary. They can be used to filter and manipulate data in tons of useful ways. The syntax is as follows:\n\nnew_dict = { expression for key, value in old_dict.items() if condition }\n\nThe if condition at the end is optional, but is a great tool for filtering data. For example, given a dictionary with a person’s name and age, make a new dictionary that only contains people with an age under 25:\n\nperson_age = { \"Mark\": 55, \"Shiela\": 28, \"Bryce\": 24, \"Jim\": 41, \"Eric\": 33, \"Ally\": 23 }\nperson_age_filtered = { name: age for name, age in person_age.items() if age < 25 }\n\nThe expression is name: age, as that’s how the new dictionary will be formatted. Then, the typical for loop iteration, for name, age in person_age.items(). Lastly, the if condition filters out the results.\n\nThe expression can also perform operations on the data being extracting. For example, to create a dictionary with key value pairs of a number and its square given a list of numbers:\n\nnums_list = [ 1, 2, 3, 4, 5 ]\nnums_squared = { num: num**2 for num in nums_list }\n\nnums_squared will produce a result of: { 1: 1, 2: 4, 3: 9, 4: 16, 5: 25 }"},{"title":"Errors","description":"There are (at least) two distinguishable kinds of errors in Python: syntax errors and exceptions.\n\nSyntax Errors\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python:\n\nFile \"script.py\", line 1\n  while True print(\"Hello world!\")\n                   ^\nSyntaxError: invalid syntax\n\nThe parser repeats the offending line and displays a little arrow ^ pointing at the earliest point in the line where the error was detected.\n\nThe error is caused by (or at least detected at) the token preceding the arrow in the example, the error is detected at the function print(), since a colon : is missing before it.\n\nFile name and line number are printed so you know where to look in case the input came from a script.\n\nExceptions\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal. Most exceptions are not handled by programs, however, and result in error messages as shown here:\n\nValue Error\n\nValueError is thrown when a function’s argument is of an inappropriate type.\n\nTraceback (most recent call last):\nFile \"script.py\", line 1, in <module>\nint('xyz')\nValueError: invalid literal for int() with base 10: 'xyz'\nName Error\n\nNameError is thrown when an object could not be found.\n\nTraceback (most recent call last):\nFile \"script.py\", line 1, in <module>\nage\nNameError: name 'age' is not defined\nIndex Error\n\nIndexError is thrown when trying to access an item at an invalid index.\n\nTraceback (most recent call last):\nFile \"script.py\", line 1, in <module>\nemployees[3]\nIndexError: list index out of range\nModule Not Found Error\n\nModuleNotFoundError is thrown when a module could not be found.\n\nTraceback (most recent call last):\nFile \"script.py\", line 1, in <module>\nimport notamodule\nModuleNotFoundError: No module named 'notamodule'\nZero Division Error\n\nZeroDivisionError is thrown when the second operator in the division is zero.\n\nTraceback (most recent call last):\nFile \"script.py\", line 1, in <module>\nratio = 100 / 0\nZeroDivisionError: division by zero"},{"title":"Files","description":"Files are named locations on the computer’s disk that permanently store information for future use of its data. They are used to permanently store data in non-volatile memory (e.g. hard disk) as opposed to volatile sources like Random Access Memory RAM, which loses its data when the computer is turned off.\n\nFile Handling\n\nHandling files is a common feature that many languages use to work with the computer’s file system. In Python, file handling is possible and usually takes place in the following order:\n\nOpen (or create) the file.\nPerform operations on the file, such as reading or writing to it.\nClose the file to its resources are freed.\nExample\n\nThe small example below demonstrates how one process of file handling could work:\n\n# Create, or overwrite, a file and open for writing\nfile = open(\"myfile.txt\", \"w\")\nfile.write(\"Hello world!\")\nfile.close()\n\n\n# Open existing file to read and print text content\nfile = open(\"myfile.txt\", \"r\")\nfirst_two_bytes = file.read(2)\nnext_three_bytes = file.read(3)\nthe_rest = file.read()\nprint(first_two_bytes, next_three_bytes, the_rest, sep=\"\\n\")\nfile.close()\n\nIn the first part of the code example, a plain text file named myfile.txt was created and opened in the \"w\" “write”-mode. Then a piece of text was written to the file and closed afterward.\n\nIn the next part, a few calls to the .read() method are assigned to some variables and then each one is printed on a new line:\n\nHe\nllo\n world!\n\nMore information about file methods in Python can be found below."},{"title":"Functions","description":"Some tasks need to be performed multiple times within a program. Rather than rewrite the same code in multiple places, a function may be defined using the def keyword. Function definitions may include parameters, providing data input to the function.\n\nSyntax\ndef my_function(value):\n  return value + 1\n\nprint(my_function(2))\nprint(my_function(3 + 5))\n\nFunctions may return a value using the return keyword followed by a value. They can then be called, or invoked, elsewhere in the program. The output from the snippet above would look similar to this:\n\n3\n9\n\nNote: Function names in Python are written in snake_case.\n\nReturn Values\n\nThe return keyword is used to return a value from a Python function. The value returned from a function can be assigned to a variable which can then be used in the program.\n\nIn the example below, the check_leap_year() function returns a string that indicates if the passed parameter is a leap year or not.\n\ndef check_leap_year(year):\n  if year % 4 == 0:\n    return str(year) + \" is a leap year.\"\n  else:\n    return str(year) + \" is not a leap year.\"\n\n\nyear_to_check = 2018\n\n\nreturned_value = check_leap_year(year_to_check)\n\n\nprint(returned_value)\n\nThe resulting output will look like this:\n\n2018 is not a leap year.\nReturning Values With yield\n\nA function can also return values with the yield keyword. Like return, yield suspends the function’s execution and returns the value specified. Unlike return, the yield statement retains the state of the function and will resume where it left off on the next function call (i.e. execution resumes after the last yield statement). This way, the function can produce a number of values over time.\n\nFunctions using yield rather than return are known as generator functions. Such a function can be used as an iterator.\n\nThe example below will automatically generate successive Fibonacci numbers.\n\n# Function to produce infinite Fibonacci numbers\ndef fibonacci():\n  # Generate first number\n  a = 1\n  yield a\n\n\n  # Generate second number\n  b = 1\n  yield b\n\n\n  # Infinite loop\n  while True:\n    # Return sum of a + b\n    c = a + b\n    yield c\n    # Function resumes loop here on next call\n    a = b\n    b = c\n\n\n# Iterate through the Fibonacci sequence until a limit is reached\nfor num in fibonacci():\n  if num > 50:\n    break\n  print(num)\n\nThis will output the following:\n\n1\n1\n2\n3\n5\n8\n13\n21\n34\nHigher-Order Functions\n\nIn Python, functions are treated as first-class objects. This means that they can be assigned to variables, stored in data structures, and passed to or returned from other functions.\n\nFunctions are considered to be “higher-order” values because they can be used as parameters or return values for other functions. One example is the built-in filter() function:\n\nfilter() takes a predicate (a function that returns a boolean value) and an iterable, and returns a new iterable containing all elements of the first one that makes the predicate true."},{"title":"Functools Module","description":"The functools module contains functions that support a functional programming approach in Python.\n\nThe following functions are provided by this module."},{"title":"Generators","description":"In Python, a generator is a function or expression that will process a given iterable one object at a time, on demand. A generator will return a generator object, which can be cast as a list or some other data structure as appropriate.\n\nGenerators\n\nGenerators are a convenient means of employing iterator functionality within the syntax of a function or expression. One of the main advantages of generators is that they evaluate items on demand, which means only one item is in memory at a time in lieu of the entire sequence (as with a list).\n\nA Generator Function\n\nThe following code shows the creation of a generator function. In the function definition, the yield statement is used to return or include an item in the final generator object.\n\ndef return_evens(lst):\n    for l in lst:\n        if l % 2 == 0:\n            yield l\n\n\neggs = [x for x in range(20)]\n\n\nprint(list(return_evens(eggs)))\n# Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\nA Generator Expression\n\nThe functionality in the previous example can alternatively be defined as an expression. A generator expression utilizes the same syntax as a list comprehension with parentheses framing the statement instead of square brackets.\n\neggs = [x for x in range(20)] # a list comprehension\n\n\nlist((x for x in eggs if x % 2 == 0)) # a generator expression\nCustom Iteration\n\nA generator object can be incrementally advanced with the next() function. When next() is called the current item is returned and the state is saved."},{"title":"Inheritance","description":"Inheritance is an object-oriented programming concept where a class (often referred to as the child class) derives attributes and behaviors from another class (often referred to as the parent class).\n\nThis eliminates the need to implement the methods inherited by a subclass, or child class, again. In other words, it enables a child class to inherit/reuse the attributes and methods of a parent class. In terms of real-world objects, it represents an IS-A relationship.\n\n# Base/super/parent class\nclass ProgramLanguage:\n  def __init__(self, name):\n    self.name = name\n\n\n# Derived/sub/child class\nclass Python(ProgramLanguage):\n  pass\n\n\n# Create an object of the derived class\ny = Python(\"Inheritance\")\n\n\nprint(y.name)\n# Output: Inheritance\n\nIn the above code, subclass Python inherits the variable name and method __init__ from the base class ProgramLanguage. The pass statement acts as a placeholder for the class body.\n\nReusing Parent Methods\n\nBase class methods can be reused in the derived classes. This prevents redundant code.\n\nIn the example below, the derived class, Python, implements the .say_hi() parent method inside the .intro() definition:\n\n# Base class\nclass ProgramLanguage:\n  def say_hi(self):\n    print(\"Hi! I am a Programming Language.\")\n\n\n# Derived class\nclass Python(ProgramLanguage):\n  def intro(self):\n    ProgramLanguage.say_hi(self) # Parent class method\n    print(\"Python here!\")\n\n\n# Object of the derived class\ndoc = Python()\ndoc.intro()\n\nThe output would be:\n\nHi! I am a Programming Language.\nPython here!\n\nNote: Inside the child class, the same number and type of arguments need to be passed into the parent class’ method.\n\nsuper()\n\nsuper() returns a temporary object of the superclass, allowing the superclass’s methods to be called. This comes in handy when using multiple inheritance.\n\nIn this case, the .say_hi() method is implemented utilizing super() inside .intro():\n\nclass Python(ProgramLanguage):\n  def intro(self):\n    super().say_hi()\n    print(\"Python here!\")\n\n\ndoc = Python()\ndoc.intro()\n\nThe output would be:\n\nHi! I am a Programming Language.\nPython here!\nOverriding Methods\n\nIn the child class, a parent class method gets overridden when a method of the same name is declared within it.\n\nclass Python(ProgramLanguage):\n  def say_hi(self): # Overriding parent method\n    print(\"Hi! I am Python. I am fun!\")\n\n\ny = Python()\ny.say_hi()\n# Output: Hi! I am Python. I am fun!\n\nIf a method is overridden in the child class, the original method can still be accessed by calling the method directly on the parent class name and passing the child class object as an argument:\n\ny = Python()\ny.say_hi()\n\n\nprint(\"... and now the 'old' ProgramLanguage way of saying hi\")\n\n\n# Using the overridden method from parent class\nProgramLanguage.say_hi(y)\n\nThe output would be:\n\nHi! I am Python.\n... and now the 'old' ProgramLanguage way of saying hi\nHi! I am a Programming Language.\nPrivate Variables\n\nWhen instance variables of the parent class don’t need to be inherited by the child class, they can be made unavailable to the child class by adding double underscores (__) before the variable name. This appends _classname before the variable name. So, when we try to access it like other instance variables of the class it gives an “Attribute error”.\n\nclass ProgramLanguage:\n  def __init__(self, name):\n    self.name = name\n    self.__private = 'Private variable'\n\n\nclass Python(ProgramLanguage):\n  pass\n\n\ny = Python(\"Python\")\n\n\nprint(y.name)\nprint(y.__private)\n\nThe error would be:\n\nAttributeError: 'Python' object has no attribute '__private'\n\n__private in parent class ProgramLanguage is now _ProgramLanguage__private and can’t be accessed using .__private. Same is true for class methods.\n\nNote: Employing a double underscore prefix only makes the method or variable inaccessible using the originally declared name. These can still be accessed, like y._ProgramLanguage__private in the above example. The use of this syntax is an indication of how the variable or method should be treated.\n\nisinstance() and issubclass()\n\nPython has two built-in functions that work with inheritance:\n\nisinstance()\nissubclasss()\n\nisinstance() checks an instance’s type:\n\nisinstance(obj, int)\n\nThe code above will be True only if obj is an object of class int or an object of some derived class of int.\n\nissubclass() checks class inheritance:\n\nprint(issubclass(bool, int))   # True\nprint(issubclass(float, int))  # False\n\nSince bool is a subclass of int, it returns True. However, since float is not a subclass of int, it returns False.\n\nAbstract Base Class\n\nAbstract base classes are inherited rather than instantiated.\n\nfrom abc import ABC, abstractmethod\n\n\nclass AbstractClass(ABC):\n  def __init__(self, id, name):\n    self.id = id\n    self.name = name\n\n\n  @abstractmethod\n  def calculate_payroll(self):\n    pass\n\nAbstractClass is derived from ABC, making it an Abstract Base Class. This tells users of the module that AbstractClass can not be instantiated, only inherited.\n\n.calculate_payroll() is decorated with @abstractmethod, denoting it as an abstract method. This tells developers that if they wish to inherit from AbstractClass, they must override the .calculate_payroll() method. Otherwise, the derived class cannot be instantiated.\n\nTypes of Inheritance\nSingle Inheritance\n\nWhen a child class inherits from only one parent class, it is called single inheritance. All prior code snippets use single inheritance.\n\nMultiple Inheritance\n\nWhen a child class inherits from multiple parent classes, it is called multiple inheritance.\n\nPython IS-A ProgramLanguage and a ScriptLanguage; it inherits from both these classes:\n\n# Parent 1\nclass ProgramLanguage:\n  def __init__(self, name):\n    self.name = name\n\n\n# Parent 2\nclass ScriptLanguage:\n  def __init__(self, text):\n    self.text = text\n\n\n# Child class\nclass Python(ProgramLanguage, ScriptLanguage):\n  # Reusing methods/constructors and overriding __init__()\n  def __init__(self, name, text):\n    ProgramLanguage.__init__(self, name)\n    ScriptLanguage.__init__(self, text)\n\n\n# Create object of derived class\ny = Python(\"Inheritance\",\"I allow code reusability.\")\n\n\nprint(\"Hi! I am {}. {}\".format(y.name, y.text))\n\nThe output would be:\n\nHi! I am Inheritance. I allow code reusability.\nMultilevel Inheritance\n\nWhen a derived class inherits from another derived class.\n\nIn the code below, class GrandChild() inherits from class Child:\n\n# Base 1\nclass Base(object):\n  def __init__(self, name):\n    self.name = name\n\n\n  def getName(self):\n    return self.name\n\n\n# Inherited/sub class\nclass Child(Base):\n  def __init__(self, name, age):\n    Base.__init__(self, name)\n    self.age = age\n\n\n  def getAge(self):\n    return self.age\n\n\n# Inherited class from sub class above\nclass GrandChild(Child):\n  def __init__(self, name, age, address):\n    Child.__init__(self, name, age)\n    self.address = address\n\n\n  def getAddress(self):\n    return self.address\n\n\ng = GrandChild(\"James\", 23, \"Transylvania\")\nprint(g.getName(), g.getAge(), g.getAddress())\n\n\n# Output: James 23 Transylvania\nHierarchical Inheritance\n\nMore than one derived class is created from a single base class:\n\nclass ProgramLanguage:\n  def __init__(self, name):\n    self.name = name\n\n\nclass Python(ProgramLanguage):\n  pass\n\n\nclass Java(ProgramLanguage):\n  pass\n\n\ny = Python(\"Python\")\nprint(y.name)\n\n\nx = Java(\"Java\")\nprint(x.name)\n\n\n# Output:\n# Python\n# Java\nHybrid Inheritance\n\nThis form is a blend of more than one type of inheritance mentioned above.\n\nPotential Complications\nClass Explosion Problem\n\nAlthough a program may work as expected, having many classes to support the idea implementation causes the class hierarchy’s inevitable growth. All this leads to the class explosion problem where class hierarchies become too extensive and make code hard to understand and maintain.\n\nDiamond Problem\n\nThe diamond problem is an obscurity that arises in multiple inheritance.\n\nClasses, B and C, inherit from class A, and class D inherits from both B and C. If there is a method in A that B and C have overridden and D does not override it, which version of the method does D inherit: that of B, or that of C?\n\nclass A:\n  def m(self):\n    print(\"inside A\")\n\n\nclass B(A):\n  def m(self):\n    print(\"in B\")\n\n\nclass C(A):\n  def m(self):\n    print(\"in C\")\n\n\nclass D(B, C):\n  pass\n\n\nobj = D()\nobj.m()\n# Output: in B\n\nThe order of parent classes decide which class D inherits from. To call the parent function of choice, the super() method is called inside the child class."},{"title":"JSON Module","description":"The json module provides tools for working with the JavaScript Object Notation (JSON) format. It can be imported with the following line:\n\nimport json\n\nThe following functions are provided by this module:"},{"title":"Iterators","description":"In Python, an iterator is an object representing a collection of elements (such as data or methods) where each element can be accessed by traversing through the collection to perform the required tasks.\n\nAn iterator supports the next() function which takes no arguments and always returns the next element of the collection. When all elements are exhausted, it returns the StopIteration exception.\n\nIterables\n\nObjects that can be converted into iterators are called iterables. Datatypes such as lists, tuples, dictionaries, and sets are iterable, meaning that they can be converted into iterators using the iter() function.\n\nThe difference between an iterable and an iterator can be easily be understood by considering iterable as a birthday cake that we need to distribute to a number of people. We cut cake into several pieces using the iter() function to get an iterator. Then we use next() to distribute each piece.\n\nAlso, it is important to understand that all iterators are iterable but the converse is not true.\n\nCode for an Iterator using a List\n\nThe following code shows the generation of an iterator from a list using the iter() function and usage of the next() function by manually iterating through all the items of the iterator. When there are no more elements left in an iterator, it returns the StopIteration exception.\n\nNote: Once an iterator has been iterated through, it cannot be re-iterated again.\n\nIterator in a for loop\n\nThe for loop has built-in iter() and next() functions, which allows running iterations more elegantly.\n\nIteration using a while loop\n\nThe while loop does not have the built-in iter() and next() functions as in the for loop, so the iter() and next() functions need to be used separately.\n\nCreating a User-Defined Iterable Object\n\nSince an iterable object is an object that can be converted into Iterator, for an object to be iterable it needs to support the iter() function and the iterator generated must also support next().\n\nIn the above code, built-in iter() function is equivalent to user-defined __iter__() method, when iter() function is invoked it invokes __iter__() method after checking the data type of input argument.\n\nSimilarly, next(cake_after_cutting) is same as cake_after_cutting.__next__(). When next() function is invoked it invokes __next__() method after checking data type of input argument."},{"title":"Keywords","description":"Certain keywords are reserved in Python and are not available to be assigned as variables or named functions. There are many keywords where some specialize in control-flow (e.g. if/else and for) while others work as operators (e.g. and, in, and is)."},{"title":"Lists","description":"A list in Python is a data type used to store a collection of objects.\n\nLists are always ordered and can contain different types of objects, such as strings, integers, booleans, etc. Lists are a mutable data type and therefore a good choice for dynamic data (adding and subtracting to lists).\n\nCreating a List\n\nThere are multiple ways to define a list in Python. We can either assign a variable to a pair of square brackets ([]) with or without values, or we can assign a variable to the list() keyword and afterwords pass in its list items.\n\nDefining empty lists:\n\nlist1 = []\nlist2 = list()\n\nCreating lists with values in them:\n\nlist1 = ['one', 2, 'three']\nlist2 = [True, False, False, True, False]\nlist3 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist4 = ['one', 2, True]\nlist5 = ['one', 'two', 'three']\nUsing a Built-in List Method\nfriends = ['Sue', 'Bob']\n\n\nprint(type(friends))\n\n\n# Use a built-in method to add Anna to the list of friends.\nfriends.append('Anna')\n\n\nprint(friends)\n\nThe output would be:\n\n<class 'list'>\n['Sue', 'Bob', 'Anna']"},{"title":"Loops","description":"While Loops\n\nIn Python, a while loop will repeatedly execute a code block as long as a condition evaluates to True.\n\nThe condition of a while loop is always checked first before the block of code runs. If the condition is not met initially, then the code block will never run.\n\nwhile condition:\n  # Code inside\n\nThis loop will only run 1 time:\n\nhungry = True\n\n\nwhile hungry:\n  print(\"Time to eat!\")\n  hungry = False\n\nThis loop will run 5 times:\n\ni = 1\n\n\nwhile i < 6:\n  print(i)\n  i = i + 1\nFor Loop\n\nPython for loops can be used to iterate over and perform an action one time for each element in a list.\n\nProper for loop syntax assigns a temporary value, the current item of the list, to a variable on each successive iteration:\n\nfor <temporary value> in <a list>:\n\nfor loop bodies must be indented to avoid an IndentationError.\n\ndog_breeds = [\"boxer\", \"bulldog\", \"shiba inu\"]\n\n\n# Print each breed:\nfor breed in dog_breeds:\n  print(breed)\nNested Loops\n\nIn Python, loops can be nested inside other loops. Nested loops can be used to access items of lists which are inside other lists. The item selected from the outer loop can be used as the list for the inner loop to iterate over.\n\ngroups = [[\"Jobs\", \"Gates\"], [\"Newton\", \"Euclid\"], [\"Einstein\", \"Feynman\"]]\n\n\n# This outer loop will iterate over each list in the groups list\nfor group in groups:\n  # This inner loop will go through each name in each list\n  for name in group:\n    print(name)\nBreak Keyword\n\nIn a loop, the break keyword escapes the loop, regardless of the iteration number. Once break executes, the program will continue to execute after the loop.\n\nnumbers = [0, 254, 2, -1, 3]\n\n\nfor num in numbers:\n  if (num < 0):\n    print(\"Negative number detected!\")\n    break\n  print(num)\n\nIn this example, the output would be:\n\n0\n254\n2\nNegative number detected!\nContinue Keyword\n\nIn Python, the continue keyword is used inside a loop to skip the remaining code inside the loop code block and begin the next loop iteration.\n\nbig_number_list = [1, 2, -1, 4, -5, 5, 2, -9]\n\n\n# Print only positive numbers:\nfor i in big_number_list:\n  if i < 0:\n    continue\n  print(i)"},{"title":"Math Module","description":"Python has a built-in math module that we can use for mathematical tasks. This module provides access to the mathematical functions defined by the C standard.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats."},{"title":"Memoization","description":"In Python, memoization can be used to improve a program’s performance.\n\nThis is ideal whenever the same calculations (with the same inputs and outputs) are known to take place. Memoization helps by saving, or caching, these results in computer memory for later use. It can be applied to many contexts, including:\n\nMaking calls to recursive or pure functions where some calculations use the same inputs and return the same outputs.\nFetching from the server with the same base API endpoints.\nSyntax\nmemo = {}\n\ndef memo_function(args):\n  if(args in memo):\n    return memo[args]\n  else:\n    # Do this and update memo.\n\nIn Python, one way memoized results are represented is with dictionaries. In a given function, if a previously calculated result exists in the memo dictionary, it is returned. Otherwise, normal calculations take place and the memo dictionary is updated.\n\nExample\n\nIn the example below, the get_square() function accepts a parameter n and returns the square of it. With small inputs, this function takes little to no time to process. But as the inputs get larger, the timelapse becomes more noticeable. This point is further shown with the time module.\n\nTo address this, memoization is used in the get_square_memo() function where such calculations are skipped if they have already been made and stored in memo."},{"title":"Modules","description":"A module is a Python file that contains functions, definitions, and statements that can be included in an application.\n\nThink of a module as a code library that can be reused across applications. Modules improve code reusablity and allow us to access shared libraries and packages.\n\nInstead of entering commands directly into a Python interpreter, Python code can be saved as a module so that we can use it again later in other applications. Modules can also be used to access libraries such as numpy, sklearn, and the date-time built-in module.\n\nCreating and Importing Modules\n\nA module can be created by saving a Python file with the .py file extension. It can then be imported into another Python file with the import command followed by the module name.\n\nFor example, to import a video_player.py file:\n\nimport video_player\n\n\n# Rest of the program starts here...\n\nThe program now has access to all functions, objects, and statements contained within the video_player module.\n\nImporting Specific Resources\n\nInstead of importing the whole module, individual named resources can be specified. For example:\n\nfrom collections import Counter\n\nThis will import only the Counter class from Python’s collections built-in module, rather than all types of collections contained within it.\n\nIt’s often useful to import only the resources that you need to avoid slowing down your program and polluting your local namespace where your code runs.\n\nNamespaces and Scope\n\nA module within our local namespace can be renamed by creating an alias using the as keyword. For example:\n\nfrom bs4 import BeautifulSoup as bs\n\nAliasing is especially convenient for shortening module names and managing the local namespace where our code executes.\n\nOnce a module is imported, it is within the scope of the program and it can be accessed in the local namespace."},{"title":"Modulo","description":"In Python, the percent sign (%) is known as the modulo operator.\n\nA modulo calculation returns the remainder of the division between two numbers.\n\nExample 1\nx = 12 % 5\n\n\nprint(x) # Output: 2\n\nBecause 12 is not evenly divisible by 5, the value of x is 2.\n\nExample 2\ny = 10 % 5\n\n\nprint(y) # Output: 0\n\nBecause 10 is evenly divisible by 5, the value of y is 0.\n\nCodebyte Example"},{"title":"Operators","description":"Operators are used to perform various operations on variables and values. The standard arithmetic and assignment operators are the most familiar.\n\nSyntax\n\nThe following code snippet uses the assignment operator, =, to set my_variable to the value of num1 and num2 with an arithmetic operator acting on them. For example, if operator represented *, my_variable would be assigned a value of num1 * num2.\n\nmy_variable = num1 operator num2\n\nPython operators can be organized into the following groups:\n\nArithmetic operators for performing traditional math evaluations.\nAssignment operators for assigning values to variables.\nComparison operators for comparing two values.\nLogical operators for combining boolean values.\nArithmetic Operators\n\nPython has the following arithmetic operators:\n\nAddition, +, which returns the sum of two numbers.\nSubtraction, -, which returns the difference of two numbers.\nMultiplication, *, which returns the product of two numbers.\nDivision, /, which returns the quotient of two numbers.\nExponentiation, **, which returns the value of one number raised to the power of another.\nModulus, %, which returns the remainder of one number divided by another.\nFloor division, //, which returns the integer quotient of two numbers.\nAssignment Operators\n\nPython includes the following assignment operators:\n\nThe = operator assigns the value on the left to the variable on the right.\nThe += operator updates a variable by incrementing its value and reassigning it.\nThe -= operator updates a variable by decrementing its value and reassigning it.\nThe *= operator updates a variable by multiplying its value and reassigning it.\nThe /= operator updates a variable by dividing its value and reassigning it.\nThe %= operator updates a variable by calculating its modulus against another value and reassigning it.\nComparison Operators\n\nPython has the following comparison operators:\n\nEqual, ==, for returning True if two values are equal.\nNot equal, !=, for returning True if two values are not equal.\nLess than, <, for returning True if left value less than right value.\nLess than or equal to, <=, for returning True if left value is less than or equal to right value.\nGreater than, >, for returning True if left value greater than right value.\nGreater than or equal to, >=, for returning True if left value greater than or equal to right value.\nLogical Operators\n\nPython has the following logical operators:\n\nThe and operator returns True if both statements are True.\nThe or operator returns True if either statement is True.\nThe not operator returns True if its associated statement is False.\nOrder of Operations\n\nPython evaluates an expression in order of precedence as follows:\n\nItems in parentheses, ((…)), have the highest level of precedence, expressions within them are evaluated first.\nExponentiation (**)\nMultiplication and division operators (*, /, // & %)\nAddition and subtraction (+ & -)\nComparison (<, <=, > & >=)\nEquality (== & !=)\nnot\nand\nor\n\nNote: Items at the same precedence are evaluated left to right. The exception to this is exponentiation, which evaluates right to left."},{"title":"pip","description":"pip is the package installer used in Python to install code packages. A similar tool is Node Package Manager (npm) in JavaScript. Much like npm, pip is the same community-driven package space, but for Python.\n\nPackages\n\nThe concept of packages is not unique to pip. A package is a collection of code that is designed for a specific purpose. These packages are also meant to be re-used and distributed by other developers.\n\nOne example is Flask. Much like how Express can facilitate the creation of server routes for backend development in JavaScript, Flask can offer the same reproducible and concise solution for developers who use Python.\n\nPython Package Index Repository (PyPI)\n\nThe Python Package Index Repository (PyPI), hosts a large collection of packages. The official package installer of PyPI is pip, which is used in the command line. A good practice to understand how to use a package is reading its documentation on PyPI.\n\nDocumentation on PyPI typically comes with the following:\n\nA list of requirements to run the package.\nInstructions for installing the package.\nOne or more examples of how the package is implemented.\npip Installation\n\npip commonly comes with the installation of Python. Therefore, the first step in installing pip is verifying that it is already installed. This step can vary between versions of Python as well as what machine it is running on. The examples below are for version 3.6.3 and above. A good resource for more specific instructions would be the official Python tutorial on installing packages.\n\n# Windows\npy --version\n\n\n# Linux/macOS\npython3 --version\n\nIt should be noted that as per the pip documentation, pip maintainers are no longer supporting Python 2 and below.\n\nTo upgrade Python, python.org will have the latest version for install. In addition, Python 3.4 and above will have pip installed by default.\n\nThe following command is run to check the latest version pip:\n\n# Windows\npy -m pip --version\n\n\n# Linux/macOS\npython -m pip --version\n\nIf pip is already installed, its version will appear in the terminal.\n\nIf pip is out of date, the following command will upgrade it:\n\n# Windows\npy -m pip install --upgrade\n\n\n# Linux/macOS\npython -m pip install --upgrade\n\nFinally, it is now possible to start installing packages from PyPI. In the following example, a fake package called ACoolPackage will be used. This isn’t a real package on PyPI, rather it is just a placeholder for a real package. It is recommended to visit the PyPI page of the package being installed for more specific instructions.\n\npy -m pip install ACoolPackage"},{"title":"Random Module","description":"In Python, the built-in random module is used to randomly generate numbers as well as randomly manipulate collections such as lists and strings.\n\nThis module can be used when imported at the top of a Python file:\n\nimport random\n\nThe random variable can then be used for executing the module’s built-in methods, like the .random() method below:\n\nrandom.random()"},{"title":"Recursion","description":"Functions in Python can call themselves — a concept known as “recursion”. Recursion is a technique that allows a function to be broken down and operated on more efficiently.\n\nSyntax\ndef recursiveSyntax(parameter_1, parameter_2, ..., parameterN):\n  if(base_cases involving parameters):\n    return \"this data\"\n  else:\n    recursive_call = recursiveSyntax(parameter_1 - 1, parameter_2 - 2, parameterN)\n    return recursive_call\n\nRecursive functions are commonly structured to operate on their parameters under two scenarios:\n\nA recursive_call to the recursiveSyntax() but with smaller values for the parameters.\nOne or more base_cases that stop the line of recursive calls and return data that can be aggregated back up the recursive_call chain.\nExample\n\nIn the example below, a recursive call to sodaCount is made until the count reaches zero, printing a message each time:\n\ndef sodaCount(count):\n  if(count==0):\n    print(\"All of the soda is gone!\")\n    return\n  else:\n    print(f\"{count} bottles of soda left on the shelf.\")\n    return sodaCount(count-1)\n\n\nprint(sodaCount(5))\n\nThe resulting output will look like this:\n\n5 bottles of soda left on the shelf.\n4 bottles of soda left on the shelf.\n3 bottles of soda left on the shelf.\n2 bottles of soda left on the shelf.\n1 bottles of soda left on the shelf.\nAll of the soda is gone!\nNone\nCodebyte Example\n\nConsider the Fibonacci sequence, whose first two terms are explicitly defined to be 0 and 1. Each subsequent term is constructed by taking the sum of the previous two terms. Thus, the first six terms of the sequence are 0, 1, 1, 2, 3, and 5.\n\nDefining a function that prints the n-th Fibonacci number is most easily achieved using recursion.\n\nInside the else block of the function definition, two recursive calls to fibonacci() (representing the two previous numbers) are added and returned. Once n is equal to 0 or 1, the base case (the if block) runs instead."},{"title":"Regular Expressions","description":"Regex, short for Regular Expressions, is a powerful system for searching text. Regular expressions are implemented in a variety of languages including java and python.\n\nIn Python, regular expressions are available through the re module:\n\nimport re\n\nThe following are some of the regular expression operations:"},{"title":"Requests","description":"The requests module is the de facto standard for sending HTTP requests in Python.\n\nIt abstracts the complexities of making requests behind a beautiful, simple API so that you can focus on interacting with services and consuming data in your application.\n\nThe HTTP request returns a Response Object with all the response data (content, encoding, status, etc).\n\nInstallation\n\nLet’s begin by installing the requests module. To do so, run the following command in the terminal:\n\npip install requests\n\nOnce requests is installed, you can use it in your program. Importing requests looks like this:\n\nimport requests"},{"title":"Scope","description":"Scope refers to the areas that variables are visible and accessible. Variables that can be accessed anywhere in a Python program are in the global scope. Conversely, variables that are defined within the body of structures like classes and methods exist only in the local scope.\n\nLocal Scope\n\nSuppose a variable is initialized within a function. This variable can only be used within that function and not from outside the function.\n\ndef my_function():\n x = 200\n print(x)\n\n\nmy_function()\nNested Functions and Local Scope\n\nIn the example below, a variable x is defined within the local scope of the outer_function() function, followed by a defined inner_function() function. Since inner_function() exists within the local scope of outer_function(), x can be accessed and printed within inner_function():\n\ndef outer_function():\n  x = 200\n  # Initialized in outer function\n\n\n  def inner_function():\n    print(x)\n  inner_function()\n\n\nouter_function()\n# Output: 200\nGlobal Scope\n\nA variable initialized in the main body is defined as a global variable and can be used anywhere in the code, including nested blocks, loops, etc. This is because these variables exist in the global scope of the code.\n\nx = 200\n\n\ndef fun():\n  print(x)\n\n\nfun()\n\n\nprint(x)\n\"\"\"\nOutput:\n200\n200\n\"\"\""},{"title":"Sets","description":"A set is an unordered collection of elements without any duplicates.\n\nSets are especially useful for performing logical operations like finding the union, intersection, or difference between collections of elements. For example, sets could be used to determine mutual friends on a social networking site.\n\nCreating a Set\n\nThere are several ways to create a set.\n\nWe can create a set from a list with the set() keyword:\n\nanimals = set()\nanimals = set(['aardvark', 'snail', 'squid'])\n\nA set can also be created with curly braces:\n\noceans = {'Pacific', 'Atlantic', 'Indian', 'Southern', 'Arctic'}\n\nIt’s important to note that creating a set will remove any duplicate elements. For example:\n\ndog_breeds = {'pug', 'golden retriever', 'corgi', 'pug', 'corgi'}\n\n\nprint(dog_breeds)\n# Output: {'pug', 'golden retriever', 'corgi'}\n\nThis will create a new set with only unique values.\n\nSet Operations\n\nSets are especially useful for logical operations such as finding the intersection, union, or difference between collections.\n\nUnion\n\nThe .union() method or | operator can be used to merge two or more sets:\n\nliked_artists1 = {'Grimes', 'Billie Eilish'}\nliked_artists2 = set({'Daft Punk', 'Iggy Azalea'})\n\n\nall_likes = liked_artists1.union(liked_artists2)\n\n\nprint(all_likes)\n\nThe output would be:\n\n{'Iggy Azalea', 'Daft Punk', 'Grimes', 'Billie Eilish'}\nIntersection\n\nWe can use the .intersection() method or & operator to find the shared elements within two or more sets. For example:\n\nfriend_group1= {'Juan', 'Mary', 'David', 'Yukiko', 'Alice'}\nfriend_group2 = {'Yukiko', 'Peter', 'Juan', 'Alice'}\n\n\nmutual_friends = friend_group1.intersection(friend_group2)\n\n\nprint(mutual_friends)\n\nThe output would be:\n\n{'Yukiko', 'Alice', 'Juan'}\nDifference\n\nWe can use the .difference() method or - operator to identify objects unique to a set. For example:\n\nsue_likes = {'Pizza', 'Tofu', 'Poke'}\nerika_likes = {'Poke', 'Pizza', 'Popcorn'}\n\n\nprint(sue_likes - erika_likes)\n\nThis would only print the items unique to the first set:\n\n{'Tofu'}\nFrozensets\n\nFrozensets are a special type of set that are immutable. Like tuples, their contents are frozen and cannot changed after creation.\n\nWe can create frozensets with the frozenset() function:\n\nfrozen_objects = frozenset(['ice cube', 'glacier', 'frozen_set'])\n\nSet methods that modify the set such as .update(), .remove(), and .add() cannot be used with frozensets since they are frozen in place!"},{"title":"Substrings","description":"A substring is a sequence of characters that are part of an original string. In Python, substrings can be obtained by using the slicing feature on a string variable. A slice can be made in a specific position within the string or it can be made at the default index.\n\nSyntax\n\nA slice is made by using the open [ and closed ] square brackets next to a string variable. Inside the brackets, the position can be given:\n\nstring[start:end:step]\nstart defaults to 0 and gives the initial position the slice will start from.\nend defaults to -1 and is the position where the slicing will end.\nstep defaults to 1 and indicates the number of steps to take in between indexes.\nExamples\n\nThe following examples show different ways of obtaining substrings from an original string name.\n\nname = \"Code Ninja\"\nRetrieving Single Characters\n\nWhen only one index is specified, a single character is returned. An index of 0 retrieves the first character of the string:\n\nprint(name[0])\n\n\n# Output: C\n\nNegative numbers work on the string backwards. For example, index -1 retrieves the last character of the string:\n\nprint(name[-1])\n\n\n# Output: a\nNegative Start Index\n\nUsing a negative start index (-n) with the default end value accesses the last n characters of the string. The following gives access to the last three characters of the string:\n\nprint(name[-3:])\n\n\n# Output: nja\nEnd Index\n\nTo specify only an end index, use [:n], where n is the ending position. This will return the first n characters.\n\nprint(name[:4])\n\n\n# Output: Code\nNegative Step Value\n\nGiven a negative step value, returns the results backward:\n\nreversed = name[::-2]\nprint(reversed)\n\n\n# Output: anNeo\nKeyword in\n\nThe in keyword can be used to check for a specific substring, like in the example below:\n\nprint('de' in name)\n\n\n# Output: True\n.find() Method\n\nThe string method .find() can also be used to find a subset. It returns the index of the first occurrence of the substring. If the substring is not found, it returns -1."},{"title":"Strings","description":"A string is a sequence of characters contained within a pair of single quotes (') or double quotes(\"). Strings can store words, sentences, or whole paragraphs. They can be any length and can contain letters, numbers, symbols, and spaces.\n\nmessage1 = \"I am a string\"\nmessage2 = 'I am also a string'\n\nOther data types such as integers, doubles, and booleans can also be strings provided that they are wrapped in quotes.\n\nAll of the following are strings:\n\n\"2\"\n'3.6'\n\"True\"\n\nHowever, none of the following are strings:\n\n7\nHello\nTrue\n\nStrings are immutable; they cannot change. Every time an operation is performed on a string, a new string is created in memory.\n\nAccessing the Characters of a String\n\nStrings in Python are technically a type of list — one in which each character is a separate element. This means each character in a string can be individually accessed by index, like with the elements in a list:\n\nmyString = \"Hello, World!\"\n\n\nvar_1 = myString[0]\nvar_2 = myString[7:]\nvar_3 = myString[1:4]\n\n\nprint(\"var_1: \" + var_1) # Output: var_1: H\nprint(\"var_2: \" + var_2) # Output: var_2: World!\nprint(\"var_3: \" + var_3) # Output: var_3: ell\n\nIf an attempt is made to access an index out of bounds, it will return an IndexError.\n\nname = \"phillis\"\nname[8] # Throws an IndexError\nMulti-line Strings\n\nStrings can be long or short. For longer text, a multi-line string can be used. Multi-line strings begin and end with three single or double quotes:\n\nmy_string = \"\"\"If it were done when 'tis done, then 'twere well\nIt were done quickly: if the assassination\nCould trammel up the consequence, and catch\nWith his surcease success; that but this blow\nMight be the be-all and the end-all here,\nBut here, upon this bank and shoal of time,\nWe'ld jump the life to come.\"\"\"\nEscape Characters\n\nSometimes a string may have a character that Python tries to interpret, such as '.\n\nmy_string = 'It's a lovely day!'\n\n\nprint(my_string)\n\nThis will raise an error, because the interpreter thinks the second ' marks the end of the string.\n\n  File \"main.py\", line 1\n    my_string = 'It's a lovely day!'\n                    ^\nSyntaxError: invalid syntax\n\nThese characters can be “escaped” by adding a backslash beforehand. The \\ is called an escape character.\n\nThe backslash will not be visible if the string is printed:\n\nmy_string = 'It\\'s a lovely day!'\n\n\nprint(my_string)\n# Output: It's a lovely day!\n\nThis problem can be avoided by wrapping strings containing ' characters in double quotes:\n\nmy_string = \"It's a lovely day!\"\n\n\nprint(my_string)\n# Output: It's a lovely day!\n\nPython also has a series of non-printing characters that can modify strings. For example, \\n adds a new line and \\t adds a tab:\n\nnote = \"I am on top!\\nI am on bottom. \\n\\tI am indented!\"\n\n\nprint(note)\n\nThis will output:\n\nI am on top!\nI am on bottom.\n        I am indented!\nModifying Strings\n\nPython has special operators to modify strings. For example, + can be used to concatenate strings, and * can be used to duplicate a string. The keyword in can be used to see if a given character or substring exists in a string.\n\nstring_one = \"Hello, \"\nstring_two = \"World! \"\ncombo = string_one + string_two\n\n\nprint(combo)\n# Output: Hello, World!\n\n\nnew_combo = combo * 2\n\n\nprint(new_combo)\n# Output: Hello, World! Hello, World!\n\n\nif \"World\" in new_combo:\n  print(\"It's here!\")\n  # Output: It's here!\nComparing Strings\n\nPython can use comparison operators to compare the contents of two strings. The operators behave as they do with numeric arguments:\n\nOperator\tTerm\tDescription\n==\tEqual\tReturns True if two strings are equal.\n!=\tNot equal\tReturns True if two strings are not equal.\n<\tLess than\tReturns True if the left string is lexically prior the right string.\n>\tGreater than\tReturns True is the left string comes lexically after the right string.\n<=\tLess than or equal to\tReturns True if the left string is equal to or lexically prior to the right string.\n>=\tGreater than or equal to\tReturns True if the left string is equal to or comes lexically after the right string.\n\nThe following example demonstrates string comparison:\n\nBuilt-in String Methods\n\nPython has a number of built-in string methods that manipulate strings. However, when these methods are called, the original string will not be changed, so any modifications will need to be saved to a new variable. A few useful built-in string methods are listed below."},{"title":"Time Module","description":"Python has a built-in time module that can be used for time related tasks. This module utilizes a number of different standards and objects that may be unfamiliar such as:\n\nThe epoch refers to a reference point in time from which calculations can be made. It is designated as midnight on January 1, 1970.\nThere are functions that will return values formatted using Daylight Savings Time (DST).\nThere is a specific time data type called struct_time.\n\nThe following functions are provided by this module."},{"title":"Tuples","description":"A tuple is a Python data structure used to store an ordered and immutable collection of objects. Tuples are similar to lists, except that tuples cannot be changed after creation.\n\nCreating a Tuple\n\nThere are multiple ways to create a tuple in Python.\n\nTuples can be created with the built-in tuple() constructor:\n\nstreaming_platforms = tuple([\"Netflix\", \"Hulu\", \"Amazon\", \"Apple TV\"])\n\nWe can also create tuples with parentheses:\n\nmountains = (\"Everest\", \"Kilimanjaro\", \"Fuji\")\n\nOne-element tuples are a special case. We can create a one-element tuple with a trailing comma:\n\ncontroller = (\"joystick\", )\n\nWithout the trailing comma, Python will interpet the surrounding parentheses as an expression instead of a tuple:\n\nstreaming_days = (3)\n\n\nprint(type(streaming_days))\n# Output: <class 'int'>\nUsing a Tuple\n\nMuch like lists, since tuples are ordered, we can access tuple elements by index:\n\nstreaming_platforms = tuple([\"Netflix\", \"Hulu\", \"Amazon\", \"Apple TV\"])\n\n\nprint(streaming_platforms[1])\n# Output: Hulu\n\nHowever, since tuples are immutable, we cannot modify, delete, or add new elements. For example, attempting to re-assign an element will throw an error:\n\nstreaming_platforms = tuple([\"Netflix\", \"Hulu\", \"Amazon\", \"Apple TV\"])\n\n\nstreaming_platforms[2] = \"YouTube\"\n\nThis will result in:\n\nTypeError: 'tuple' object does not support item assignment\n\nTuples also support sequence operations such as len(), min(), max()."},{"title":"User Input","description":"input() is a built-in function in Python that allows a user to assign custom input to a variable.\n\nmy_cats_name = input(\"What is your cat's name? \\n\")\n\n\nprint(\"The best cat in the world is \" + my_cats_name)\n\nWhen this code is run, it will print out “What is your cat’s name?”. Then, the user can type in something and press enter. Whatever the user types will be saved to the variable my_cats_name and printed out in the final print() function.\n\nOnce a user inputs a value it can be used like a normal variable. For example, it can be compared against other variables:\n\nanswer = input(\"What is the meaning of life? \\n\")\n\n\nif answer == \"42\":\n  print(\"Good job!\")\nelse:\n  print(\"Sorry! That's not it.\")\n\nIn this case, when the code is run, it will print out “What is the meaning of life?”. If the user types \"42\" and presses enter, it will print “Good job!”. If the user types anything other than \"42\", it will print out “Sorry! That’s not it”.\n\nWhatever the user types will be saved as a string. However, the string can be converted to other types.\n\nmy_num = input(\"What number comes after 1? \\n\")\n\n\nif my_num == 2:\n  print(\"Correct!\")\nelse:\n  print(\"No...\")\n\n\n# Output: No...\n\nThis always prints “No…” because the string '2' does not equal the number 2.\n\nmy_num = input(\"What number comes after 1? \\n\")\n\n\nif int(my_num) == 2:\n  print(\"Correct!\")\nelse:\n  print(\"No...\")\n\nWith the addition of the int() type conversion function, this now prints “Correct!” if and only if the user inputs 2."},{"title":"Variables","description":"A variable is used to store data that will be used by the program. This data can be a number, a string, a Boolean, a list or some other data type. Every variable has a name which can consist of letters, numbers, and the underscore character _.\n\nThe equal sign = is used to assign a value to a variable. After the initial assignment is made, the value of a variable can be updated to new values as needed.\n\nVariable Names\n\nA variable can have a short name (like x and y) or a more descriptive name (age, grade, grocery_list).\n\nRules for Python variables:\n\nA variable name must start with a letter or the underscore character. It cannot start with a number.\nA variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _).\nVariable names are case-sensitive (num, Num, and NUM are three different variables).\nExamples\n\nThese are all valid variable names and assignment:\n\nuser_name = \"@sonny420\"\nuser_id = 100\nverified = False\n\nA variable’s value can be changed after assignment"}],"R Programming Language":[{"title":"Comments","description":"A comment is a piece of text within an R program that is not executed. It can be used to provide additional information to aid in understanding the code. It can also serve to “comment out” blocks of code that the programmer doesn’t want executed, such as for archival purposes or debugging. Many languages support single line and multi-line comments. Only single-line comments are supported in R.\n\nSyntax\n\nComments in R begin with a # character. Everything after the # on that line will be ignored. The comment can either go at the beginning of the line or immediately after the code that will be executed:\n\n# This is a comment and won't be executed.\n\n\nprint(\"This is a line of code that will be executed.\")\n\n\na <- 3 + 5 # comments can also go at the end of a line of code.\n\n\n# To have a multi-line comment in R,\n# multiple '#' characters must be used\n# for each subsequent line."},{"title":"Data Types","description":"R supports many data types, each with different uses and characteristics. Variables can hold different data types, and are not limited to storing the data type they were initially assigned.\n\n# This is legal in R\n\n\n# Assign an integer data type\nvar1 <- 1L\n\n\n# Assign a string data type\nvar1 <- \"Hello world!\"\n\nR supports the following basic data types:\n\nThe numeric type for whole numbers or decimals. (5.12, 16)\nThe integer type for whole numbers followed by an L. (100L)\nThe complex type for numbers with an imaginary part, denoted by an i. (5 + 7i)\nThe character type for strings of characters. (“Hello World!”)\nThe logical for Boolean values. (TRUE or FALSE)\n\nThe class() function can be used to determine the data type of a variable.\n\nx <- 3 + 2i\nclass(x) # Output: \"complex\"\n\n\nx <- 100\nclass(x) # Output: \"numeric\"\n\n\nx <- 100L\nclass(x) # Output: \"integer\""},{"title":"Operators","description":"Operators are used in R to perform various operations on variables and values. Among the most commonly used ones are arithmetic and assignment operators.\n\nSyntax\n\nThe following R code uses an arithmetic operator for multiplication, *, to calculate the product of two numbers, along with the assignment operator, <- to store the result in the variable x.\n\n# Store five times three in variable x\nx <- 5 * 3\n\nOperators in R can be organized into the following groups:\n\nArithmetic operators for traditional mathematical evaluations such as addition and subtraction.\nAssignment operators for assigning values to variables.\nComparison operators for testing equality between values.\nLogical operators for evaluating the “truthiness” of values against one another.\nMiscellaneous operators for various tasks including vectors and sequencing.\nArithmetic operators\n\nR supports the following arithmetic operators:\n\nAddition, +, which returns the sum of two numbers.\nSubtraction, -, which returns the difference between two numbers.\nMultiplication, *, which returns the product of two numbers.\nDivision, /, which returns the quotient of two numbers.\nExponents, ^, which returns the value of one number raised to the power of another.\nModulus, %, which returns the remainder of one number divided by another.\nInteger Division, %/%, which returns the integer quotient of two numbers.\nAssignment operators\n\nR uses the following assignment operators:\n\n<- assigns a value to a variable from right to left.\n-> assigns a value to a variable left to right.\n<<- is a global version of <-.\n->> is a global version of ->.\n= works the same way as <-, but its use is discouraged.\nComparison operators\n\nR has the following comparison operators:\n\nEqual, ==, which returns TRUE if two values are equal.\nNot equal, !=, which returns TRUE if two values are not equal.\nLess than, <, which returns TRUE if left value is less than right value.\nLess than or equal to, <=, which returns TRUE if left value is less than or equal to right value.\nGreater than, >, which returns TRUE if left value is greater than right value.\nGreater than or equal to, >=, which returns TRUE if left value is greater than or equal to right value.\nLogical operators\n\nR has the following logical operators:\n\nElement-wise AND, &, for comparing each element and returning TRUE if both elements are TRUE.\nLogical AND, &&, which returns TRUE if both values are TRUE, only evaluates as many elements as necessary.\nElement-wise OR, |, for comparing each element and returning TRUE if either element is TRUE.\nLogical OR, ||, which returns TRUE if either value is TRUE, only evaluates as many elements as necessary.\nLogical NOT, !, which returns TRUE if the associated statement is FALSE.\n\nNote: The long form of AND and OR (&& and ||) are preferred for if statements as the short form can produce a vector value.\n\nMiscellaneous operators\n\nR uses the following miscellaneous operators:\n\nThe : operator creates a sequence of numbers from the left argument to the right one.\nThe %in% operator returns TRUE if the left argument is in the vector to the right.\nThe %*% operator performs matrix multiplication on two matrices."},{"title":"Variables","description":"A variable is used to store data that can be accessed later by subsequent code. In R, there are no variable “declaration” commands. Instead, they are created with the assignment operator, <- (The more familiar assignment operator, =, can be used instead, but is discouraged).\n\n# This creates a variable containing the string \"value\"\nvariable <- \"value\"\n\nThe assignment operator can be chained together to initialize multiple variables at once:\n\nvar1 <- var2 <- var3 <- 0\n\nIn R, writing a defined variable name by itself on a line has the effect of printing its associated value:\n\nscore <- 100\n\n\n# This line:\nscore # Output 100\n\n\n# Has the same effect as this line:\nprint(score) # Output 100\nVariable Names\n\nR variables must adhere to the following naming conventions:\n\nThe name can be a combination of letters, digits, period(.) and underscore(_).\nIt must start with a letter or a period.\nIf it starts with a period, the second character cannot be a number.\nIt cannot start with a number or an underscore.\nVariable names are case-sensitive.\nReserved words (TRUE, FALSE, print, etc.) cannot be used as variable names.\nExamples\n\nThe following code snippet shows examples of valid variable names in R:\n\nfoo <- 1\nFoo <- 2 # A different variable from \"foo\" above\n.bar <- TRUE\nfoo_bar <- \"value\"\n3.5 -> Foo123.4 # Rightward assignment."}],"React":[{"title":"Components","description":"In React, components make up the UI of the application. Components are pieces of code that are reusable and independent. Each component comes with one or both of the following:\n\nA state object that contains component data that is expected to change over time.\nA props object with data that can be passed down from parent component to child component.\nClass Components\n\nClass components contain a state and use a render() function to return JSX markup. When defined, the class has to be an extention of the React.Component class:\n\nimport React from 'react';\n\n\nclass ClassComponent extends React.Component {\n  this.state = {\n    property1: \"A string\",\n    property2: 1,\n    property3: true\n  }\n\n\n  render() {\n    return (\n      <div>\n        ...\n      <div>\n    )\n  };\n};\nFunction Components\n\nFunction components are stateless and only use the return statement. No import statement necessary:\n\nfunction FunctionComponent(props) {\n  return (\n    <div>\n      ...\n    <div>\n  )\n}\nArrow Function\n\nThe arrow function is a feature that was introduced in ES6. It uses the = and > characters to define a function like a variable. In React, function components can be defined with this syntax:\n\nconst FunctionComponent = (props) => {\n  return (\n    <div>\n      ...\n    <div>\n  )\n}"},{"title":"Hooks","description":"In React, hooks are functions that give function components class-like abilities. These abilities include:\n\nUsing state\nPerforming side effects\n\nThere are a few rules when using hooks! Specifically:\n\nCall hooks at the top level of React functions. If hooks are called in a loop, condition, or nested function, they may not render in the same order every time.\nCall hooks from React functions and not regular JavaScript functions.\n\nWhile there are standard React hooks, like useState() and useEffect(), there are also custom-made hooks!\n\nHooks are imported at the top of a file from the react library:\n\nimport React, { useState, useEffect } from 'react';\nSyntax of useState()\n\nPass an initialValue into useState() to return a pair of new values:\n\nA current state value\nA function, setState that updates the state\nconst [state, setState] = useState(initialValue);\n\nuseState() returns an array. The first element is the initialValue assigned to state. The second element is a function with a similar use case as React’s this.setState() class component method.\n\nSyntax of useEffect()\n\nThe useEffect() hook and function will execute whenever a component mounts or updates. It is equivalent to React’s class component lifecycle methods: componentDidMount(), componentDidUpdate(), and componentWillUnmount().\n\nA callback function, sideEffects(), is passed into useEffect(). In addition, the component’s state can be accessed inside of sideEffect().\n\nuseEffect(function sideEffects() {\n  ...\n})\n\nThe default behavior for effects is to invoke the effect after every completed render.\n\nTo fire the effect function conditionally, a second argument is passed to useEffect. This argument is an array of values that the effect depends on.\n\nNote: When registering event listeners inside the effect function, it is not ideal to call them every time a component rerenders. Registering a new listener on every update might cause memory leaks.\n\nuseEffect(function sideEffects() {\n  ...\n}, [dep1, dep2, ...]); // Re-runs the effect if a value in the array changes\n\nIn the example below, the effect runs the first time a component mounts. Subsequent rerenders don’t fire the effect. This might be useful for setting up a subscription to an external service or registering event listeners.\n\nuseEffect(function sideEffects() {\n  ...\n}, []); // Runs the effect when a component renders the first time"},{"title":"JSX","description":"JSX is a syntax extension of JavaScript that combines the JavaScript and HTML-like syntax to provide highly functional, reusable markup. It’s used to create DOM elements which are then rendered in the React DOM.\n\nWhile not required in React, JSX provides a neat visual reqresentation of the application’s UI.\n\nA JavaScript file containing JSX will have to be compiled before it reaches a web browser.\n\nSyntax\n\nJSX looks a lot like HTML:\n\nconst headerElement = <h1>This is a header</h1>;\n\nIn the block of code, we see the similarities between JSX syntax and HTML: they both use the angle bracket opening <h1> and closing </h1> tags.\n\nUnder the hood, after it’s been processed to regular JavaScript, it looks like this:\n\nconst headerElement = React.createElement('h1', 'This is a header');\n\nJavaScript code, such as variables and functions, can be used in JSX, as well:\n\nimport React from 'react';\n\n\nconst App = () => {\n  return (\n    <React.Fragment>\n      <button onClick={() => 'The button was clicked!'}>Click!</button>\n    </React.Fragment>\n  );\n};\nJSX Attributes\n\nThe syntax of JSX attributes closely resembles that of HTML attributes.\n\nconst example = <h1 id=\"example\">JSX Attributes</h1>;\n\nIn the block of code, inside of the opening tag of the <h1> JSX element, we see an id attribute with the value \"example\".\n\nNested JSX Elements\n\nIn order for the code to compile, a JSX expression must have exactly one outermost element. In the below block of code, the <a> tag is the outermost element.\n\nconst myClasses = (\n  <a href=\"https://www.codecademy.com\">\n    <h1>Sign Up!</h1>\n  </a>\n);\nMultiline JSX Expression\n\nA JSX expression that spans multiple lines must be wrapped in parentheses ( and ).\n\nconst myList = (\n  <ul>\n    <li>Item 1</li>\n    <li>Item 2</li>\n    <li>Item 3</li>\n  </ul>\n);\n\nHere, we see the opening parentheses on the same line as the constant declaration, before the JSX expression begins. We see the closing parentheses on the line following the end of the JSX expression.\n\nJSX with .map() Method\n\nThe array method .map() comes up often in React. It’s good to get in the habit of using it alongside JSX.\n\nIf you want to create a list of JSX elements from a given array, then.map() over each element in the array, returning a list item for each one.\n\nconst strings = ['Home', 'Shop', 'About Me'];\n\n\nconst listItems = strings.map((string) => <li>{string}</li>);\n\n\n<ul>{listItems}</ul>;\nJSX Conditionals\n\nJSX does not support if/else syntax in embedded JavaScript. There are three ways to express conditionals for use with JSX elements:\n\nUsing Ternary Operator\n\nUsing ternary operator within curly braces in JSX:\n\nconst headline = <h1>{age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff'}</h1>;\nUsing if Statement\n\nUsing if/else statement outside of JSX element:\n\nlet text;\n\n\nif (age >= drinkingAge) {\n  text = 'Buy Drink';\n} else {\n  text = 'Do Teen Stuff';\n}\n\n\nconst headline = <h1>{text}</h1>;\nUsing && Operator\n\nUsing && AND operator:\n\n// Renders as empty div if length is 0\nconst unreadMessages = ['hello?', 'remember me!'];\n\n\nconst update = (\n  <div>\n    {unreadMessages.length > 0 && (\n      <h1>You have {unreadMessages.length} unread messages.</h1>\n    )}\n  </div>\n);"},{"title":"Lifecycle Methods","description":"In React, lifecycle methods are unique event listeners that listen for changes during certain points during a component‘s lifecycle. A component’s lifecycle usually runs in this order:\n\nRendering/mounting a component to the DOM for the first time.\nUpdatilng an existing component.\nCatching any errors associated with a component render-gone-wrong.\nUnmounting a component and removing it from the DOM.\n\nLifecycle methods were originally exclusive to class components. But thanks to React hooks, even functional component’s can work with their lifecycle.\n\nRendering/Mounting a Component\n\nAfter a component is first created and render()ed to the DOM, it is “mounted”. The method used here is called componentDidMount(), which occurs after the component is rendered.\n\nimport React from \"react\";\n\n\nclass App extends React.Component {\n  componentDidMount() {\n    conosle.log(\"Component has mounted!\")\n  }\n\n\n  render() {\n    console.log(\"Rendering...\")\n    return(\n      <React.Fragment>\n      <React.Fragment>\n\n\n    )\n  }\n}\n\nAnd the output should be this:\n\nRendering...\nComponent has mounted!\nUpdating a Component\n\nWhen changes are made to a component, usually to its state, it is in the update-phase of its lifecycle. This is handled by the componentDidUpdate() method.\n\nUsing the common <Counter> example, and some custom increase() and decrease() event methods to change its count state, compomentDidUpdate() will execute immediately after either of these methods executes:\n\nimport React from 'react';\n\n\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n\n\n    this.state = {\n      count: 0,\n    };\n\n\n    this.increment = () => this.setState({ count: this.state.count + 1 });\n    this.decrement = () => this.setState({ count: this.state.count - 1 });\n  }\n\n\n  componentDidMount() {\n    console.log('Component has mounted.');\n  }\n\n\n  componentDidUpdate() {\n    console.log('Component updated. Count is now ' + this.state.count + '.');\n  }\n\n\n  render() {\n    console.log('Rendering...');\n    return (\n      <React.Fragment>\n        <h1>Count: {this.state.count}</h1>\n        <button onClick={this.increment}>+1</button>\n        <button onClick={this.decrement}>-1</button>\n      </React.Fragment>\n    );\n  }\n}\n\nAssuming we clicked the “+” button twice, which causes a re-render() each time, our output would be this:\n\nRendering...\nComponent has mounted.\nRendering...\nComponent udpated. Count is now 1.\nRendering...\nComponent updated. Count is now 2.\nCatching Errors in Components\n\nPrior to React 16, there were no features that handled errors being thrown during the component tree’s “rendering” phase. When this occurred, the following would happen:\n\nThe entire app would crash and all components would ummount.\nA trace report of the error would replace the UI.\n\nThis prompted the creation of the following lifecycle methods for handling errors in React class components:\n\nstatic getDerivedStateFromError(error) for returning an updated state to allow a render of fallback UI.\ncomponentDidCatch(error, errorInfo) for logging error information to the console, including a component stack tracing back to the source of the error.\n\nAny class component that uses either or both of these methods is considered to be an Error Boundary component because they are catching errors thrown from their child components.\n\nimport React from \"react\";\n\n\nclass CounterThatThrowsError extends React.Component {\n  constructor(props) {\n    super(props)\n\n\n    this.state = {\n      count: 0\n    }\n\n\n    this.increment = () => this.setState({count: this.state.count + 1})\n    this.decrement = () => this.setState({count: this.state.count - 1})\n  }\n\n\n  render() {\n    if(this.state.count === 3) throw new Error(\"Crashed!\")\n\n\n    return(\n      <React.Fragment>\n        <h1>Count: {this.state.count}</h1>\n        <button onClick={this.increment}>+1</button>\n        <button onClick={this.decrement}>-1</button>\n      </React.Fragment>\n    )\n  }\n};\n\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n\n\n    this.state = {\n      hasError: false,\n      error: null\n    }\n  }\n\n\n  getDerivedStateFromError(error) {\n    return {\n      hasError: true,\n      error: error\n    }\n  }\n\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error.name + \": \" error.message)\n    // Output: Error: Crashed!\n  }\n\n\n  render() {\n    if(this.state.hasError) {\n      return (\n        <div style={{ marginLeft: \"2em\" }}>\n          <h1>Oh no! Something's gone wrong!</h1>\n        </div>\n      )\n    }\n\n\n    return(\n      <div className=\"App\">\n        <Counter />\n      </div>\n    )\n  }\n}\n\nNote: getDerivedStateFromError() and componentDidCatch() are only able to work with errors strictly related to their child components. They are not compatible with errors related to event handlers.\n\nUnmounting a Component\n\nWhen a component is unmounted, it is considered to be at the end of its lifecycle within the React applicaiton. The associated lifecycle method is componentWillUnmount(), which executes when React anticipates its host-component will be destroyed.\n\nGoing back to the previous example where the <Counter> component throws an error after is state is equal to 3, it is thereby destroyed and replaced by new a new UI inside of its parent component, <App>.\n\nimport React from \"react\";\n\n\nclass CounterThatThrowsError extends React.Component {\n  constructor(props) {\n    super(props)\n\n\n    this.state = {\n      count: 0\n    }\n\n\n    this.increment = () => this.setState({count: this.state.count + 1})\n    this.decrement = () => this.setState({count: this.state.count - 1})\n  }\n\n\n  componentWillUnmount() {\n    console.log(\"Counter has been unmounted!\")\n    // Ouput: Counter has been unmounted!\n  }\n\n\n  render() {\n    if(this.state.count === 3) throw new Error(\"Crashed!\")\n\n\n    return(\n      <React.Fragment>\n        <h1>Count: {this.state.count}</h1>\n        <button onClick={this.increment}>+1</button>\n        <button onClick={this.decrement}>-1</button>\n      </React.Fragment>\n    )\n  }\n};\n\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n\n\n    this.state = {\n      hasError: false,\n      error: null\n    }\n  }\n\n\n  getDerivedStateFromError(error) {\n    return {\n      hasError: true,\n      error: error\n    }\n  }\n\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error.name + \": \" error.message)\n    // Output: Error: Crashed!\n  }\n\n\n  render() {\n    if(this.state.hasError) {\n      return (\n        <div style={{ marginLeft: \"2em\" }}>\n          <h1>Oh no! Something's gone wrong!</h1>\n        </div>\n      )\n    }\n\n\n    return(\n      <div className=\"App\">\n        <Counter />\n      </div>\n    )\n  }\n}"},{"title":"Routing","description":"In React, routing is most commonly achieved through React Router.\n\nReact Router is a third-party library that allow components to be used as routed endpoints within an application. This library comes in three packages:\n\nreact-router: For core functionality\nreact-router-native: React Native version\nreact-router-dom: Recommended for web applications\n\nInstall the newest version with npm:\n\nnpm install react-router-dom@latest\n\nThe newest version of React Router is v6, which comes with many breaking changes including:\n\nUsing a <Routes /> component instead of a <Switch /> component for <Route /> configuration.\nUsing the element attribute instead of component when passing a JSX to a <Link />.\nExample\n\nBelow, a <BrowserRouter/> (aliased as <Router/>) is used to map the navigation <Link/> components to a <Routes/> component. The <Routes/> renders the appropriate <Route> based on the most specific-matching path among all possible matches.\n\nimport Home from './Home';\nimport About from './About';\nimport Projects from './Projects';\nimport Contact from './Contact';\n\n\nimport { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom';\n\n\nconst App = () => {\n  return (\n    <div>\n      <Router>\n        <nav>\n          <ul>\n            <Routes>\n              <Route path=\"/about\" element={<About />} />\n              <Route path=\"/blog\" element={<Blog />} />\n              <Route path=\"/contact\" element={<Contact />} />\n              <Route path=\"/\" element={<Home />} />\n            </Routes>\n            <li>\n              <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n              <Link to=\"/about\">About</Link>\n            </li>\n            <li>\n              <Link to=\"/projects\">Projects</Link>\n            </li>\n            <li>\n              <Link to=\"/contact\">Contact</Link>\n            </li>\n          </ul>\n        </nav>\n      </Router>\n    </div>\n  );\n};\n\n\nconst Home = () => {\n  return <h2>Home</h2>;\n};\n\n\nconst About = () => {\n  return <h2>About</h2>;\n};\n\n\nconst Projects = () => {\n  return <h2>Projects</h2>;\n};\n\n\nconst Contact = () => {\n  return <h2>Contact</h2>;\n};\n\n\nexport default App;"},{"title":"Props","description":"In React, components are able to use props, or “properties”, to display and share data throughout the application. In other words, props is the information that gets passed from one component to another.\n\nParent components can pass props to their child components, but not the other way around. Props can be many data types, including:\n\nNumbers\nStrings\nFunctions\nObjects\nSyntax\nimport React from 'react';\n\n\nclass ParentComponent extends React.Component {\n  render() {\n    return <ChildComponent prop1=\"Mike\" prop2=\"piza\">\n  }\n}\n\n\nfunction ChildComponent(props) {\n  return <h2>This is prop1: {props.prop1}. This is prop2: {props.prop2}.</h2>\n}\nthis.props\n\nEvery component has something called props.\n\nA component’s props is an object. It holds information about that component.\n\nTo see a component’s props object, you use the expression this.props. Here’s an example of this.props being used inside of a render method:\n\nrender() {\n  // Printing the props object\n  console.log(this.props);\n\n\n  return <h1>Hello world</h1>;\n}\nPass props to a Component\n\nYou can pass information to a React component. How? By giving that component an attribute:\n\n<MyComponent foo=\"bar\" />\n\nLet’s say that you want to pass a component the message, \"This is some top secret info.\". Here’s how you could do it:\n\n<Example message=\"This is some top secret info.\" />\n\nAs you can see, to pass information to a component, you need a name for the information that you want to pass.\n\nIn the above example, we used the name message. You can use any name you want.\n\nIf you want to pass information that isn’t a string, then wrap that information in curly braces. Here’s how you would pass an array:\n\n<Greeting myInfo={['top', 'secret', 'lol']} />\n\nIn this next example, we pass several pieces of information to <Greeting />. The values that aren’t strings are wrapped in curly braces:\n\n<Greeting name=\"Frarthur\" town=\"Flundon\" age={2} haunted={false} />\nDisplaying the Props\n\nYou will often want a component to display the information that you pass.\n\nHere’s how to make a component display passed-in information:\n\nFind the component class that is going to receive that information.\nInclude this.props.name-of-information in that component class’s render method’s return statement.\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\n\nclass Greeting extends React.Component {\n  render() {\n    return <h1>Hi there, {this.props.firstName}!</h1>;\n  }\n}\n\n\nReactDOM.render(<Greeting firstName=\"Rybu\" />, document.getElementById('app'));"},{"title":"Virtual DOM","description":"In React, Virtual DOM is a conceptual representation of the actual DOM object, like a lightweight copy. A virtual DOM object has the same properties as a real DOM object, but it lacks the real thing’s power to directly change what’s on the screen.\n\nManipulating the DOM is slow. Manipulating the virtual DOM is much faster, because nothing gets drawn onscreen. Think of manipulating the virtual DOM as editing a blueprint, as opposed to moving rooms in an actual house.\n\nWith Virtual DOM, when changes are made to the UI and there’s a re-render, they are compared to the relevant branches in the DOM-tree. Then, the changes are applied to the DOM-tree.\n\nThe Virtual DOM is not to be confused with the Shadow DOM, or any other technology or concept.\n\nHow It Works\n\nWhen you render a JSX element, every single virtual DOM object gets updated. This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM can update so quickly. Once the virtual DOM has updated, then React compares the virtual DOM with a virtual DOM snapshot that was taken right before the update.\n\nBy comparing the new virtual DOM with a pre-update version, React figures out exactly which virtual DOM objects have changed. This process is called “diffing.”\n\nOnce React knows which virtual DOM objects have changed, then React updates those objects, and only those objects, on the real DOM. For example, if we are making changes to a list item, React would be smart enough to rebuild your one checked-off list item, and leave the rest of your list alone.\n\nThis makes a big difference! React can update only the necessary parts of the DOM. React’s reputation for performance comes largely from this innovation.\n\nIn summary, here’s what happens when you try to update the DOM in React:\n\nThe entire virtual DOM gets updated.\nThe virtual DOM gets compared to what it looked like before you updated it. React figures out which objects have changed.\nThe changed objects, and the changed objects only, get updated on the real DOM.\nChanges on the real DOM cause the screen to change."},{"title":"State","description":"The state object is where we store data in a component that is expected to change over time. When the state object changes, the component re-renders.\n\nProps are passed down by parent components, whereas state is created and maintained by the component itself.\n\nClass and functional components handle state differently. Functional components use hooks to manage state. The following will address how class components manage state.\n\nCreating the state Object\n\nThe state object is initialized in the component’s constructor():\n\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n    // The state object\n    this.state = {\n      brand: 'Chevrolet',\n      model: 'Malibu',\n      color: 'white',\n      year: 1998,\n    };\n  }\n  render() {\n    return (\n      <div>\n        <h1>My First Car</h1>\n      </div>\n    );\n  }\n}\nUsing the state Object\n\nRefer to the state object in the render() method:\n\nclass Car extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      brand: 'Chevrolet',\n      model: 'Malibu',\n      color: 'white',\n      year: 1998,\n    };\n  }\n  render() {\n    return (\n      <div>\n        <h1>My First Car</h1>\n        <p>\n          It is a {this.state.color}\n          {this.state.brand}\n          {this.state.model}\n          made in {this.state.year}. 🚙\n        </p>\n      </div>\n    );\n  }\n}\n\nIt will appear like this:\n\nCaution\n\nWhen React component’s state is updated, it will automatically re-render. This means that the state should never be updated in a render() method because it will cause an infinite loop."}],"Ruby":[{"title":"Casting","description":"In Ruby, the language comes with a variety of building typecasting methods for conerting values from one data type to another.\n\nSyntax\n\nFor the most part methods usually begin with to_[data-type].\n\nTo Integer\n\nTo convert from String to Integer, use to_i:\n\nmeaning_of_life = \"42\"\n\n\nputs meaning_of_life.class # Output: String\n\n\nmeaning_of_life = meaning_of_life.to_i\n\n\nputs meaning_of_life.class # Output: Integer\nTo Float\n\nTo convert from String to Float-type, use to_f:\n\nmeaning_of_life = \"42.0\"\n\n\nputs meaning_of_life.class # Output: String\n\n\nmeaning_of_life = meaning_of_life.to_f\n\n\nputs meaning_of_life.class # Output: Float\nTo Array\n\nTo convert an Object to an Array, use to_a:\n\nmyObj = {\n  name: \"Denise\",\n  occupation: \"Software Engineer\"\n}\n\n\nputs myObj.to_a\n\nThe output would be:\n\nname\nDenise\noccupation\nSoftware Engineer"},{"title":"Arrays","description":"Arrays store data values in a list. An array can contain any data type. Values are comma separated and enclosed in square brackets. Elements in the array start at an index of 0.\n\nCreating Arrays with new Class Method\n\nThis method will create an array with zero, one or two arguments. No arguments will create an empty array. A single argument will determine the size of the array. Two arguments will determine the size of the array and the second argument will populate the array with that value.\n\n# Create an array without any arguments\narray1 = Array.new\n\n\nputs array1.length\n# Output: 0\n\n\n# Create an array with a length of seven\narray2 = Array.new(7)\n\n\nputs \"#{array2}\"\n# Output: [nil, nil, nil, nil, nil, nil, nil]\n\n\nputs array2.length\n# Output: 7\n\n\n# Create an array with four arguments\narray3 = Array.new(4, \"hello\")\n\n\nputs \"#{array3}\"\n# Output: [\"hello\", \"hello\", \"hello\", \"hello\"]\nCreating Arrays Literals\n\nThe literal constructor [] can also be used to create an array. Between the brackets, you can use a comma separated list of values. The values types may be any type of data.\n\n countdown = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n puts \"#{countdown}\"\n # Output: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\n puts countdown.length\n # Output: 10\n\n\n puts countdown.size\n # Output: 10\nAccessing Elements in Arrays\n\nThere are a few ways to access elements in an array. A common way is to use the index of an array to access an element.\n\nhaystack1 = [\"hay\", \"hay\", \"needle\", \"hay\", \"hay\"]\n\n\nputs haystack1[2]\n# Output: \"needle\"\n\n\nputs haystack1[-3]\n# Output: \"needle\"\n\n\n# A second value can be passed in to select the number of elements to return\nhaystack2 = [\"hay\", \"hay\", \"needle\", \"needle\", \"hay\"]\n\n\nputs haystack2[2, 2]\n# Output: needle\n# Output: needle"},{"title":"Classes","description":"Classes are like blueprints for creating objects. Objects are often called instances of a class. Classes define the properties and methods that objects created from them will have. For example, a ball is a class and baseball, football, and basketball are instances of the ball class.\n\nDefining a Class\n\nThe class keyword followed by a name with the first letter capitalized creates a new class. The end keyword ends the class definition. Objects, or instances of the class, are created by calling the new method on the class.\n\n# Class name is Ball\nclass Ball\n  # Properties and methods of the class\nend\n\n\n# Create two instances of the Ball class\nball1 = Ball.new\nball2 = Ball.new\n\n\n# Print the class of ball1 and ball2\nputs ball1.class\nputs ball2.class\n\nThe output would look something like:\n\nBall\nBall\nPassing Parameters to new Method\n\nThe new method is passed parameters when it is called. The parameters are assigned to the properties of the class.\n\n# Class name is Ball\nclass Ball\n\n\n  # Initialize method - called whenever a new object is created\n  def initialize(name, size, shape, color)\n    @name = name\n    @size = size\n    @shape = shape\n    @color = color\n\n\n    puts \"The #@name is #@size and #@shape and looks #@color.\"\n  end\n\n\nend\n\n\n# Create two instances of the Ball class\nball1 = Ball.new(\"basketball\", \"medium\", \"round\", \"orange\")\nball2 = Ball.new(\"football\", \"medium\", \"oblong\", \"brown\")\nball3 = Ball.new(\"soccer ball\", \"medium\", \"round\", \"black and white\")\n\nThe output would look something like:\n\nThe basketball is medium and round and looks orange.\nThe football is medium and oblong and looks brown.\nThe soccer ball is medium and round and looks black and white."},{"title":"Comments","description":"Commenting code helps programmers write free text that is commonly used to explain the code written, or can even be used to add TO-DOs to the code.\n\nSingle-line Comments\n\nSingle-line comments start with a #.\n\n# I am a single line comment.\nMulti-line comments\n\nMulti-line comments start with =begin and end with =end.\n\n=begin\nI am a multi line comment.\nI can take as many lines as needed.\n=end"},{"title":"Conditionals","description":"Conditionals control the flow of execution of your program based on conditions that you define. Conditionals are the decision-making statements in your program.\n\nIf Statements\n\nDecides if a block of code will be executed or not based on whether a condition is true.\n\nage = 17\n\n\nif (age >= 16)\n  puts \"You are eligible to get your driver's license.\"\nend\n\n\n# Output: You are eligible to get your driver's license.\nIf - Else Statements\n\nIf the condition in an if statement is false, the block of code in the else statement will be executed.\n\n\n\nage = 15\n\n\nif (age >= 16)\n  puts \"Can you drive me to the store?\"\nelse\n  puts \"Can you walk with me to the store?\"\nend\n\n\n# Output: Can you walk with me to the store?\nIf - Elseif - Else Statements\n\nIf the if statement is not true, the block of code in the elseif statement will be executed if the condition is true. There may me multiple elseif statements. Finally, if none of the conditions are true, the block of code in the else statement will be executed.\n\nage1 = 35\nage2 = 26\nage3 = 19\nage4 = 17\nage5 = 15\n\n\ndef things_you_can_do(age)\n  if (age >= 35)\n    puts \"You can run for president.\"\n  elsif (age >= 25)\n    puts \"You can rent a car.\"\n  elsif (age >= 18)\n    puts \"You can vote.\"\n  elsif (age >= 16)\n    puts \"You can get a driver's license.\"\n  else\n    puts \"You still have your youth!\"\n  end\nend\n\n\nthings_you_can_do age1\nthings_you_can_do age2\nthings_you_can_do age3\nthings_you_can_do age4\nthings_you_can_do age5\n\n\n# Output: You can run for president.\n# Output: You can rent a car.\n# Output: You can vote.\n# Output: You can get a driver's license.\n# Output: You still have your youth!\nTernary Statements\n\nA shorter version of the if statement. It will evaluate an expression, if true, it will execute the code following the ?. If false, execute the code following the :.\n\n# Example of condition evaluating to true\nage1 = 19\n\n\ncan_vote = (age1 >= 18) ? \"You can vote.\" : \"You can't vote.\"\n\n\nputs can_vote\n# Output: You can vote.\n\n\n# Example of condition evaluating to false\nage2 = 17\n\n\ncan_vote = (age2 >= 18) ? \"You can vote.\" : \"You can't vote.\"\n\n\nputs can_vote\n# Output: You can't vote."},{"title":"Data Types","description":"Data types represent different types of data such as numbers, booleans, strings, etc. As an object-oriented language, all data types are based on classes.\n\nNumbers\n\nRuby has different types of numbers such as integers and floating point numbers.\n\n# Integer type\ncount = 1\n\n\n# Float type\nrating = 1.5\n\n\n# Both float and integer types\nmiles = 127\nhours = 2.5\nmiles_per_hour = miles / hours\n\n\nputs \"Miles per hour: #{miles_per_hour}\"\n# Output: Miles per hour: 50.8\nBooleans\n\nA value of either true or false.\n\ntemp = 100\nisHot = temp > 80\n\n\nputs isHot\n# Output: true\n\n\nif isHot\n  puts \"Better wear shorts today!\"\nelse\n  puts \"Better wear long pants today!\"\nend\n\n\n# Output: Better wear shorts today!\nStrings\n\nA string is a sequence of characters that represents a word or a sentence. They are created by surrounding a sequence of characters with single or double quotes.\n\nputs \"Hello World!\"\nputs 'Hello World!'\nArrays\n\nArrays store data in a list. An array can contain any type of data. Values are comma separated and enclosed in square brackets. Positions in the array start at 0.\n\nmixed_array = [true, 2, \"three\", 4.0]\n\n\nputs \"The first element is: #{mixed_array[0]}\"\n# Output: The first element is: true\n\n\nHashes\n\nA collection of key-value pairs enclosed within curly braces. Values are assigned to keys using the => syntax.\n\nperson = {\n  first_name: \"Kara\",\n  last_name: \"Brennan\",\n  age: 29\n}\n\n\nputs \"#{person[:first_name]} #{person[:last_name]} is #{person[:age]} years old.\"\n# Output: Kara Brennan is 29 years old.\nSymbols\n\nSymbols are a unique data type in Ruby. They are similar to strings except that they take up less memory and have better performance. Symbols are created by using the : syntax.\n\nbasketball_team = {:center => \"Shaquille O'Neal\", :forward => \"LeBron James\", :guard => \"Steph Curry\"}\n\n\nputs basketball_team[:center]\n# Output: Shaquille O'Neal\n\n\nputs basketball_team[:forward]\n# Output: LeBron James\n\n\nputs basketball_team[:guard]\n# Output: Steph Curry"},{"title":"Errors","description":"Ruby uses exceptions to report errors and other information when something in the program has gone wrong.\n\nIf an error has ocurred, the Ruby program will end. For example:\n\nputs 2 / 0\n\nThis will result in:\n\nTraceback (most recent call last):\n        1: from errors_in_ruby.rb:1:in `<main>'\nerrors_in_ruby.rb:1:in `/': divided by 0 (ZeroDivisionError)\n\nSome common errors are:\n\nRuntimeError\nStandardError\nNoMethodError\nIOError\nTypeError\nArgumentError\nRescuing Errors\n\nUse the rescue keyword in a begin...end block to catch errors and report messages. The error can be as general as StandardError or as specific as ZeroDivisionError:\n\nbegin\n  puts 2 / 0\nrescue ZeroDivisionError\n  puts \"Can't divide by 0\"\nend"},{"title":"Dates","description":"In Ruby, date- and time-specific data are handled by two classes:\n\nDate\nDateTime\n\nIn order to use these classes, import the date module:\n\nrequire(\"date\")\nSyntax\n\nTo create a new Date object, use .new():\n\n# With 1 argument\nmyDate = Date.new(year)\n\n\n# With 2 arguments\nmyDate = Date.new(year, month)\n\n\n# With 3 arguments\nmyDate = Date.new(year, month, day)\n\n\nmyDate = Date.new(2021, 07, 30)\n\n\nputs myDate # Output: 2021-07-30\n\nTo create a new DateTime object, use .new():\n\nrequire(\"date\")\n\n\nmyDateTime = DateTime.new(year, month, day, hour, minute, second, offset)\n\n\nmyDateTime = DateTime.new(2021, 07, 30, 13, 46, 45, \"+4\")\n\n\nputs myDateTime # Output: 2021-07-30T13:46:45+04:00\n\nTo create a new DateTime object set to this very moment, use .now():\n\nputs DateTime.now # Output: 2021-07-30T13:48:56-04:00"},{"title":"Functions","description":"Functions are a set of instructions that return one value. Functions that exist in an object are typically called methods.\n\nFunction Basics\n\nA function is declared using the def keyword. We close a function with the end keyword.\n\ndef greeting\n  puts \"Hello, World!\"\n  return\nend\n\n\n# Output: Hello, World!\n# Output => nil\nFunctions with Parameters\n\nFunctions can take parameters. Parameters are variables that are passed into a function.\n\ndef greeting(name)\n  puts \"Hello, #{name}!\"\n  return\nend\n\n\ngreeting(\"John\")\n# Output: Hello, John!\n# Output => nil\n\n\n# Parentheses are optional when calling a function\ngreeting \"Mary\"\n# Output: Hello, Mary!\n# Output => nil\nExplicit and Implicit Return\n\nIf the return keyword is not used, the last expression in the function will be returned.\n\ndef greeting(name)\n  return \"Hello, #{name}!\"\nend\n\n\ngreeting(\"John\")\n# Output: => Hello, John!\n\n\n# Returns the value of the last expression evaluated\ndef greeting(name)\n  \"Hello, #{name}!\"\nend\n\n\ngreeting(\"Mary\")\n# Output: => Hello, Mary!\nDefault Values\n\nDefault values may be provided and will be used if no argument is passed to our function.\n\ndef greeting(name=\"human\")\n  return \"Hello, #{name}!\"\nend\n\n\ngreeting\n# Output: => Hello, human!"},{"title":"Files","description":"The File class is used for working with file objects in Ruby.\n\nCreate a New File\n\nTo create a new File object, use the .new() method and pass in:\n\nA string name for the new file.\nA mode to indicate which operations can be done to the file.\n\nCommon modes include the following:\n\nModes\tDescription\nr\tRead: Start from the beginning of the file.\nr+\tRead and write: Start from the beginning of the file.\nw\tWrite: Start from the beginning of the file.\nw+\tRread and write: Overwrite the existing or create a new one.\na\tAppend (write-only): Start writing from the end of the existing file or create a new one.\na+\tAppend (read and write): Start reading and/or writing from the end of the existing file or create a new one.\n\nThis new File object can be assigned to its own variable, like in the example below:\n\nexample_file = File.new(\"exampleFile.txt\", \"w\")\n\n\nputs example_file\n# Output: #<File:0x00007fab5113b790>\nOpen and Close a File\n\nTo open a file, use the .open() method:\n\nFile.new(\"exampleFile.txt\", \"w\")\n\n\nFile.open(\"exampleFile.txt\", \"r\")\n\nTo close the file, use the .close method:\n\nexample_file.close\n\nWhen using .open() with a do...end block, the file will .close at the end.\n\nFile.open(\"exampleFile.txt\", \"w+\") do |f|\n  ...\nend\nRead and Write to a File\n\nSince it’s related to the IO class, the File class can read and write files. It’s important to mention that the file must be opened before reading or writing can start. It must also be closed afterward.\n\nTo just write to a file, use the w mode:\n\nexample_file = File.open(\"exampleFile.txt\", \"w\")\n\n\nFile.write(\"exampleFile.txt\", \"This is some text.\")\n\n\nexample_file.close\n\nTo just read an (opened) file, use the r mode:\n\nexample_file = File.open(\"exampleFile.txt\", \"r\")\n\n\nputs example_file.read\n# Output: This is some text.\n\n\nexample_file.close"},{"title":"Gems","description":"In Ruby, gems are open-source Ruby libraries or applications that lend extra utility to other Ruby programs. Each gem is composed of the following:\n\nThe source code it was built with (including any tests).\nAny documentation with metadata such as the name, version, and platform.\nA .gemspec file holding all Gem-related metadata.\n\nGems can be referenced, installed, and published from an online registry called RubyGems.\n\nTo install gems to the local machine:\n\ngem install name-of-gem\n\nTo display a list of previously installed gems:\n\ngem list\n\nSome popular Ruby gems include:\n\nRuby on Rails for building robust, full-stack web applications.\nActive Record for object-relational database management in Rails.\nPry for REPL-style inspection of programs at runtime.\nOmniAuth for third-party authentication in applications.\nSinatra for a building relatively minimal, light websites.\n\nGems can be represented in a Gemfile either in general or with a specific version:\n\nsource 'https://rubygems.org'\n\ngem 'pry'\ngem 'rails', '3.0.0.beta3'\ngem 'omniauth',  '>=1.0'"},{"title":"Hashes","description":"A collection of key-value pairs enclosed within curly braces. Values are assigned to keys using the => syntax.\n\nCreating Hash with new Class Method\n\nThis will create an empty hash with no default values. Default values may also be provided.\n\n# Create a new empty hash\nempty_hash = Hash.new\n\n\nputs empty_hash.inspect\n# Output: {}\n\n\nputs \"#{empty_hash[1]}\"\n# An empty hash will have nothing to display\n\n\n# Create a new hash with a default value\nhash_default = Hash.new(\"Codecademy\")\n\n\nputs hash_default.inspect\n# Output: {}\n\n\n# An empty hash will return the default value\nputs \"#{hash_default[4]}\"\n# Output: Codecademy\nCreating Hash Literals\n\nA hash literal is created by enclosing a list of key-value pairs between curly braces.\n\nprogramming_languages = {\"key1\" => \"Ruby\", \"key2\" => \"Python\", \"key3\" => \"Java\", \"key4\" => \"C++\", \"key5\" => \"C#\"}\n\n\nputs programming_languages.inspect\n# Output: {\"key1\"=>\"Ruby\", \"key2\"=>\"Python\", \"key3\"=>\"Java\", \"key4\"=>\"C++\", \"key5\"=>\"C#\"}\n\nRetrieving a hash value involves putting the required key between square brackets ([]).\n\nprogramming_languages = {\"key1\" => \"Ruby\", \"key2\" => \"Python\", \"key3\" => \"Java\", \"key4\" => \"C++\", \"key5\" => \"C#\"}\n\n\nputs programming_languages[\"key1\"]\n# Output: Ruby\n\nChanging a hash value involves putting the required key between square brackets ([]) and assigning a new value.\n\nprogramming_languages = {\"key1\" => \"Ruby\", \"key2\" => \"Python\", \"key3\" => \"Java\", \"key4\" => \"C++\", \"key5\" => \"C#\"}\n\n\n# print original value of \"key1\"\nputs programming_languages[\"key1\"]\n# Output: Ruby\n\n\n# change value of \"key1\"\nprogramming_languages[\"key1\"] = \"Ruby on Rails\"\n\n\nputs programming_languages[\"key1\"]\n# Output: Ruby on Rails"},{"title":"Inheritance","description":"In Ruby, inheritance describes the relation between classes.\n\nSyntax\n\nInheritance is expressed when the < is used to connect the parent class, Animal, with the child class, Dog:\n\nclass Animal\n  def initialize(species)\n    @species = species\n  end\n\n\n  def species\n    @species\n  end\nend\n\n\nclass Dog < Animal\n  def initialize(species, name)\n    super(species)\n    @name = name\n  end\nend\n\n\nsnoop = Dog.new(\"Long-Beach Labrador\", \"Calvin\")\n\n\nputs snoop.species # Output: Long-Beach Labrador\n\nThe Dog class inherits all the methods from its parent Animal class, including .species.\n\nOverriding Methods\n\nAn inheriting child class can override methods defined in its parent and replace with code specific to it:\n\nclass Animal\n  def initialize(species)\n    @species = species\n  end\n\n\n  def species\n    @species\n  end\n\n\n  def make_sound\n    \"The animal made a sound that was hard to tell.\"\n  end\nend\n\n\nclass Dog < Animal\n  def initialize(species, name)\n    super(species)\n    @name = name\n  end\n\n\n  def name\n    @name\n  end\n\n\n  def make_sound\n    \"Bark!\"\n  end\nend\n\n\nsnoop = Dog.new(\"Long-Beach Labrador\", \"Calvin\")\n\n\nputs snoop.make_sound # Output: Bark!\n\nThe .make_sound method from Animal was overridden in Dog with a return string specific to that class."},{"title":"Iterators","description":"Iterators are used to do one thing multiple times. They are used in tandem with collections (Hashes, Arrays, etc…). A collection is an object that stores a group of data members.\n\nEach Iterator\n\nReturns all elements in a range, array or hash. Values are returned in the order they are stored in the collection.\n\nletters = ['C', 'o', 'd', 'e', 'c', 'a', 'd', 'e', 'm', 'y']\n\n\nletters.each do|letter|\n  puts letter\nend\nOur collection, letters, is an array.\nThe each is a method that iterates through the collection.\nThe do and end are used to indicate the scope of the each method.\nletter is a variable that is used to store the value of each iteration.\n\nThe output would be:\n\nC\no\nd\ne\nc\na\nd\ne\nm\ny\nCollect Iterator\n\nRuns on all the elements in a collection. Returns the entire collection.\n\nnumbers = [1, 2, 3, 4, 5]\n\n\nnumbers_squared = numbers.collect {|number| number * number}\n\n\nputs numbers_squared\n# Output: [1, 4, 9, 16, 25]\nThe collect method is a method that iterates through the numbers array.\nnumber is a variable that is used to store the value of each iteration.\nTimes Iterator\n\nThis iterator is a loop designed to repeat a block of code a certain number of times. May or may not use an iteration variable.\n\n5.times do |i|\n  puts \"Message number #{i + 1}\"\nend\n5.times is the specified number of times to repeat the block of code.\n\nThe output would be:\n\nMessage number 1\nMessage number 2\nMessage number 3\nMessage number 4\nMessage number 5"},{"title":"Lambda","description":"In Ruby, lambdas are anonymous function code blocks that can take zero or more arguments. They can then be stored or passed in other values and called primarily with the #call method.\n\nSyntax\n\nIf zero arguments are used, use either -> or lambda:\n\nmyLambda = lambda { puts \"Hello, World!\" }\n\n\nputs myLambda.call # Output: Hello, World!\n\nIf 1 or more arguments are used, use ->:\n\nmyLambda = -> (v) { v * 2 }\n\n\nputs myLambda.call(2) # Output: 4"},{"title":"Loops","description":"Loops are used to repeat a task a number of times. A loop runs a set of instructions or functions a given amount of times as long as a condition is met. The most common loop in Ruby is the for loop. Other loops are while, until, and do...while.\n\nFor Loops\n\nThis loop is utilized when you know beforehand how many times you want to repeat the task.\n\nfor i in 1..5 do\n  puts \"Message number #{i}\"\nend\nThe for keyword indicates the beginning of a loop.\ni is our variable.\nThe in keyword indicates the range of numbers you want to loop over.\nThe do keyword indicates the instructions you want to repeat.\nThe end keyword indicates the end of the loop.\n\nThe output would be:\n\nMessage number 1\nMessage number 2\nMessage number 3\nMessage number 4\nMessage number 5\nWhile Loops\n\nThe for loop is used when you know how many times you want to repeat the task, the while loop is used when you don’t know how many times you want to repeat the task.\n\ni = 1\n\n\nwhile i <= 5 do\n  puts \"Message number #{i}\"\n  i = i + 1\nend\nThe while keyword indicates the beginning of a loop.\ni <= 5 indicates that the loop will continue as long as i is less than or equal to 5.\nThe do keyword indicates the instructions you want to repeat.\nThe end keyword indicates the end of the loop.\n\nThe output would be:\n\nMessage number 1\nMessage number 2\nMessage number 3\nMessage number 4\nMessage number 5\nDo…While Loops\n\nThe do...while loop is used when you don’t know how many times you want to repeat the task. The while loop is used when you want to check a condition before the first loop. do...while loops are used when you want to check a condition in the loop body after executing the statements. the do...while loop will run at least once.\n\ni = 1\n\n\nloop do\n  puts \"Message number #{i}\"\n\n\n  i = i + 1\n  if i == 6\n    break\n  end\nend\nThe loop keyword indicates the beginning of a loop.\nif i == 6 is the condition that will break the loop.\nThe do keyword indicates the instructions you want to repeat.\nThe end keyword indicates the end of the loop.\nThe break keyword indicates the end of the loop.\n\nThe output would be:\n\nMessage number 1\nMessage number 2\nMessage number 3\nMessage number 4\nMessage number 5\nUntil Loops\n\nThe for loops, while loops, and do...while loops run until a condition is no longer true. The until loops run until a condition is true.\n\ni = 1\n\n\nuntil i == 6 do\n  puts \"Message number #{i}\"\n  i = i + 1\nend\nThe until keyword indicates the beginning of a loop.\ni == 6 is the condition that will end the loop when true.\nThe do keyword indicates the instructions you want to repeat.\nThe end keyword indicates the end of the loop.\n\nThe output would be:\n\nMessage number 1\nMessage number 2\nMessage number 3\nMessage number 4\nMessage number 5"},{"title":"Modules","description":"In Ruby, modules are collections of classes, methods, and constants. They lend extra functionality to classes that include them.\n\nSyntax\n\nModules are defined with a module...end block. For example:\n\nmodule ModuleName\n  include OtherModule\n\n\n  CONSTANT = 123\n\n\n  def method_1\n    ...\n  end\n\n\n  def method_2\n    ...\n  end\nend\nUsage in a Class\nmodule TwoTermSolver\n  def add(a, b)\n    a + b\n  end\n\n\n  def subtract(a, b)\n    a - b\n  end\n\n\n  def multiply (a, b)\n    a * b\n  end\n\n\n  def divide(a, b)\n    begin\n      a / b\n    rescue ZeroDivisionError\n      puts \"Division by zero (0) is not allowed.\"\n    end\n  end\nend\n\n\nclass Calculator\n  include TwoTermSolver\nend\n\n\nputs Calculator.new.add(3, 4) # Output: 7"},{"title":"Modulo","description":"A Ruby function that returns the modular value, the remainder, when two numbers are divided.\n\nSyntax\nx.modulo(y)\nwhere x is the dividend and y is the divisor. Two values are required.\nExample 1\nputs 5.modulo(3)\n# Output: 2\n5 is divided by 3 and the remainder is 2.\nExample 2\nputs 10.modulo(3)\n# Output: 1\n10 is divided by 3 and the remainder is 1."},{"title":"Random","description":"The rand function will return a random number greater than or equal to 0 and less than the integer passed to the function. If an argument is not passed to the function, the return value is a random number between 0 and 1.\n\nExample\n# When no argument is passed, the result is a random number between 0 and 1.\nputs rand();\n# Output example: 0.5\n\n\n# When an argument is passed, the result is a random number between 0 and the argument.\nputs rand(10);\n# Output example: 6"},{"title":"Operators","description":"Arithmetic Operators\n\nBasic math operations can be applied to integer and floating point values:\n\n+ addition\n- subtraction\n* multiplication\n/ division\n% modulo (yields the remainder)\na = 30;\nb = 20;\n\n\nputs a + b\n# Output: 50\n\n\nputs a - b\n# Output: 10\n\n\nputs a * b\n# Output: 600\nputs a / b\n# Output: 1.5\nputs a % b\n# Output: 10\nComparison Operators\n\nComparison operators can be used to compare two values:\n\n> greater than\n< less than\n>= greater than or equal to\n<= less than or equal to\n== equal to\n!= not equal to\n\nThe result of a comparison is a boolean value true or false:\n\na = 5;\nb = 3;\n\n\nputs a > b;\n# Output: true"},{"title":"RegExp","description":"In Ruby, Regular Expressions (shortened as RegExp), are used to describe and match patterns in strings. This functionality is housed in the Regexp class.\n\nSyntax\n\nRegular expressions can be created in three ways:\n\n# With / /\nregexp1 = /code/\n\n\n# With %r{ }\nregexp2 = %r{code}\n\n\n# With Regexp.new()\nregexp3 = Regexp.new(\"code\")\nFinding Patterns in Strings\n\nTo see if a given string matches a regular expression, use .match().\n\nputs regexp1.match(\"codecademy\") # Output: code\n\nTo test if there even was a match (true or false), use .match?():\n\nputs regexp1.match?(\"codecademy\") # Output: true"},{"title":"Scope","description":"In Ruby, variables have a scope that outlines what other variables and methods are available to them versus which ones are not. There are different levels of scope:\n\nClass-level\nInstance-level\nGlobal-level\nLocal-level\nClass-level\n\nVariables defined at the class-level scope are usually marked with @@. They are available for use anywhere within the class block or any sub-class blocks:\n\nclass MyClass\n  @@class_variable = \"This is the Class variable\"\n\n\n  def inner_method\n    \"From MyClass: #{@@class_variable}\"\n  end\nend\n\n\nclass SubClass < MyClass\n  def display_class_variable\n    \"From SubClass: #{@@class_variable}\"\n  end\nend\n\n\n\n\nclassInstance = MyClass.new()\n\n\nsubClassInstance = SubClass.new()\n\n\nputs subClassInstance.display_class_variable\n# Output: From SubClass: This is the Class variable\n\n\nputs classInstance.inner_method\n# Output: From MyClass: This is the Class variable\nInstance-level\n\nVariables defined at the instance-level scope are usually marked with @ and created within a class’s initialize method. They are available for whenever an instance of the class if was defined in is used:\n\nclass Person\n  def initialize(name)\n    @name = name\n  end\n\n\n  def name\n    @name\n  end\nend\n\n\nperson = Person.new(\"Randy\")\n\n\nputs person.instance_variables # Output: @name\nputs person.name # Output: Randy\nGlobal-level\n\nVariables defined in the global scope can be access anywhere within the Ruby program. Their names start with $:\n\n$global_number = 42\n\n\ndef show_numbers\n  puts [$global_number]\nend\n\n\nshow_numbers # Output: 42\nLocal-level\n\nVariables defined at the local scope are the most contextual; whichever block they are defined in usually determines how far their scope reaches.\n\nBelow, local_to_outside_method is local to the general, global scope of the program. Inside the add_numbers() method is a variable whose scope exists only within the method, local_to_method:\n\nlocal_to_outside_method = 32\n\n\ndef add_numbers(outside_term)\n  local_to_method = 42\n  outside_term + local_to_method\nend\n\n\nputs local_to_outside_method + add_numbers(3) # Output: 77"},{"title":"Sets","description":"In Ruby, a Set is a collection of uordered, non-duplicated values. They are functional like an Array but have quick lookup with Hash-storage.\n\nSyntax\n\nIn order to use Sets:\n\nImport the set module with require()\nUse the Set keyword followed by brackets ([]) containing comma-separated values\nrequire(\"set\")\n\n\ntest_set = Set[1, 2]\n\n\nputs test_set # Output: #<Set: {1, 2}>\nExample\n\nValues can be added to Sets with #add():\n\ntest_set.add(\"It's a Beautiful Day!\")\n\n\nputs test_set\n\nThey can also be deleted with #delete(). Pass in the actual value. If the value doesn’t exist in the Set, nothing happens to it:\n\ntest_set.delete(2)\n\n\nputs test_set # Output: #<Set: {1, \"It's a Beautiful Day!\"}>\n\n\ntest_set.delete(100)\n\n\nputs test_set # Output: #<Set: {1, \"It's a Beautiful Day!\"}>\n\nSince Sets are array- and hash-like, they are iterable and can use methods like each:\n\nrequire(\"set\")\n\n\ntest_set = Set[1, 2]\n\n\ntest_set.add(3)\ntest_set.add(\"It's a Beautiful Day!\")\n\n\ntest_set.each do |element|\n  puts element\nend"},{"title":"Strings","description":"A string is a sequence of one or more characters that represents a word or a sentence. It may contain letters, numbers, or symbols. They are created by surrounding a sequence of characters with single or double quotes. Strings are mutable, which means that they can be changed.\n\nCreating Strings\n\nA string can be created by using the \" (double quotes) or ' (single quotes) around a sequence of characters.\n\nputs 'String created using single quotes.'\nputs \"String created using double quotes.\"\n# Output: String created using single quotes.\n# Output: String created using double quotes.\nString Interpolation\n\nDouble quotes allow variable interpolation. This means that you can use a variable inside a string.\n\nfavorite_color = \"blue\"\n\n\nputs \"My favorite color is #{favorite_color}.\"\n# Output: My favorite color is blue.\nfavorite_color = \"blue\"\n\n\nputs 'Cannot interpolate #{favorite_color} with single quotes.'\n# Output: Cannot interpolate #{favorite_color} with single quotes.\nStrings are Objects\n\nStrings are objects. They have methods that can be invoked on them.\n\ngreeting = \"Hello, neighbor\"\ngreeting_shout = greeting.upcase\n\n\nputs greeting_shout\n# Output: \"HELLO, NEIGHBOR\"\nAccessing Elements within a String\n\nSquare brackets ([]) can be used to access elements within a string by passing in indexes or ranges.\n\n# access element at index 3\ngreeting = \"Hello, world!\"\n\n\nputs greeting[3]\n# Output: l\n\n\n# access element at the end of string with negative index\ngreeting = \"Hello, world!\"\n\n\nputs greeting[-1]\n# Output: !\n\n\n# access a range of elements\ngreeting = \"Hello, world!\"\nfirst_word = greeting[0..4]\n\n\nputs first_word\n# Output: Hello\n\n\n# two comma separated values will indicate the starting index and the number of elements to be accessed\ngreeting = \"Hello, world!\"\nsecond_word = greeting[7, 5]\n\n\nputs second_word\n# Output: world\nMulti-line Strings\n\nMulti-line strings can be created by using \", %//, and <<STRING STRING syntax.\n\nputs \"First string\"\n\n\n# Multi-line with `\"\"`\nputs \"\"\n\n\n# Multi-line with `%//`\nputs %/Second string/\n\n\n# Multi-line with `<<STRING STRING`\nputs <<STRING\n\n\nIn Ruby, a user can create the multiline\nstrings easily where into other programming\nlanguages creating multiline strings\nrequires a lot of efforts\nSTRING\n\nThe output would be:\n\n=begin\nFirst string\n\nSecond string\n\nThird string\nString Replication\n\nReplicating a string is done with the * operator. The operator is preceded by the string to be replicated and followed by the number of times to replicate the string.\n\ntongue_twister = \"Sally sells seashells by the seashore \"\n\n\nputs tongue_twister * 5\n\nThe output would be:\n\nSally sells seashells by the seashore Sally sells seashells by the seashore Sally sells seashells by the seashore Sally sells seashells by the seashore"},{"title":"Variables","description":"A variable is a label that Ruby assigns to a particular object. There are four different types of variables in Ruby. Each type starts with a special character to indicate the type of variable it is.\n\nLocal Variables\n\nLocal variables must begin with a lowercase letter or _. These variables are local to the code block of the method they are declared in.\n\ncolor = \"green\"\n_person = \"Shannon\"\n\nThere is nothing special about the word color in this line of code. It’s just a variable name. You could set pizza = \"green\". While that variable name choice might be misleading to the human reading it, the value would still be \"green\".\n\nInstance Variables\n\nInstance variables begin with an @ symbol. Instance variables are variables that belong to an object.\n\nclass Person\n\n\n def initialize(first, middle, last)\n\n\n   # Instance Variables\n   @first_name = first\n   @middle_name = middle\n   @last_name = last\n end\n\n\n # Displaying result\n def display_full_name()\n   puts \"Full name:  #@first_name #@middle_name #@last_name\"\n end\nend\n\n\n# Create Objects\nperson1 = Person.new(\"Alexandra\", \"Smith\", \"Johnson\")\nperson2 = Person.new(\"Marcus\", \"Alonzo\", \"Thomas\")\n\n\n# Call Methods\nperson1.display_full_name()\nperson2.display_full_name()\n\n\n# Output: Full name: Alexandra Smith Johnson\n# Output: Full name: Marcus Alonzo Thomas\nClass Variables\n\nClass variables begin with an @@ sign. Class variables are available across different objects shared by all the descendants of the class. They must be initialized before use.\n\nclass Person\n\n\n # Class variable\n @@number_of_people = 0\n\n\n def initialize(first, middle, last)\n  @first_name = first\n  @middle_name = middle\n  @last_name = last\n end\n\n\n # displaying result\n def display_full_name()\n  puts \"Full name:  #@first_name #@middle_name #@last_name\"\n end\n\n\n def total_no_of_people()\n   # class variable\n   @@number_of_people += 1\n   puts \"Total number of people: #@@number_of_people\"\n end\nend\n\n\n# Create Objects\nperson1 = Person.new(\"Alexandra\", \"Smith\", \"Johnson\")\nperson2 = Person.new(\"Marcus\", \"Alonzo\", \"Thomas\")\n\n\n# Call Methods\nperson1.display_full_name()\nperson1.total_no_of_people()\nperson2.display_full_name()\nperson2.total_no_of_people()\n\n\n# Output: Full name: Alexandra Smith Johnson\n# Output: Total number of people: 1\n# Output: Full name: Marcus Alonzo Thomas\n# Output: Total number of people: 2\nGlobal Variables\n\nGlobal variables begin with an $ symbol. While Class variables are not available across different classes, global variables are. Its scope is global, meaning that it can be accessed from anywhere in the program.\n\n# Global variable\n$global_variable_starting_score = 0\n\n\nclass Class1\n def print_global_starting_score\n   # Access global variable\n   puts \"The starting score in Class1 is #$global_variable_starting_score\"\n end\nend\n\n\nclass Class2\n def print_global_starting_score\n   # Access global variable\n   puts \"The starting score in Class2 is #$global_variable_starting_score\"\n end\nend\n\n\nclass1obj = Class1.new\nclass1obj.print_global_starting_score\nclass2obj = Class2.new\nclass2obj.print_global_starting_score\n\n\n# Output: The starting score in Class1 is 0\n# Output: The starting score in Class2 is 0"},{"title":"User Input","description":"In Ruby, user input is made possible by the #gets method. During the executing of a Ruby program, when a line with the #gets method is read, the terminal is primed for input from the user. The input is returned as a string type after the #gets method is finished.\n\nname = gets\n\n\nputs \"My name is #{name}!\"\n\nThe output would be:\n\nMelanie\nMy name is Melanie\n!\n\nIf just the #gets method is used, the keystroke on the Enter key is submitted with rest of the input, hence why thd ! is on a new line. This can be avoided with the #chomp method:\n\nname = gets.chomp\n\n\nputs \"My name is #{name}!\"\n\nThe output would be:\n\nBrandon\nMy name is Brandon!"}],"SQL":[{"title":"About SQL","description":"SQL stands for Structured Query Language, and is the programming language implemented by a database management system (DBMS) used for managing and querying data held in a relational database.\n\nSQL has been an ANSI standard since 1986 and each different DBMS has its own implementation of this standard. These different implementations have varying adherence to the standard, so in practice SQL code of any complexity is not typically transferrable between different DBMS systems without some modification. However, because of the standard, skills learned in one DBMS system are largely applicable to another.\n\nTypes of Statements\n\nSQL statements can be broadly grouped into four different classes, or sub-languages:\n\nData Query Language (DQL): Includes commands for performing queries on data within schema objects, retrieving some schema relation based on the query passed to it. Examples include:\n\nSELECT retrieves data from the database.\n\nData Definition Language (DDL): Includes commands used to define the database schema. These commands are used to create and modify the structure of database objects. Examples include:\n\nCREATE creates an object in the database.\nDROP deletes an object from the database.\nALTER changes the definition of an existing object in the database.\n\nData Manipulation Language (DML): Includes commands used to modify the data stored in the database. Examples include:\n\nINSERT inserts new data into a database table.\nUPDATE alters data in a database table.\nDELETE removes data from a database table.\n\nData Control Language (DCL): Includes commands dealing with the controls and properties of the DBMS, such as rights and permissions to database objects. Examples include:\n\nGRANT grants a user permissions on a database object.\nREVOKE removes a user’s permissions on a database object.\nExamples of SQL code\n\nSelecting first and last name from a table of users:\n\nSELECT firstName, lastName\nFROM users;\n\nDelete records from a transaction table with a particular field value:\n\nDELETE FROM transactionTable\nWHERE transactionKey = '5';\n\nCreate a table with three fields:\n\nCREATE TABLE cars (\n  manufacturer VARCHAR(40),\n  model VARCHAR(40),\n  year INT\n);\nDifferent Databases\nSQLite\nPostgreSQL\nSQL Server\nMySQL"},{"title":"Aggregate Functions","description":"In SQL, aggregate functions perform a calculation on a set of values and return a single value. They are often used with the GROUP BY clause of the SELECT statement.\n\nNote: Except for COUNT(*), aggregate functions ignore all NULL values.\n\nExample\n\nList all the years and their number of movies, but only the years with more than 5 movies:\n\nSELECT year,\n  COUNT(*)\nFROM movies\nGROUP BY year\nHAVING COUNT(*) > 5;"},{"title":"Commands","description":"SQL, Structured Query Language, is a programming language designed to manage data stored in relational databases. SQL operates through simple, declarative statements. This keeps data accurate and secure, and it helps maintain the integrity of databases, regardless of size.\n\nHere’s an appendix of commonly used commands."},{"title":"Comments","description":"A comment is a piece of text within a program that is not executed. It can be used to provide additional information to aid in understanding the code, or to prevent execution of SQL statements.\n\nSingle-line Comments\n\nSingle line comments start with --. Any text between -- and the end of the line will be ignored (will not be executed).\n\nThe following example uses a single-line comment as an explanation:\n\n-- Select all:\n\n\nSELECT *\nFROM customers;\nMulti-line Comments\n\nMulti-line comments start with /* and end with */.\n\nAny text between /* and */ will be ignored.\n\nThe following example uses a multi-line comment as an explanation:\n\n/* Select everything\nfrom the customers table */\n\n\nSELECT *\nFROM customers;\n\nThe following example uses a multi-line comment to ignore many statements:\n\n/* SELECT *\nFROM customers;\nSELECT *\nFROM products; */\n\n\nSELECT *\nFROM orders;\n\nTo ignore just a part of a statement, also use the /* */ comment.\n\nThe following example uses a comment to ignore part of a line:\n\nSELECT id, customer_name, /* city, */ country\nFROM customers;"},{"title":"Constraints","description":"Constraints in SQL are the rules applied to the values of individual columns. They add information about how a column can be used after specifying the data type for a column. They can be used to tell the database to reject inserted data that does not adhere to a certain restriction.\n\nHere are some of the constraints that can be set:\n\nPRIMARY KEY columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a constraint violation which will not allow you to insert the new row.\n\nUNIQUE columns have a different value for every row. This is similar to PRIMARY KEY except a table can have many different UNIQUE columns.\n\nNOT NULL columns must have a value. Attempts to insert a row without a value for a NOT NULL column will result in a constraint violation and the new row will not be inserted.\n\nDEFAULT columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.\n\nNote: There can be only one PRIMARY KEY column per table, but there can be multiple UNIQUE columns.\n\nThe statement below sets constraints on the celebs table:\n\nCREATE TABLE celebs (\n  id INTEGER PRIMARY KEY,\n  name TEXT UNIQUE,\n  grade INTEGER NOT NULL,\n  age INTEGER DEFAULT 10\n);\nid column is the PRIMARY KEY.\nname column is UNIQUE.\ngrade column is NOT NULL.\nage column has a DEFAULT of 10."},{"title":"Dates","description":"Dates in SQL are often written in the following format:\n\nDATE: YYYY-MM-DD\nDATETIME: YYYY-MM-DD hh:mm:ss\n\nWe can use SQL’s date functions to transform data into a desired format. Since date functions can be database specific, verify the functions that exist on your relational database management system.\n\nFor example, suppose there’s a bodega table with the following data:\n\norder_id\titem\tprice\tquantity\torder_date\n1\tDonut\t2.49\t2\t2022-08-16 08:04:23\n2\tCookie\t0.99\t3\t2022-08-16 09:43:00\n3\tDonut\t2.49\t1\t2022-08-16 11:25:12\n4\tEgg Sandwich\t7.99\t1\t2022-08-17 11:45:41\n5\tIce Coffee\t3.99\t2\t2022-08-17 12:18:50\nSELECT TIME(order_date)\nFROM bodega;\n\nThis would return just the time from the order_date column.\n\nTIME(order_date)\n08:04:23\n09:43:00\n11:25:12\n11:45:41\n12:18:50"},{"title":"Indexes","description":"Indexes are specialized data structures that organize a table ahead of time to improve the speed of database searches. This is accomplished through a balanced tree structure that allows the server to only search a subset of relevant rows instead of every row sequentially.\n\nWhile an index organizes the values of an entire table, the organization is based on the value of a specific column. This column should ideally be frequently searched and have a varied set of data to best realize the improved performance of the sorting provided by the index. Columns that are not often used in queries should be avoided. Similarly, columns with many identical values, such as binary columns or columns with a high number of NULL values, should not be indexed.\n\nIndexes are best used on large tables where a small subset of the data is commonly searched. If instead, all the rows are frequently accessed (perhaps to calculate a sum), the extra organization of the index will be irrelevant. Also, on smaller tables the speed improvements will be less noticeable, as most rows may have to be searched anyways.\n\nThe index also needs to be maintained on each INSERT, UPDATE, and DELETE event, possibly making these actions slower. Therefore, tables that feature frequent writes and large updates should avoid indexes.\n\nAs an index is built over time, it is possible for the data to be fragmented across a disk, lowering the performance. This can be avoided by removing and recreating the index, although the implementation differs by database version.\n\nSyntax\n\nIndexes are commonly created alongside the table that it describes:\n\nCREATE TABLE table_name (\n  column_name datatype,\n  column_name datatype,\n  ...\n  INDEX index_name (index_column_name)\n);\n\nHowever, they can also be created for existing tables:\n\nCREATE INDEX index_name\nON table_name (column_name);\nExamples\n\nTo create an index named id_index for the frequently searched student_id column in the students table, use the following query:\n\nCREATE INDEX id_index\nON students (student_id);\nCreating a Unique Index\n\nDue to indexes performing better with more varied data, it is encouraged to enforce unique indexes that disallow duplicates. This works best with columns that happen to be the PRIMARY KEY as well.\n\nTo create a unique index for the student_id that does not allow duplicate values, use the following query:\n\nCREATE UNIQUE INDEX unique_id_index\nON students (student_id);\nRemoving an Index\n\nThe following query can be used to remove the original index placed on student_id:\n\nDROP INDEX id_index;"},{"title":"Operators","description":"SQL operators are unique keywords used in the WHERE clause of a statement to perform arithmetic, comparison, and logical operations.\n\nArithmetic Operators\n\nArithmetic operators are used to perform arithmetic on numeric types:\n\n+: Addition\n-: Subtraction\n*: Multiplication\n/: Division\n%: Modulo (remainder)\n\nFor example:\n\n-- Addition\n10 + 5\n-- Subtraction\n10 - 5\n--  Multiplication\n10 * 5\n-- Division\n10 / 5\n-- Modulo\n10 % 5\nComparison Operators\n\nComparison operators can be used to compare two values:\n\n=: Equal to\n>: Greater than\n<: Less than\n>=: Greater than or equal to\n<=: Less than or equal to\n!=: Not equal\n\nFor example:\n\nSELECT *\nFROM students\nWHERE gpa > 25;\nLogical Operators\n\nLogical operators can be used to combine multiple conditions such as AND, OR, NOT or perform operations such as NOT and BETWEEN."},{"title":"Joins","description":"In order to efficiently store data, we often spread related information across multiple tables.\n\nConnecting or joining these tables to find interesting data is a common task that a Data Analyst, Data Scientist, or Data Engineer will often encounter.\n\nInner Join\n\nThe JOIN clause allows for the return of results from more than one table by joining them together with other results based on common column values specified using an ON clause.\n\nINNER JOIN is the default JOIN and it will only return results matching the condition specified by ON.\n\nHere’s joining the books table and the authors table on books.author_id column and the authors.id column:\n\nSELECT *\nFROM books\nJOIN authors\n  ON books.author_id = authors.id;\n\nOuter Join\n\nAn outer join will combine rows from different tables even if the join condition is not met.\n\nIn a LEFT JOIN, every row in the left table is returned in the result set, and if the join condition is not met, then NULL values are used to fill in the columns from the right table.\n\nSELECT column_name(s)\nFROM table1\nLEFT JOIN table2\n  ON table1.column_name = table2.column_name;\n\nUNION\n\nThe UNION clause is used to combine results that appear from multiple SELECT statements and filter duplicates.\n\nSELECT name\nFROM first_names\nUNION\nSELECT name\nFROM last_names;\n\nFor example, given a first_names table with a column name containing rows of data “James” and “Hermione”, and a last_names table with a column name containing rows of data “James”, “Hermione” and “Cassidy”, the result of this query would contain three names:\n\nname\nCassidy\nJames\nHermione\nCROSS JOIN\n\nThe CROSS JOIN clause is used to combine each row from one table with each row from another in the result set. This JOIN is helpful for creating all possible combinations for the records (rows) in two tables.\n\nSELECT shirts.shirt_color,\n   pants.pants_color\nFROM shirts\nCROSS JOIN pants;\n\nThe given query will select the shirt_color and pants_color columns from the result set, which will contain all combinations of combining the rows in the shirts and pants tables.\n\nIf there are 3 different shirt colors in the shirts table and 5 different pants colors in the pants table then the result set will contain 3 x 5 = 15 rows."},{"title":"Procedures","description":"Procedures are blocks of SQL code that are saved in a database and can be executed repeatedly on demand. Also referred to as stored procedures — they can be defined with parameters to be used within the body of the procedure, produce an output value, or both.\n\nThe syntax for creating a procedure varies depending upon the type of database management system (DBMS) being used. Below is an example procedure defined and executed with MySQL that accepts two parameters and returns an output value.\n\nMySQL Example\n# Set the default delimiter so the procedure can include semicolons\nDELIMITER //\n\n\n# Create the procedure\nCREATE PROCEDURE add_int (IN x INT, IN y INT, OUT z INT)\nBEGIN\n  SELECT x + y INTO z;\nEND //\n\n\n# Set the delimiter back to the default\nDELIMITER ;\n\n\n# Execute the stored procedure\nCALL add_int (5, 3, @z);\n# Return the output parameter\nSELECT @z AS Result;\n\nOutput:\n\nResult\n8"},{"title":"Primary Keys","description":"SQL tables sometimes have a column that uniquely identifies each row of that table. These special columns are called primary keys.\n\nA primary key column has a few requirements:\n\nNone of the values can be NULL.\nEach value must be unique (i.e., you can’t have two customers with the same customer_id in the customers table).\nA table can not have more than one primary key column.\n\nHere’s an orders table where the order_id is its primary key:\n\norder_id\tcustomer_id\ttotal_cost\tpurchase_date\n1\t1001\t13.99\t2022-01-01\n2\t1294\t61.42\t2022-01-01\n3\t1001\t23.45\t2022-01-02\nSyntax\n\nPRIMARY KEY columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a constraint violation which will not allow you to insert the new row.\n\nThe statement below sets a PRIMARY KEY on the students table:\n\nCREATE TABLE students (\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  grade INTEGER,\n  age INTEGER\n);\nForeign Keys\n\nWhen the primary key for one table appears in a different table, it is called a foreign key.\n\nWhy is this important? The most common types of joins will be joining a foreign key from one table with the primary key from another table. For instance, when we join the orders table and the customers table, we join on the customer_id column, which is a foreign key in orders and the primary key in customers."},{"title":"Wildcards","description":"Wildcards are special characters used in SQL to represent one or more arbitrary characters.\n\nThere are two wildcards generally recognized across SQL implementations:\n\n% which matches zero to any arbitrary number of characters.\n_ which matches any one single arbitrary character.\n\nSome SQL implementations add additional types of wildcards. Microsoft Access SQL, in particular, is non-standard, using * in place of % and ? in place of _.\n\nWildcards are commonly used with the LIKE operator, which returns TRUE if the wildcard pattern matches with the provided string value.\n\nExamples\n\nThe following example selects all rows where “H” is the second character in the value of column:\n\nSELECT * FROM table WHERE column LIKE '_H%';\n\nThe matches would include values like “THE” and “WHERE” but not “HOUSE”, or “BREATH”.\n\nSelect all rows where column‘s value contains an “H” anywhere:\n\nSELECT * FROM table WHERE column LIKE '%H%';\n\nMatches values like “THE”, “WHERE”, “HOUSE” and “BREATH”.\n\nSelect all rows where column‘s value is three characters long and has an “H” as the second character:\n\nSELECT * FROM table WHERE column LIKE '_H_';\n\nMatches the value “THE” but not “WHERE”, “HOUSE” or “BREATH”.\n\nSelect all rows where column‘s value begins with “H”;\n\nSELECT * FROM table WHERE column LIKE 'H%';\n\nMatches the value “HOUSE” but not “THE”, “WHERE” or “BREATH”.\n\nSelect all rows where column‘s value ends with “H”:\n\nSELECT * FROM table WHERE column LIKE '%H';\n\nMatches the value “BREATH” but not “THE”, “WHERE” or “HOUSE”."},{"title":"SQL Injections","description":"SQL injection is a technique used to introduce unwanted code into a database. This code is malicious and can be sent to a database and run without permission. The result can be anything from bypassing login to data theft or corruption of a database. The code is usually entered when a website or application asks for user input.\n\nTo prevent SQL injection, databases should not take user input as a command to be run. Running tests across a database could also show any vulnerabilities. Also, parameters can be used to protect against SQL injection, allowing for more control over the values being passed. This will ensure SQL will treat the data as text and not as a command to be executed.\n\nVulnerable Queries\n\nIn this example, there is a form that asks for your User ID. This form will run this SQL command to check if the user exists.\n\nNow if a user enters ‘1’ OR ‘1’=’1’, then the command will look like the following:\n\nSELECT * FROM users WHERE UserID = 'input from user'\n\nThe user injecting the code will be able to access all the UserID’s because 1=1 will always execute as true.\n\nThis example will send a command to the database to drop a table:\n\nSELECT * FROM Projects WHERE UserID = 'input from user'\n\nIf the input is something like '1'; DELETE FROM Projects WHERE '1'='1', the following will happen:\n\nUsers with a UserID set to 1 will be located and retrieved.\nThe semi-colon ; indicates the end of a command and the beginning of the next one.\nThe next command will delete all such rows from the Projects table.\nParameterized queries\nstring sql = \"SELECT * FROM users WHERE UserID = $userInput\"\n\nThis example saves the query as a string and passes the value of the user’s input as a variable into the string.\n\nResources\nIn-depth Codecademy Article\nSQL Injection Prevention Cheatsheet"},{"title":"Window Functions","description":"A window function performs a calculation over the inputted column and then returns the calculated value for each row. Window functions can be identified by their use of the OVER clause.\n\nIn the simplest syntactic example, a function can be preformed over a given column as shown below:\n\nSELECT function_name(column_1_name) OVER()\nFROM table_name;\n\nAn ORDER BY clause can be used to determine in which direction the function should be calculated.\n\nSELECT function_name(column_1_name) OVER(\n    ORDER BY column_2_name\n  )\nFROM table_name;\nExample\n\nA common use case for window functions is to create a running total.\n\nFor example, suppose there’s a monthly_sales table with the following values:\n\nquarter\tmonth\tsales\n1\t1\t1000\n1\t2\t500\n1\t3\t750\n2\t4\t800\n2\t5\t500\n2\t6\t400\n3\t7\t300\n3\t8\t500\n3\t9\t700\n4\t10\t800\n4\t11\t1000\n4\t12\t1250\n\nTo find the cumulative sales up to each month, the given query can be used:\n\nSELECT quarter,\n  month,\n  sales,\n  SUM(sales) OVER(\n    ORDER BY month\n  ) AS 'running_total'\nFROM monthly_sales;\n\nThis will give the following output:\n\nquarter\tmonth\tsales\trunning_total\n1\t1\t1000\t1000\n1\t2\t500\t1500\n1\t3\t750\t2250\n2\t4\t800\t3050\n2\t5\t500\t3550\n2\t6\t400\t3950\n3\t7\t300\t4250\n3\t8\t500\t4750\n3\t9\t700\t5450\n4\t10\t800\t6250\n4\t11\t1000\t7250\n4\t12\t1250\t8500\nPartitions\n\nWindow functions can be partitioned to create bunches of rows that apply the function to each bunch. This is done using the PARTITION BY keyword within the OVER clause.\n\nTo find the average sales per quarter of the previous example, the given query can be used:\n\nSELECT quarter,\n  month,\n  sales,\n  AVG(sales) OVER(\n    PARTITION BY quarter\n  ) AS 'quarterly_average'\nFROM monthly_sales;\n\nThis will give the following output:\n\nquarter\tmonth\tsales\tquarterly_average\n1\t1\t1000\t750\n1\t2\t500\t750\n1\t3\t750\t750\n2\t4\t800\t566.66\n2\t5\t500\t566.66\n2\t6\t400\t566.66\n3\t7\t300\t500\n3\t8\t500\t500\n3\t9\t700\t500\n4\t10\t800\t1016.66\n4\t11\t1000\t1016.66\n4\t12\t1250\t1016.66"}],"Swift":[{"title":"Advanced Operators","description":"Advanced operators in Swift provide the programmer with increased functionality and complex value manipulation. They build upon the concepts covered in the basic operators wiki and include compound assignments, bitwise, and custom operators, to name a few.\n\nBitwise operators are used to manupilate the raw data bits of a structure, such as graphics, file inputs, or device drivers, while not common, these operators are very useful in their specific use cases. Swift also allows the overloading of the standard operators to include your own definition of the function.\n\nCompound Assignment Operator\n\nCompound assignment operators combine the assignment operator = with another separate operation, for example +. The following operations are allowed +, -, /, *, %,\n\nvar a = 1\na +=  9 // a = 10\na *= 4 // a = 40\na -= 7 // a = 33\na /= 3 // a = 11\na %= 5 // a = 1\nBitwise NOT Operator\n\nBitwise NOT ~ operator inverts all the bits in a number, so 0101 0101 will become 1010 1010. It is very important to note that using the ~ operator on a signed integer, a standard integer, inverts a positive integer, n, into -(n+1) and not the inverse binary.\n\nvar newBinaryNumber: UInt8 = 0b01010101  // 01010101\nvar NewinvertedBinary = ~newBinaryNumber // 10101010\n\n\nprint(NewinvertedBinary)\n// Output: 170\n\n\nvar standardInt = 85\nvar invertedStandardInt = ~standardInt\n\n\nprint(invertedStandardInt)\n// Output: -86\nBitwise AND Operator\n\nBitwise AND & operator returns a new binary from the combination of two other binary numbers. If there is a 1 in the same place in each binary string, the result will have a 1 in that digit, else, a 0 will be place\n\n        0 0 1 1 0 1 0 1\nAND     0 1 1 1 1 1 0 1\nEQUALS  0 0 1 1 0 1 0 1\n\n\nlet firstBinary = 0b00110101\nlet secondBinary = 0b01111101\nlet result = firstBinary & secondBinary // 00110101\nBitwise OR Operator\n\nBitwise OR | operator compares two numbers and returns a new number where each bit is set to 1 if either bit equals 1 in the original two numbers.\n\n        0 0 1 1 0 1 0 1\nOR      0 1 1 1 1 1 0 1\nEQUALS  0 1 1 1 1 1 0 1\n\n\nlet firstBinary = 0b00110101\nlet secondBinary = 0b01111101\nlet result = firstBinary | secondBinary // 01111101\nBitwise XOR Operator\n\nBitwise XOR ^ operator, also known as ‘exclusive OR’, compares two binary numbers. It will return a new number with each bit set to 1 if the bits of the orignal numbers are different, or exclusive. 0‘s will be placed anywhere that the two bits are equivalent.\n\n        0 0 1 1 0 1 0 1\nXOR     0 1 1 1 1 1 0 1\nEQUALS  0 1 0 0 1 0 0 0\n\n\nlet firstBinary = 0b00110101\nlet secondBinary = 0b01111101\nlet result = firstBinary ^ secondBinary // 01001000\nBitwise Left and Right Shift Operators\n\nBitwise shift operators, << and >> operate slightly differently on signed and unsigned values. For unsigned values the process is very straight forward, the number shifts to the left or right by the number of digits specified. In essence, for every shift to the left you make, you are doubling the value of the number and for every shift right, you are halving the number.\n\nvar shifty: UInt8 = 0b00001000\nshifty << 1        // 00010000\nshifty << 3        // 01000000\nshifty >> 7        // 00000000\n\n\n// Digits shifted outside the scope of the value are discarded, as with the shift of 7 above\n\nIn signed numbers, the first digit represents the sign, 0 for positive, 1 for negative. For this reason, it is important to keep that digit as we shift either direction. Let’s start with an 8-bit signed number, 15. We said the first digit was the sign, 15 is positive so the sign is 0 and the remaining 7 bits are: 0001111. Together our 8-bit number is 00001111. When shifted left, the signed digit remains the same and digits are “pushed” out of the binary number at the signed digit. When shifting right, instead of filling the void space with a 0, it is filled with the signed digit.\n\nvar signedFifteen = 0b00001111         // 0 0001111\n\n\nvar shiftedRight = signedFifteen >> 1  // 0 0000111\n// Signed digit is '0' and is used to fill  ^\nvar shiftedLeft = signedFifteen << 4   // 0 1110000\n// Signed digit acts as end point, leading '1' is dropped\nCustom and Overloaded Operators\n\nSwift allows you to create your own operators or even define ones that already exist for a given class or structure. Let’s create a basic student structure that we’ll use for the examples.\n\nstruct Student {\n  var name: String\n  var studentId: Int\n  var gpa: Double\n}\n\n\nvar tim = Student(name: \"Tim\", studentId: 234234, gpa: 2.95)\nvar amy = Student(name: \"Amy\", studentId: 233241, gpa: 3.70)\n\nThe equatable operator, == and it’s inverse != will use Swift’s standard definition unless it is redefined. We can test the equatability of the two students by adding conformance to Equatable and creating a == function.\n\nextension Student: Equatable {\n  static func == (student1: Student, student2: Student) -> Bool {\n    return student1.studentId == student2.studentId\n  }\n}\n\n\nif tim == amy {\n  print(\"These students are the same\")\n} else {\n  print(\"These are different students\")\n}\n// Output: \"These are different students\"\n\nWe can now use == to compare two students in a way that makes sense to our program logic. Swift also allows us to overright most of the common operators, for a complete list, visit this page. When we add or subtract from a student, we want to manipulate the GPAs, the mthods below provide examples of their implementation.\n\nextension Student {\n  static func + (left: Student, right: Double) -> Double {\n    if left.gpa + right > 4.0 {\n      return 4.0\n    }\n    return left.gpa + right\n  }\n  static func - (left: Student, right: Double) -> Double {\n    if left.gpa - right < 0.0 {\n      return 0.0\n    }\n    return left.gpa - right\n }\n}\n\nWe can redefine the + and - operators to adjust the GPAs of our students, we also add additional logic to the operator so that it doesn’t go above 4.0 or below 0.0.\n\nBasic operators are not the only ones that can be reassigned, we can also redefine compound operators as well.\n\nextension Student {\n  static func += (left: inout Student, right: Double) -> Student {\n    left.gpa = left + right\n    return left\n  }\n}\n\nThe above examples are not inclusive of all the tasks that can be reassigned, and custom operators such as +++ or -+- can also be created for example. Use the above reference to Swift documentation for the complete list."},{"title":"Arrays","description":"Arrays are ordered collections of values. In other words, an array is an ordered list of values, all of the same type, contained in the same structure. Swift, being a very type safe language, will throw compiler errors if you attempt to store values of different types, say attempting to store a String in an int array.\n\nThe same value can be stored in an array multiple times in different locations.\n\nCreating Arrays\n\nArrays can be created several ways, each with a specific use case.\n\nAn empty array can be declared and initalized with the following syntax:\n\nvar arrayName = [Type]()\n\nThis is useful if you are are not ready to add elements yet or are unsure of how large the array will become.\n\nvar groceryList = [String]()\n\nArrays can also be initialized with a given size and default values. For example, maybe we are storing the values for a Battleship game and the default location marker we want is “U” for “Unchecked”.\n\nvar alphaRow = [Character](repeating: \"U\", count: 10)\n// Creates: [\"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\"]\n\nSwift also allows you to assign different values within the array directly at initialization and will even perform type inferencing enabling you to shorten your code.\n\nvar statesIveVisited:[String] = [\"NY\", \"CA\", \"TX\", \"FL\"]\nvar statesImGoingTo = [\"ME\", \"ID\", \"NV\", \"AK\"]\n\nIf an array is declared as a constant, using let, then the arrray is immutable. You cannot change its size or change the values of its members, this is especially useful if you are trying to protect the data you are storing from being manipulated later on in your program.\n\nAccessing Arrays\n\nArrays can be accessed using subscript notation. Since all arrays are zero-indexed, the first index in the array will be arrayName[0] and the last element will be one less than the .count property of the array. Attempting to access an element that doesn’t exist through subscript notation will result in a runtime error.\n\nvar statesIveVisited:[String] = [\"NY\", \"CA\", \"TX\", \"FL\"]\nprint(\"Yesterday I went to \\(statesIveVisited[0]).\")\n// Output: Yesterday I went to NY.\n\n\nvar statesImGoingTo = [\"ME\", \"ID\", \"NV\", \"AK\"]\nprint(\"Tomorrow I'm headed to \\(statesImGoingTo[1])!\")\n// Output: Tomorrow I'm headed to NV!\n\n\nprint(\"After Nevada, I'm going to head to \\(statesImGoingTo[4]).\")\n// Runtime Error: Index out of range\n\nArrays can also be accessed through built in array properties in the Swift Standard Library, some of these include .first, .last, and .randomElement. If no values exist in the array, these properties will return nil instead of throwing a runtime error.\n\nprint(\"The first and last states I've visited are \\(statesIveVisited.first) and \\(statesIveVisited.last), respectively.\")\n// Output: The first and last states I've visited are NY and FL, respectively.\n\n\nprint(\"To make life interesting, next week I'll fly to \\(statesIveVisited.randomElement).\")\n\nValues in an array can be directly reassigned by accessing the element at a specific index and reassigning the value or assigned into separate variables themselves.\n\nstatesIveVisited[2] = \"MI\"\n// [\"NY\", \"CA\", \"MI\", \"FL\"]\n\n\nlet coolestState = statesIveVisited[0]\nAdding and Removing Items\n\nAdding elements to an array can be done through the append() or insert() methods. Using append() will add an element to the end of the array and insert() allows you to choose where you would like to add an element, pushing the current element at that index and all later elements to the right to make room. Both methods allow for single and multiple element additions.\n\nvar topBabyNames = [\"Sophia\", \"Liam\"]\n\n\ntopBabyNames.append(\"Riley\")\n// [\"Sophia\", \"Liam\", \"Riley\"]\n\n\ntopBabyNames.append(contentsOf: [\"Olivia\", \"Noah\"])\n// [\"Sophia\", \"Liam\", \"Riley\", \"Olivia\", \"Noah\"]\n\n\ntopBabyNames.insert(\"Jackson\", at: 3)\n// [\"Sophia\", \"Liam\", \"Riley\", \"Jackson\", \"Olivia\", \"Noah\"]\n\nSimilarily, elements are removed using the remove(), removeFirst(), and removeLast() methods.\n\ntopBabyNames.remove(at: 2)\n// [\"Sophia\", \"Liam\", \"Jackson\", \"Olivia\", \"Noah\"]\n\n\ntopBabyNames.removeFirst()\n// [\"Liam\", \"Jackson\", \"Olivia\", \"Noah\"]\n\n\ntopBabyNames.removeLast()\n// [\"Liam\", \"Jackson\", \"Olivia\"]\n\nThere are many more array manipulation methods available in the Swift Standard Library, including many more generic Collection based methods.\n\nIterating Over Arrays\n\nTo iterate over the entire contents of an array in Swift use a for-in loop.\n\nfor name in topBabyNames {\n    print(\"\\(name)is the coolest name.\")\n}\n// Output:\n// Liam is the coolest name.\n// Jackson is the coolest.\n// Olivia is the coolest name.\n\nA second technique is to call the forEach() method. This method will operate on all elements of the array and cannot be escaped using a break or continue call, evening returning a value in the body of the closure will only return that value out of the body and not the declaring method body. The forEach() method is commonly used when you want to ensure all elements are manipulated by the loop or to display the purpose of the loop to others reading your code.\n\ntopBabyNames.forEach { name in\n  print(\"\\(name) is the coolest name.\")\n}\n// Same as above\nUseful Array Methods and Tests\n\nSwift has a healthy library of methods and properties available for arrays and collections in general. Some of these include testing the contents of arrays such as contains() and .isEmpty while others can modify or manipulate the array entirely such as map(), reduce(), and sort(). Swift documentation for both collections and arrays include the exhaustive list.\n\nvar topBabyNames = [\"Sophia\", \"Liam\", \"Riley\", \"Jackson\", \"Olivia\", \"Noah\"]\n\n\ntopBabyNames.sort()\nprint(topBabyNames)\n// [\"Jackson\", \"Liam\", \"Noah\", \"Olivia\", \"Riley\", \"Sophia\"]\n\n\ntopBabyNames.reverse()\nprint(topBabyNames)\n// [\"Sophia\", \"Riley\", \"Olivia\", \"Noah\", \"Liam\", \"Jackson\"]\n\n\ntopBabyNames.contains(\"Olivia\")\n// true"},{"title":"Classes","description":"Classes serve as a template to define characteristics and behaviors of an object.\n\nThey are reference types, meaning all instances of a class carry the same characteristics and behaviors.\n\nAn instance is an object created based on a class.\n\nSyntax\n\nIn Swift, classes are defined using the class keyword, followed by a class name, and a pair of curly braces {}.\n\nclass MyClass {\n  // Class body\n}\n\nNote: Class names should be capitalized as per convention.\n\nvar, init(), and func\n\nVariables can be defined with the following steps:\n\nUse the var keyword.\nProvide a variable name.\nAssign a value with =.\n\ninit() is a special method that gets called when a class instance is created. It can take any number of arguments in the form of property: DataType. The self keyword refers to the instance itself.\n\nFunctions within a class are defined with the following steps:\n\nUse the func keyword.\nName the function.\nProvide a set of curly braces {} to hold the function’s body.\nclass Employee {\n  var name = \"\"\n  var salary = 0\n  var manager = false\n\n\n  init(name: String, salary: Int) {\n    self.name = name\n    self.salary = salary\n  }\n\n\n  func promote() {\n    self.manager = true\n  }\n}\n\nIn the code above, Employee class is given three properties or variables:\n\nA name set to an empty string \"\".\nA salary set to an integer value of 0.\nA manager boolean value set to false.\n\nThe init() method takes in name and salary arguments that are of data type string and integer, respectively.\n\nWhen called on an instance, the .promote() method will set its manager property to true.\n\nCreating an Instance\n\nIn Swift, the init() method is called when a class instance is created.\n\nAn employee by the name of \"Sandy Cheeks\" works for “Tree Dome Enterprises Limited” and makes a salary of 10,000 acorns a year. Below, the sandyCheeks variable is assigned to the value of Employee(). This creates an instance of the class Employee.\n\nSandy’s name and salary are set through the initialization method:\n\nvar sandyCheeks = Employee(name: \"Sandy Cheeks\", salary: 10000)\n\nNote: Classes are also named types, which are types that are given a name when defined and can be referred to as such (i.e. instances of Employee have the type Employee).\n\nAccess Functions and Variables\n\nTo view an instance’s characteristics or properties:\n\nprint(sandyCheeks.name)\n// Output: Sandy Cheeks\n\n\nprint(sandyCheeks.salary)\n// Output: 10000\n\nSandy is getting a promotion! So the .promote() method will be called on sandyCheeks instance:\n\nprint(sandyCheeks.manager)\n// Output: false\n\n\nsandyCheeks.promote()\nprint(sandyCheeks.manager)\n// Output: true"},{"title":"Closures","description":"Similar to blocks in C or lambdas in other programming languages, closures in Swift contain chunks of code that can be passed around and reused within the same code.\n\nThey can store and capture references to variables and constants which is also referred to as closing over constants and variables. The best part is that all memory management is handled by Swift.\n\nUsing Closures\n\nClosures look very similar to functions. To show this, a variable called hello is assigned to a closure that prints out “Hello World”:\n\nlet hello = { print(\"Hello World!\") }\n\n\nhello()\n\nThe closure is the code between the curly brackets, { and }. The closure is then called by using the opening and closing parenthesis, ( and ), on the constant hello. This executes the closure and prints out Hello World!.\n\nParameters\n\nJust like functions, closures can also take in parameters or input values. The previous example can be changed to say “Hello” to a specific person instead of the generic “Hello World”.\n\nlet helloName:(String) -> () = { name in\n  print(\"Hello, \\(name)!\")\n}\n\n\nhelloName(\"Sonny\")\n\nThis prints out:\n\nHello, Sonny!\n\nThere are two important parts to this closure:\n\nThe type, (String) -> (), which specifies the value being taken in and returned by the closure.\nThe expression, {name in ...}, where in separates the parameters from the closure body.\n\nThe function call, hello(...), executes the closure.\n\nIt is also important to note the return type is void because nothing of a specific type is being returned in this example. This can be written as () or (void).\n\nType Inference\n\nSwift can infer the type for the parameters and the return type. To demonstrate this, the following numbers will be sorted from decreasing to increasing order using Swift’s .sorted() method.\n\nlet numbers = [38, 45, 66, 72, 19, 73]\n\nHere, a variable named sortedNumbers is created and the .sorted() method is called on the numbers array:\n\nvar sortedNumbers = numbers.sorted( by: { (num1:Int, num2:Int) -> Bool in\n  return num1 < num2\n})\n\nThe closure inside the curly brackets is the argument the numbers are being sorted by. Two integers, num1 and num2, are taken in and a boolean is returned. When num1 is less than num2, it returns true. Otherwise, it returns false.\n\nThe .sorted() method sorts through the whole array and returns a new array.\n\nSince .sorted() method is being called on an array of integers, Swift can infer that the argument is of type (Int, Int) -> (Bool). This means types do not need to be written in the argument, the above expression can be written as follows:\n\nsortedNumbers = numbers.sorted(by: { num1, num2 in return num1 < num2 })\nSingle Expression Closures\n\nIf the closure uses a single expression, like the one above where num1 < num2 is the sole expression, Swift knows what is needed to be returned.\n\nDue to this, there is no need to write the return key in the argument. This can be omitted in the above example, and written as follows:\n\nsortedNumbers = numbers.sorted(by: { num1, num2 in num1 < num2 })\nShorthand Argument Names\n\nThere are also shorthand argument names Swift makes available to inline closures. They are based on the closure’s argument values. $0 is used for the first argument value, $1 for the second value, $2 for the third, and so on.\n\nWhen using shorthand argument names, the argument list and the in keyword can be completely omitted. When removing this from the previous expression, it looks like this:\n\nsortedNumbers = numbers.sorted(by: { $0 < $1 })\nOperations\n\nSwift has type-specific implementations of operators. In the above closure expression when the < operator is being used on integers, Swift can further infer that two integers must be taken in and a value of type Bool will be returned.\n\nThe shorthand expression names can be removed entirely and just the operator needs to be passed in as the argument, like so:\n\nsortedNumbers = numbers.sorted(by: < )\nAutoclosures\n\nAutoclosures are used to wrap a closure expression being passed as an argument of a function.\n\nIt makes for slightly cleaner code because the curly brackets are eliminated when calling the function. This allows the function to be called like it had a String parameter rather than a closure.\n\nTake the following code for example that does not take an autoclosure:\n\nfunc find(search: () -> Bool) {\n  if search() {\n      print(\"The result was true!\")\n  } else {\n      print(\"The result came back false!\")\n  }\n}\n\n\nfind(search: { 122 < 82 })\n// Output: The result came back false!\n\nThis function prints The result was true! when the argument is true, else it prints The result came back false. In this example, the latter is printed since 122 is not less than 82.\n\nNotice when calling the function the comparison argument is in curly braces. These can be removed when using an autoclosure, as shown below:\n\nfunc find(search: @autoclosure () -> Bool) {\n  if search() {\n      print(\"The result was true!\")\n  } else {\n      print(\"The result came back false!\")\n  }\n}\n\n\nfind(search: 122 < 82)\n\nThe @autoclosure attribute is used right before the parameters in the closure argument. When the function is called, the argument is automatically converted into a closure.\n\nAutoclosures can be very useful because they delay code execution. After all, the closure doesn’t run unless called.\n\nTrailing Closures\n\nWhen using a closure as the final argument of a function, Swift has a trailing closure syntax that is useful especially if the closure expression is too long to be written in the function’s argument field. The trailing closure syntax allows for defining the closure outside of the function.\n\nTake the following code, for example, the closure is the only and final argument of the function. Using trailing closure syntax, the closure can be defined outside of the function call.\n\nfunc function(closure: () -> Void) {\n  print(\"Inside function call\");\n  closure();\n  print(\"After closure call\")\n}\n\n\nfunction {\n  print(\"Inside closure\");\n}\n\nThe output is:\n\nInside function call\n\n\nInside closure\n\n\nAfter closure call\nCapturing Values\n\nClosures can capture values from the context surrounding them. Swift stores the external values alongside the closure so it can easily refer to and modify.\n\nTake the following code for example, which is a simple counter function that increments the count by one when it’s called.\n\nfunc counter() -> () -> Int {\n  var count = 0\n  let add = { () -> Int in\n      count += 1\n      return count\n  }\n  return add\n}\n\n\nlet countUp = counter()\n\n\nprint(countUp())    // Output: 1\nprint(countUp())    // Output: 2\nprint(countUp())    // Output: 3\n\n\nlet countUpTwo = counter()\n\n\nprint(countUpTwo()) // Output: 1\nprint(countUp())    // Output: 4\n\nIn the first instance of counter(), assigned to the variable countUp, the closure stored the previous value and incremented the value each time it was called. Creating a new instance of counter() affect countUp because they are not in the same context as each other.\n\nWhy use closures?\n\nClosures make code easier to read and shorter without losing any intentions to the code. It allows for the removal of any uneccessary parts of code to make it clear and precise. It also gives code greater flexibility, by allowing the passing around of functional code in variables and constants."},{"title":"Comments","description":"Comments in represent text that is useful to the programmer or developement team. Think of them as notes or reminders to yourself of important concepts or ideas that need a little explaining above the syntax of the raw code.\n\nIn Swift there are two kinds of comments: single-line comments and multi-line comments. These comments will be completely ignored by the compiler at compile-time.\n\nFamous software engineer Martin Fowler once wrote,\n\n“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”\n\nSingle-Line Comments\n\nIn Swift, as in many other languages, single line comments are prefaced with two consecutive forward slashes (//). They don’t have to be their own line, single line comments can be appended at the end of a line to give more context.\n\n// I am a single-line comment!\nprint(\"Hello World\")\n\nA single-line comment can also be used to comment after a line of code:\n\nprint(\"Hello World\") // Me, too!\nMulti-Line Comments\n\nMulti-line comments allow for greater context and readability of a concept or idea that your program is doing. It is also commonly used for metadata information like authorship and copyright information. In Swift, multi-line comments are made opened with /* and closed with */.\n\n/*\n   This space can be used to write notes to our future selves about ideas that we want\n   to implement and just haven't or if our algorithm isn't easily legible through\n   the code, we can explain it here. This is especially important if we are part\n   of a team separated by time and space and communication occurs here instead of an office.\n*/"},{"title":"Conditionals","description":"Conditionals take an expression, which is code that evaluates to determine a value, and checks if it is true or false. If it’s true, we can tell our program to do one thing — we can even account for false to do another.\n\nAs we write more complex programs, conditionals allow us to address multiple scenarios and make our programs more robust.\n\nif Statement\n\nAn if statement executes a code block when its condition evaluates to true. If the condition is false, the code block does not execute.\n\nvar halloween = true\n\n\nif halloween {\n  print(\"Trick or treat!\")\n}\n\n\n// Output: Trick or treat!\nelse if Statement\n\nAn else if statement provides additional conditions to check for within a standard if/else statement. else if statements can be chained and exist only after an if statement and before an else.\n\nvar weather = \"rainy\"\n\n\nif weather == \"sunny\" {\n  print(\"Grab some sunscreen\")\n} else if weather == \"rainy\" {\n  print(\"Grab an umbrella\")\n} else if weather == \"snowing\" {\n  print(\"Wear your snow boots\")\n} else {\n  print(\"Invalid weather\")\n}\n\n\n// Output: Grab an umbrella\nelse Statement\n\nAn else statement is an optional partner to an if statement. When the condition for the if statement evaluates to false, the code within the body of the else will execute.\n\nvar turbulence = false\n\n\nif turbulence {\n  print(\"Please stay seated.\")\n} else {\n  print(\"You may freely move around.\")\n}\n\n\n// Output: You may freely move around."},{"title":"Dictionaries","description":"A dictionary is an unordered collection of paired data, or key: value pairs.\n\nvar dictionaryName = [\n  \"Key1\": \"Value1\",\n  \"Key2\": \"Value2\",\n  \"Key3\": \"Value3\"\n]\n\nKeys can be be used to access, remove, add, or modify its associated value. Every key in a dictionary is unique.\n\n// Each key is unique even if they all contain the same value\n\n\nvar fruitStand = [\n  \"Coconuts\": 12,\n  \"Pineapples\": 12,\n  \"Papaya\": 12\n]\nAssigning a Value to a Variable\n\nTo assign the value of a key-value pair to a variable, set the value of a variable to dictionaryName[keyValue].\n\nvar primaryHex = [\n  \"red\": \"#ff0000\",\n  \"yellow\": \"#ffff00\",\n  \"blue\": \"#0000ff\",\n]\n\n\nprint(\"The hex code for blue is \\(primaryHex[\"blue\"])\")\n// Prints: The hex code for blue is Optional(\"#0000ff\")\n\n\nif let redHex = primaryHex[\"red\"] {\n  print(\"The hex code for red is \\(redHex)\")\n}\n// Prints: The hex code for red is #ff0000\n\nNote: Assigning the value of a key-value pair to a variable will return an optional value. To extract the value, use optional unwrapping.\n\n.count Property\n\nThe .count property returns an integer that represents how many key-value pairs are in a dictionary.\n\nvar fruitStand = [\n  \"Apples\": 12,\n  \"Bananas\": 20,\n  \"Oranges\", 17\n]\n\n\nprint(fruitStand.count)  // Output: 3\n.isEmpty Property\n\nThe .isEmpty property will return a true value if there are no key-value pairs in a dictionary and false if the dictionary does contain key-value pairs.\n\nvar bakery = [String:Int]()\n\n\n// Check if dictionary is empty\nprint(bakery.isEmpty)  // Prints: true\n\n\nbakery[\"Cupcakes\"] = 12\n\n\n// Check if dictionary is empty\nprint(bakery.isEmpty)  // Prints: false\nIterating Over a Dictionary\n\nA for-in loop can be used to iterate through the keys and values of a dictionary.\n\nvar emojiMeaning = [\n  \"🤔\": \"Thinking Face\",\n  \"😪\": \"Sleepy Face\",\n  \"😵\": \"Dizzy Face\"\n]\n\n\n// Iterate through both keys and values\nfor (emoji, meaning) in emojiMeaning {\n  print(\"\\(emoji) is known as the '\\(meaning) Emoji'\")\n}\n\n\n// Iterate only through keys\nfor emoji in emojiMeaning.keys {\n  print(emoji)\n}\n\n\n// Iterate only through values\nfor meaning in emojiMeaning.values {\n  print(meaning)\n}"},{"title":"Data Types","description":"All programming languages designate certain “types” of data. This helps the operating system and computer hardware allocate memory based on the type of data that is going to be stored. Swift, being a very type-safe language, takes great care to ensure that data types are understood, by both you and the compiler.\n\nIn Swift, we generally store values in variables which can be thought of as a container to hold data. The data type determines how big that container is and where the computer is going to store it for accessing later.\n\nBasic Data Types\nType\tExample\tDescription\nInt\t5, -638\tInteger whole number\nFloat\t3.14, -8.323\tFloating point number\nDouble\t6.2831853071\tFloating point number\nString\tHello world!\tText\nCharacter\tc, $\tSingle character\nBool\ttrue, false\tLogical values\nInteger Data Types\n\nIntegers are whole numbers such as 35 and -123. As you can see from the example, they can be either signed or unsigned whole numbers, the default being signed. Integers can be declared in five different ways:\n\nInt: The standard reference used for whole numbers in Swift. It will create an integer with a size that is based on the platform it is operating on. On 32-bit systems it will create Int32, on 64-bit systems it will create an Int64.\nInt8: Creates an 8-bit signed integer (range of -128 to 127)\nInt32: Creates a 32-bit signed integer (range of -2,147,483,648 to 2,147,483,647)\nInt64: Creates a 64-bit signed integer (range of -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)\nUInt: Unsigned (positivle values only) that is created in the same manner as a standard Int\nUInt8: Creates an 8-bit unsigned integer (range of 0 to 255)\nUInt32: Creates a 32-bit unsigned integer (range of 0 to 4,294,967,295)\nUInt64: Creates a 64-bit unsigned integer (range of 0 to 18,446,744,073,709,551,615)\nlet shinyNewInteger: Int = 500\nlet verySmallInteger: Int8 = 16\nFloating Point Numbers\n\nA Float and a Double are number data types that allow for decimals. A Float is a 32-bit ‘floating-point’ number and a Double is a 64-bit floating-point number, that being said, a Float has approaximately half as much precision as a Double. If you need a high precision of accuracy, it is best to use a Double. In fact, when you declare a variable without specifying the type, Swift will type inference a Double as a precaution.\n\nlet accountBalance: Float = 857.45\nlet pi: Double = 3.14159265359\nlet gpa = 3.7 // inferred as a Double\nStrings and Characters\n\nStrings are a collection of Characters and Characters are the individual symbols that make up our languages. In Swift, the String type can be either mutable or immutable, as determined by the type of variable you store it in, either a var or a let for a constant. Both String and Character are typically declared inside a set of double quotation marks, while multi-line Strings are declared with a set of triple quotations opening and closing the text.\n\nlet author: String = \"Edgar Allen Poe\"\nlet type: Character = \"P\"\nlet theRaven: String = \"\"\"\nOnce upon a midnight dreary, while I pondered, weak and weary,\nOver many a quaint and curious volume of forgotten lore—\n  While I nodded, nearly napping, suddenly there came a tapping,\nAs of some one gently rapping, rapping at my chamber door.\n“’Tis some visitor,” I muttered, “tapping at my chamber door—\n        Only this and nothing more.”\n\"\"\"\nBoolean Data Type\n\nBoolean values, initialized using the Bool keyword, represent true and false. They are used in control flow and other conditional statements to process the logical decision points in your program leading them to be referred to as logical values. They can be declared directly or by using a logical test.\n\nlet fallingOnPavementHurts = true\n\n\nvar gameOver: Bool = homeScore > 5 || awayScore > 5"},{"title":"Enums","description":"In Swift, an enumeration (enum) is a collection of set values that can be referenced throughout a program.\n\nSyntax\nenum MyEnum {\n  Enumeration cases go here\n}\n\nTo access specific cases in MyEnum, the dot operator . is used, following the case name:\n\nMyEnum.case\nCreating an enum and Examples\n\nenum cases can be defined on separate lines:\n\nenum Level {\n  case beginner\n  case intermediate\n  case advanced\n}\n\nenum cases can also be written in a single line for simplicity:\n\nenum Level {\n  case beginner, intermediate, advanced\n}\nRaw Value\n\nRaw values can be added for each case if a raw type is defined after the enum name and trailing colon :.\n\nenum Bishop: String {\n  case novice = \"Beginner\"\n  case firstJob = \"Magician\"\n  case secondJob = \"Cleric\"\n  case thirdJob = \"Priest\"\n}\n\nThe example above displays an enum, named Bishop, with a raw type of String and cases assigned to their respective raw values.\n\nAssociated Value\n\nAssociated values can be added to available cases.\n\nenum MageAdvancementTree {\n  case novice\n  case firstJob(String)\n  case secondJob(wizard: String)\n  case thirdJob(mage: String)\n  case fourthJob(arch: String)\n}\n\n\nvar bishop = MageAdvancementTree.thirdJob(mage: \"Priest\")\n\n\nprint(bishop)\n// Output: thirdJob(mage: \"Priest\")\n\nAn enum named MageAdvancementTree is created and most of its cases have associated values. Then, a bishop variable is declared as a MageAdvancementTree and sets the mage to a string, \"Priest\".\n\nAccessing an enum and Examples\n\nAn enumeration can be accessed with the dot . syntax.\n\nenum MageAdvancementTree {\n  case novice, firstJob, secondJob, thirdJob, fourthJob\n}\n\n\nvar bishop = MageAdvancementTree.thirdJob\nbishop = .fourthJob\n\n\nprint(bishop)\n// Output: fourthJob\n\nWhen a variable is declared and set to an enumeration, it can be re-assigned to a different case value with the shortened dot syntax shown above.\n\nSwitch Case\n\nA switch statement is another way to access values within an enumeration. In the example below, the bishop variable will be evaluated to match case .fourthJob because it was previously set to the fourthJob value. Access to the values in enum MageAdvancementTree is possible because bishop is already set to it.\n\nswitch bishop {\n  case .novice:\n    print(\"Beginner\")\n  case .firstJob:\n    print(\"Magician\")\n  case .secondJob:\n    print(\"Cleric\")\n  case .thirdJob:\n    print(\"Priest\")\n  case .fourthJob:\n    print(\"Bishop\")\n}\n// Output: Bishop\nIterative\n\nNotice that MageAdvancementTree adopts the CaseIterable protocol which gives access to the allCases property. Using a for...in loop, each value within the enumeration can be accessed.\n\nenum MageAdvancementTree: String, CaseIterable {\n  case novice = \"Beginner\"\n  case firstJob = \"Magician\"\n  case secondJob = \"Cleric\"\n  case thirdJob = \"Priest\"\n  case fourthJob = \"Bishop\"\n}\n\n\nfor job in MageAdvancementTree.allCases {\n  print(job.rawValue)\n}\n\nThis would output the raw values in MageAdvancementTree:\n\nBeginner\nMagician\nCleric\nPriest\nBishop"},{"title":"Inheritance","description":"Inheritance allows properties, methods, and other characteristics to be transferred between classes. This is a feature that differentiates classes from other data types.\n\nA class that inherits features is known as the child class or subclass. The class that the subclass inherited from is known as the parent class or superclass.\n\nSyntax\n\nA class can inherit from another class with the following syntax:\n\nclass SuperClass {\n  // Superclass definition goes here\n}\n\n\nclass SubClass: SuperClass {\n  // Subclass definition goes here\n}\n\nThe subclass will inherit all the properties and methods from the superclass and can also have its own defined ones.\n\nExample\n\nThe following example is a class named Car with one variable, topSpeed that is equal to 200, and a function named drive() that prints a string:\n\nclass Car {\n  var topSpeed = 200\n  func drive() {\n    print(\"Driving\")\n  }\n}\n\nA second class can inherit from the Car class as shown below:\n\nclass Jeep: Car {\n  // Creating new property\n  var currentNumberOfMiles = 0\n}\n\nAn instance of Jeep can be created like this:\n\nlet wrangler = Jeep()\n\nProperties can be accessed or changed like this:\n\nwrangler.topSpeed = 100\nprint(wrangler.topSpeed)\n// Output: 100\n\n\nwrangler.currentNumberOfMiles = 300\nprint(wrangler.currentNumberOfMiles)\n// Output: 300\nOverride\n\nA method of a superclass can be overridden within the subclass by using the override keyword. The following example creates a new subclass of Car called Tesla and uses the override keyword on the drive() function:\n\nclass Tesla: Car {\n  override func drive() {\n    print(\"Driving very quietly\")\n  }\n}\n\nWhen an instance of Tesla is created and the func method is called on it, the new implementation of drive() will print:\n\nlet modelY = Tesla()\nmodelY.drive()\n// Output: Driving very quietly\nAccessing Superclass Method After Override\n\nIf the superclass version of the method needs to be accessed in the overidden version, the super keyword can be used:\n\nclass Tesla: Car {\n  override func drive() {\n    super.drive()\n    print(\"Driving very quietly\")\n  }\n}\n\nWhen .drive() is called on an instance of the class, both the superclass and overriden versions of the method will be called:\n\nmodelY.drive()\n\nThis will output:\n\nDriving\nDriving very quietly\nPrevent Overriding\n\nOverriding can be prevented by using the final keyword when declaring the method in the superclass. An example of this is shown below using the previous example:\n\nclass Car {\n  var topSpeed = 200\n    final func drive() { // Declaring final for drive()\n      print(\"Driving\")\n    }\n}\n\n\nclass Tesla: Car {\n  override func drive() { // ERROR: Instance method overrides a 'final' instance method\n    super.drive()\n    print(\"Driving very quietly\")\n  }\n}\n\nWhen the method is declared final, any attempt to override a method declared final will result in an error."},{"title":"Loops","description":"for-in Loop\n\nThe for-in loop is used to iterate over collections, including strings and ranges.\n\nfor char in \"hehe\" {\n  print(char)\n}\n\nThe output would be:\n\nh\ne\nh\ne\ncontinue Keyword\n\nThe continue keyword will force the loop to move on to the next iteration.\n\nfor num in 0...5 {\n  if num % 2 == 0 {\n    continue\n  }\n  print(num)\n}\n\nThe output would be:\n\n1\n3\n5\nbreak Keyword\n\nTo terminate a loop before its completion, use the break keyword.\n\nfor char in \"supercalifragilisticexpialidocious\" {\n  if char == \"c\" {\n    break\n  }\n  print(char)\n}\n\nThe output would be:\n\ns\nu\np\ne\nr\nUsing Underscore\n\nUse _ instead of a placeholder variable if the variable is not referenced in the for-in loop body.\n\nfor _ in 1...3 {\n  print(\"Olé\")\n}\n\nThe output would be:\n\nOlé\nOlé\nOlé\nwhile Loop\n\nA while loop accepts a condition and continually executes its body’s code for as long as the provided condition is true.\n\nIf the condition is never false then the loop continues to run and the program is stuck in an infinite loop.\n\nvar counter = 1\nvar stopNum = Int.random(in: 1...10)\n\n\nwhile counter < stopNum {\n  print(counter)\n  counter += 1\n}\n\n\n// The loop prints until the stop condition is met\nRanges\n\nRanges created by the ... operator will include the numbers from the lower bound to (and includes) the upper bound.\n\nlet zeroToThree = 0...3\n\n\n// zeroToThree: 0, 1, 2, 3\nstride() Function\n\nCalling stride() with the 3 necessary arguments creates a collection of numbers; the arguments decide the starting number to, the (excluded) ending number, and how to increment/decrement from the start to the end.\n\nfor oddNum in stride(from: 1, to: 5, by: 2) {\n  print(oddNum)\n}\n\nThe output would be:\n\n1\n3"},{"title":"Operators","description":"Operators are unique characters or phrases that Swift uses to manipulate and validate values. Swift was specifically designed to enhance the operators from several programming languages to create more capability with less code for the programmer.\n\nAssignment Operator\n\nThe assignment operator = in Swift is the same as in most other languages and serves the same purpose. It is used to initializae or reassign a variable to some value. In Swift, unlike some other high level programming languages like C or Java, the assignment operator does not return any values.\n\nvar a = 5\n// When we reference variable 'a', it returns the value int: 5.\nlet z = (a = 6)\n// Compile warning that 'b' is of type '()' \"\n// Output: '()'\n\nHere, the z = (a=6) assignment leaves z to equal () once the a=6 is evaluated.\n\nArithmetic Operators\n\nSwift contains the following operators that match their similar expressions in common math:\n\n+ for addition\n- for subtraction\n* for multiplication\n/ for division\n% for modulus or remainder division\n\nThese work as you would expect for all mathematical operations, however the + operator can also be used to concatenate two strings together such as \"Operators\" + \" in Swift\" = \"Operators in Swift\".\n\nComparison Operators\n\nThese operators are used to return Bool values for use in conditional statements. These control logic flow in loops or if statements for example. The basic comparison operators are below:\n\n== equal to\n!= not equal to\n> greater than\n>= greater than or equal to\n< less than\n<= less than or equal to\n\nThe following code snippet shows a use cases of comparison operators in a while loop that will :\n\nvar countUp = 0\nvar countDown = 10\n\n\nwhile countUp < countDown {\n  countUp = countUp + 1\n  countDown = countDown - 1\n}\nLogical Operators\n\nLogical Operators are used to evaluate or modify the value of Beolean values and are especially useful in control flow logic, in Swift there are three operators:\n\n! Logical NOT\n&& Logical AND\n|| Logical OR\n\nLogical NOT(!) operator appears directly before a Boolean value with no spaces. This operator inverts the value of the Boolean so that true becomes false and vice versa.\n\nvar earthIsFlat = false\nif !earthIsFlat {\n  print(\"All our physics doesn't work!\")\n}\n\nLogical AND (&&) and logical OR (||) operators evalute two Booleans or Boolean expressions. In an AND evaluation, both expressions must result in true, resulting in the overall AND expression becoming true. In an OR evaluation only one expression must be true for the result of OR to be true. In both cases, if the left side of the expression evaluates to a value that the compiler can determine a value for the operator, the right side will not be evaluated at all.\n\nvar iAmTrue = true\nvar iAmFalse = false\n\n\nif (iAmTrue && iAmFalse) {\n  // Both sides are checked because the first value is true and the compiler needs to check right side' value\n  print(\"Both values are 'true' and the AND operator returned 'true'.\")\n} else if (iAmTrue || iAmFalse) {\n  // Only the left side is evaluated, as soon as the compiler sees a 'true', it can reason that the OR requirements are met and will enter the 'else if' body\n  print(\"At least one value was 'true'  and the OR operator returned 'true'.\")\n} else {\n  print(\"Neither value is 'true'.\")\n}\nRange Operators\n\nRange operators provide quick and convenient ways of creating various ranges or iterating over elements in an object. The three primary types are Closed ( a...z ), Half-Open (a..<z), and One-Sided (a...), each providing different limits on the range. Swift does not allow for the creation on decrementing ranges, therefore the value of the first variable must not be greater than the value of the second.\n\nThe Closed Range operator (a...z) creates a range that begins at a and continues to and includes, z. The most common use case for Closed Range Operators is in for-in loops.\n\nlet userAge = 32\n\n\nfor year in 2...userAge {\n  print(\"You turned \\(year) years old!\")\n}\n\nThis should output:\n\nYou turned 2 years old!\nYou turned 3 years old!\n... all the way to and including\nYou turned 32 years old!\n\nHalf-Open range operators(a..<z) create a range beginning at a and continue to z but not including z. They are commonly used when working with Arrays or other zero-indexed lists.\n\nlet picnic = [\"Ceasar Salad\", \"Turkey Sandwich\", \"Cookie\", \"Juice Box\"]\n\n\nfor i in 0..<picnic.count {\n  print(\"Item #\\(i+1) in the picnic basket is a \\(picnic[i]).\")\n}\n\nThis should output:\n\nItem 1 in the picnic basket is a Ceasar Salad.\nItem 2 in the picnic basket is a Turkey Sandwich.\nItem 3 in the picnic basket is a Cookie.\nItem 4 in the picnic basket is a Juice Box.\n\nThe One-Sided range operator defines a range that will continue as far in one direction as possible. We can use this range to iterate from or to specific ranges inside of other fixed length entities.\n\nfor food in picnic[...2] {\n  print(food)\n}\n// Ceasar Salad\n// Turkey Sandwich\n// Cookie\n\n\nfor food in picnic[2...] {\n  print(food)\n}\n// Cookie\n// Juice Box\n\n\nfor food in picnic[..<3] {\n  print(food)\n}\n// Ceasar Salad\n// Turkey Sandwich\n// Cookie\n\n\nlet infiniteRange = 0... // 0 to infinity\nfor i in infiniteRange {\n  print(i)\n  // creates an infinite loop, always take note of what\n  // \"stops\" your open-ended ranges\n}\nNil-Coalescing Operator\n\nThe nil-coalescing operator (a ?? z) unwraps an optional with the value of a unless a is nil, then it will return the value of z. a always has to be an optional type and z has to match the type that’s stored in a.\n\nlet defaultPrice = 1.99\nvar getItemPrice: Double?\n\n\nlet priceToChargeCustomer = getItemPrice ?? defaultPrice\n\nSince getItemPrice isn’t assigned a value it defaults to ‘nil’. The price to charge the customer is either a price we get from an item or the default price. In this case, priceToChargeCustomer = 1.99\n\nTernary Conditional Operator\n\nThe ternary conditional operator is shorthand for a simple if-else statement. It follows the syntax statementToTest ? doThisAndReturnIfTrue : doThisAndReturnIfFalse which in terms of the if-else statement can be read as:\n\nif the statement is true, evaluate and return the value of the left side of the ternary\nif it’s false, evaluate and return the value of the right side.\nlet exoticBirdBingo = [\"ostrich\", \"falcon\", \"peacock\", \"flamingo\", \"gold and blue macaw\"]\nlet birdsSeen = [\"flamingo\", \"pigeon\", \"blue jay\", \"peacock\"]\n\n\nfor bird in birdsSeen {\n  print(exoticBirdBingo.contains(bird) ? \"Cross \\(bird) off your bingo card!\" : \"A \\(bird) is just a normal bird.\")\n}\n\nThis would output:\n\nCross flamingo off your bingo card!\nA pigeon just a normal bird.\nA blue jay is just a normal bird.\nCross peacock off your bingo card!"},{"title":"Protocols","description":"A protocol is a collection of methods, properties, and rules that a class, struct, or enum can adopt.\n\nSyntax\n\nA protocol is created with the protocol keyword:\n\nprotocol MyProtocol {\n  // Protocol body\n}\n\nNote: Names are written in PascalCase.\n\nFor class, structure, or enumeration data types to adopt a protocol, it chains onto their definition and is separated with a colon:\n\nclass MyClass: MyProtocol, OtherProtocol, ... {\n  // This can be a class, structure, or enumeration\n}\nProperty Requirements\n\nProperty requirements are variables that indicate a type and the get/set keywords determine if that property is gettable and/or settable.\n\nprotocol MyProtocol {\n  var getAndSet: Int { get set }\n  var onlyGet: String { get }\n}\n\nNote: Gettable variables can be read and settable variables can be set or changed. Programmers sometimes only allow a variable to be gettable because they don’t want it to be mutated.\n\nData types that adopt a protocol, must conform to the properties and methods defined in it.\n\nprotocol Grammar {\n  var alphabet: String { get }\n}\n\n\nstruct Language: Grammar {\n  var alphabet: String\n}\n\n\nlet english = Language(alphabet: \"abcdefghijklmnopqrstuvwxyz\")\n\n\nprint(english.alphabet)\n// Output: abcdefghijklmnopqrstuvwxyz\nBuilt-in Protocols\n\nSwift includes certain built-in protocols.\n\nCaseIterable\n\nCaseIterable has an allCases property. An enumeration can adopt this protocol to gain access to all its values.\n\nenum MageAdvancementTree: CaseIterable {\n  case novice, firstJob, secondJob, thirdJob, fourthJob\n}\nprint(\"You will have \\(MageAdvancementTree.allCases.count) different jobs as a Mage.\")\n// Output: You will have 5 different jobs as a Mage."},{"title":"Optionals","description":"Optionals are types that deal with scenarios involving the potential presence or absence of a value (nil).\n\nSyntax\n\nIn Swift, a non-optional variable should not be set to nil. Rather, the optional type must be defined using the added question mark ?.\n\nThere are two ways to use an optional. Below, a variable named myVariable is set to an optional Type, Type?. Type referred to a Swift data type. It can either be equal to some value with the specified data type or nil.\n\nvar myVariable: Type?\nvar myVariable: Optional<Type>\n\nNote: If myVariable is not assigned a value of the specified data type, it will default to nil.\n\nUnwrapping Optionals\n\nOptional types should be unwrapped only if it’s certain that a value is present. An error will result if an optional without a value is unwrapped. Below are some ways this can be done.\n\nNil-Coalescing\n\nThe nil-coalescing operator, ??, assigns a value by checking from left to right. If the preceding optional values are nil, the default value on the right is assigned.\n\nIn the example below,maybeInt is declared as an optional integer type and set to nil, therefore myInt will default to 27:\n\nvar maybeInt: Int? = nil\nvar myInt = maybeInt ?? 27\n\n\nprint(myInt)\n// Output: 27\n\nNote: In the following code blocks, a mutable var variable can be used in place of any constant let variable.\n\nif let\n\nif let is an optional binding control structure.\n\nvar maybeString: String? = \"maybeString\"\n\n\nif let myString = maybeString {\n  print(\"\\(maybeString) and myString are equal!\")\n} else {\n  print(\"myString could not be assigned to nil.\")\n}\n\n\n// Output: Optional(\"maybeString\") and myString are equal!\n\nmyString is declared and conditionally bound to the maybeString optional. The value of myString can be accessed from inside the if statement, but not in the outer scope. An alternative to if let that allows upwrapped values to be accessed in the outer scope, is the guard let statement.\n\nguard let\n\nguard let is another optional binding control structure that can be used within a function.\n\nvar maybeInt: Int? = 2022\n\n\nfunc findInt() {\n  guard let myInt = maybeInt else {\n    return\n  }\n  print(myInt)\n}\n\n\n findInt()\n // Output: 2022\n\nIf the optional maybeInt holds a value, it will be assigned to myInt. Otherwise, the else block will run and hit the return statement.\n\nNote: The following ways to upwrap optionals is not recommended because it does not handle nil cases.\n\nForced Upwrapping\n\nPlacing an ! after an optional value forces it to unwrap its value:\n\nvar maybeInt: Int? = 27\n\n\nvar myInt: Int = maybeInt!\n\n\nprint(myInt)\n// Output: 27\n\nAlternatively, this can be done implicitly:\n\nvar myInt = maybeInt!\n\n\nprint(myInt)\n// Output: 27"},{"title":"Sets","description":"In Swift, a set is used to store unique elements of the same data type.\n\nCreating a Set\n\nTo create a set populated with values, use the Set keyword before the assignment operator.\n\nvar paintingsInMOMA: Set = [\"The Dream\", \"The Starry Night\", \"The False Mirror\"]\n\nThe values of the set must be contained within brackets [] and separated with commas ,.\n\nEmpty Sets\n\nAn empty set is a set that contains no values inside.\n\nvar team = Set<String>()\n\n\nprint(team)\n// Output: []\nIterating Over a Set\n\nA for-in loop can be used to iterate over each item in a set.\n\nvar recipe: Set = [\"Chocolate chips\", \"Eggs\", \"Flour\", \"Sugar\"]\n\n\nfor ingredient in recipe {\n  print(\"Include \\(ingredient) in the recipe.\")\n}\n.isEmpty Property\n\nUse the built-in property .isEmpty to check if a set has no values contained in it.\n\nvar emptySet = Set<String>()\n\n\nprint(emptySet.isEmpty)  // Prints: true\n\n\nvar populatedSet: Set = [1, 2, 3]\n\n\nprint(populatedSet.isEmpty) // Prints: false\n.count Property\n\nThe property .count returns the number of elements contained within a set.\n\nvar band: Set = [\"Guitar\", \"Bass\", \"Drums\", \"Vocals\"]\n\n\nprint(\"There are \\(band.count) players in the band.\")\n// Output: There are 4 players in the band.\nSet Methods\nMethod\tDescription\n.insert()\tAdd an element at a specified index\n.remove()\tRemove an element at a specified index\n.removeAll()\tRemove every single value from a set\n.contains()\tCheck whether an item exists within the set\n.intersection()\tPopulates a new set of elements with the overlapping elements of two sets\n.union()\tPopulates a new set by taking all the values from two sets and combining them\n.symmetricDifference()\tCreates a new set with all the non-overlapping values between two sets\n.subtracting()\tRemoves the values of one second set from another set and stores the remaining values in a new set"},{"title":"Structures","description":"Structures, or structs, are used to programmatically represent a real-life object in code. Structures are created with the struct keyword followed by its name and then body containing its properties and methods.\n\nstruct Building {\n  var address: String\n  var floors: Int\n\n\n  init(address: String, floors: Int, color: String) {\n    self.address = address\n    self.floors = floors\n  }\n}\nDefault Property Values\n\nA structure’s properties can have preassigned default values to avoid assigning values during initialization. Optionally, these properties’ values can still be assigned a value during initialization.\n\nstruct Car {\n  var numOfWheels = 4\n  var topSpeed = 80\n}\n\n\nvar reliantRobin = Car(numOfWheels: 3)\n\n\nprint(reliantRobin.numOfWheels) // Prints: 3\nprint(reliantRobin.topSpeed)    // Prints: 80\nStructure Instance Creation\n\nA new instance of a structure is created by using the name of the structure with parentheses () and any necessary arguments.\n\nstruct Person {\n  var name: String\n  var age: Int\n\n\n  init(name: String, age: Int) {\n    self.name = name\n    self.age = age\n  }\n}\ninit() Method\n\nStructures can have an init() method to initialize values to an instance’s properties. Unlike other methods, The init() method does not need the func keyword. In its body, the self keyword is used to reference the actual instance of the structure.\n\nstruct TV {\n  var screenSize: Int\n  var displayType: String\n\n\n  init(screenSize: Int, displayType: String) {\n    self.screenSize = screenSize\n    self.displayType = displayType\n  }\n}\nStructure Methods\n\nMethods are like functions that are specifically called on an instance. To call the method, an instance is appended with the method name using dot notation followed by parentheses that include any necessary arguments.\n\nstruct Dog {\n  func bark() {\n    print(\"Woof\")\n  }\n}\n\n\nlet fido = Dog()\nfido.bark() // Prints: Woof\n\n\nvar newTV = TV(screenSize: 65, displayType: \"LED\")\n\n\n// Instance of Person:\nvar morty = Person(name: \"Morty\", age: 14)\nMutating Methods\n\nStructure methods declared with the mutating keyword allow the method to affect an instance’s own properties.\n\nstruct Menu {\n  var menuItems = [\"Fries\", \"Burgers\"]\n\n\n  mutating func addToMenu(dish: String) {\n    self.menuItems.append(dish)\n  }\n}\n\n\nvar dinerMenu = Menu()\n\n\ndinerMenu.addToMenu(dish: \"Toast\")\n\n\nprint(dinerMenu.menuItems)\n// Output: [\"Fries\", \"Burgers\", \"Toast\"]"},{"title":"Switch","description":"The switch statement is a type of conditional used to check the value of an expression against multiple cases.\n\nA case executes when it matches the value of the expression. When there are no matches between the case statements and the expression, the default statement executes.\n\n\n\nvar secondaryColor = \"green\"\n\n\nswitch secondaryColor {\n  case \"orange\":\n    print(\"Mix of red and yellow\")\n  case \"green\":\n    print(\"Mix of blue and yellow\")\n  case \"purple\":\n    print(\"Mix of red and blue\")\n  default:\n    print(\"This might not be a secondary color.\")\n}\n\n\n// Output: Mix of blue and yellow\nInterval Matching\n\nIntervals within a switch statement’s case provide a range of values that are checked against an expression.\n\nlet year = 1905\nvar artPeriod: String\n\n\nswitch year {\n  case 1860...1885:\n    artPeriod = \"Impressionism\"\n  case 1886...1910:\n    artPeriod = \"Post Impressionism\"\n  case 1912...1935:\n    artPeriod = \"Expressionism\"\n  default:\n    artPeriod = \"Unknown\"\n}\n\n\n// Output: Post Impressionism\nCompound Cases\n\nA compound case within a switch statement is a single case that contains multiple values. These values are all checked against the switch statement’s expression and are separated by commas.\n\nlet service = \"Seamless\"\n\n\nswitch service {\n  case \"Uber\", \"Lyft\":\n    print(\"Travel\")\n  case \"DoorDash\", \"Seamless\", \"GrubHub\":\n    print(\"Restaurant delivery\")\n  case \"Instacart\", \"FreshDirect\":\n    print(\"Grocery delivery\")\n  default:\n    print(\"Unknown service\")\n}\n\n\n// Output: Restaurant delivery\nWhere Clause\n\nWithin a switch statement, a where clause is used to test additional conditions against an expression.\n\n\n\nlet num = 7\n\n\nswitch num {\n  case let x where x % 2 == 0:\n    print(\"\\(num) is even\")\n  case let x where x % 2 == 1:\n    print(\"\\(num) is odd\")\n  default:\n    print(\"\\(num) is invalid\")\n}\n\n\n// Output: 7 is odd"},{"title":"Tuples","description":"Tuples are a data type introduced in Swift version 4. They are used to group multiple values, separated by commas ,, into a single value that is enclosed in parentheses ().\n\nNote: Tuples are compound types. This means that they combine different types of data.\n\nSyntax\nvar myTuple = (value1, value2, ...)\n\nNote: Names should be in camelCase.\n\nAccessing and Changing Values\n\nValues of a tuple can be accessed using indices:\n\nvar computerScience = (1960, \"George Forsythe\")\n\n\nprint(computerScience.0)\n// Output: 1960\n\n\nprint(computerScience.1)\n// Output: George Forsythe\n\nValues or elements can also be referenced with a named property:\n\nvar alanTuring = (\n  name: \"Alan Mathison Turing\",\n  born: 1912,\n  inventions: [\"Universal Turing Machine\", \"Bombe\"]\n)\n\n\nprint(\"\\(alanTuring.name) was born in \\(alanTuring.born) and invented the \\(alanTuring.inventions[0]).\")\n// Alan Mathison Turing was born in 1912 and invented the Universal Turing Machine.\n\nThese values can then be altered through their indices or name:\n\ncomputerScience.0 = 1961\nprint(computerScience.0)\n// Output: 1961\n\n\nalanTuring.inventions.append(\"Automatic Computing Engine\")\nprint(alanTuring.inventions)\n// Output: [\"Universal Turing Machine\", \"Bombe\", \"Automatic Computing Engine\"]"},{"title":"Variables","description":"The Swift programming language allows you to store values in two types of containers, var for variables and let for constants. As the names imply, a variable’s value can change, or be reassigned, later in the program while a constant’s value cannot. It is a best practice to use constants as much as possible, this will help prevent you from accidentally reassigning values later on without meaning to.\n\nOnce a variable or constant’s data type has been established, whether explicitly declared or inferred by the compiler, it cannot be changed and the variable name cannot be used for another data type within the same program. In the same manner, a variable cannot be changed into a constant and a constant cannot be converted into a variable.\n\nDeclaring and Initializing Variables and Constants\n\nVariables and constants can be declared with or without initialization on the same line, however you cannot declare an uninitialized variable without including the type annotation. This makes sense considering that the compiler, when it looks over the code line-by-line, can’t make a determination of the data type at the time of the build. Swift also allows a wide range of characters to be used in constant and variable names including Unicode characters and emojis.\n\nvar dailyTemperature: Int\nlet boilingPoint = 100\n\n\nvar dailyHigh\n// Compiler error: \"Type annotation missing\"\n\nIn the example above dailyTemperature is declared as a variable because we are expecting it to change daily. It has been declared, meaning that the operating system has set aside storage for it, but it has not been initialized with a value. The constant boilingPoint will not change and is declared and initialized in the same line. Below are some examples of using emojis as variable names.\n\nlet 🌕 = \"Full Moon\"\nlet 🌑 = \"New Moon\"\nlet 🌙 = \"Cresent Moon\"\nAccessing and Reassigning Variables and Constants\n\nThe value of a variable can be changed by using the assignment operator to set the value to a different value of the same type. You can also use another variable to set the value of a variable\n\nvar dailyTemperature: Int\nlet reallyHot = 50\n\n\n// Monday\ndailyTemperature = 18\n\n\n// Tuesday\ndailyTemperature = reallyHot\n\nVariables and constants can also be passed directly into functions and methods or returned as the result of function.\n\nlet 🌕 = \"Full Moon\"\nprint(🌕)\n// Output: \"Full Moon\""}],"TypeScript":[{"title":"About TypeScript","description":"TypeScript is a typed language that checks to see if JavaScript variables are of the correct data type before the code is run. It achieves this by using four tools that build on each other in the following order:\n\nA language specification that describes JavaScript syntax as well as new TypeScript-specific syntax\nA compiler program that takes in TypeScript (and therefore also JavaScript) syntax and converts it to the equivalent JavaScript\nA type checker program that reads in TypeScript syntax, understands the types of values every entity is meant to be and notices any “type errors” (mismatches)\nA language server that editors such as VS Code can run to provide build-time hints and refactoring tools\nHistory\n\nTypeScript was released in October 2012 by Microsoft after two years of development. Anders Hejlsberg, the original designer of C#, was the lead designer for the language.\n\nInstallation\n\nTo download the latest stable build via npm, use the following command:\n\nnpm install -g typescript\n\nTo check the installed version, use the following command:\n\ntsc -v\n\nTypeScript was developed by Microsoft and is available in VSCode by default.\n\nPlayground\n\nThere’s an interactive playground provided by the TypeScript team at https://www.typescriptlang.org/play.\n\nIt allows you to type in JavaScript or TypeScript code on the left and see the resultant JavaScript output or any TypeScript type errors.\n\nResources\nTypeScript official site: https://typescriptlang.org\nGitHub repository: https://github.com/microsoft/typescript"},{"title":"Assignability","description":"Assignability is how TypeScript can determine whether a value of a particular data type can be assigned to a variable of the same (or another) data type.\n\nWhen/where assignability takes place\n\nTypeScript perfoms assignability checks whenever a value is being assigned into another location in the computer’s memory, such as:\n\nAssigning values to variables.\nPassing arguments to functions.\nExample: Assigning matching data types\n\nIn this snippet of code, TypeScript sees that the spooky variable is initially assigned a boolean value, so it believes the spooky variable should always be of type boolean.\n\nAssigning a variable of type boolean later on is allowed, as a type is assignable to itself, but assigning any other type, such as a string, is not allowed:\n\nlet spooky = true;\n\n\nspooky = false; // Ok\n\n\nspooky = 'skeletons';\n// Error: Type 'string' is not assignable to type 'boolean'.\nExamples: Comparing object types\n\nWhen comparing object types, TypeScript will ensure that all the required fields exist in the assigning object type. It will also ensure that all field that do exist on the types match up.\n\nIn the following example, we define an interface object called Skeleton, which will serve as a blueprint for the following:\n\nThe names of Skeleton properties.\nThe corresponding : type definitions.\n\nthe first receiveSkeleton() call works because its object argument contains both required properties -spooky and scary- and they are of the correct types.\n\ninterface Skeleton {\n  spooky: boolean;\n  scary: boolean;\n}\n\n\nfunction receiveSkeleton(skeleton: Skeleton) {\n  console.log(skeleton.spooky ? 'Spooky ' : 'Not spooky...');\n  console.log(skeleton.scary ? 'scary!' : 'Not scary...');\n}\n\n\nreceiveSkeleton({ spooky: true, scary: false }); // Ok\n\nThe second example throws an Error because the spooky property is of type string instead of boolean:\n\nreceiveSkeleton({\n  spooky: 'Very!',\n  scary: true,\n});\n\n\n// Ouptut --> Error: Type 'string' is not assignable to type 'boolean'\n\nThis third and final example throws an Error because the object we passed to receiveSkeleton was missing a scary property.\n\nreceiveSkeleton({\n  spooky: false,\n});\n\nThe following error will occur, per the TypeScript checker:\n\nError: Argument of type '{ spooky: false; }'\nis not assignable to parameter of type 'Skeleton'.\nProperty 'scary' is missing in type '{ spooky: false; }'\nbut required in type 'Skeleton'."},{"title":"Arrays","description":"In TypeScript, arrays are considered to be collections of single, “generic” types of values. All elements must be of the same type of data as prescribed in the array definition.\n\nDefining an array\n\nArray types can be inferred during the initialization of a new array.\n\nIn this example, the vowels array is inferred to consist of elements of type string:\n\nconst vowels = ['a', 'e', 'i', 'o', 'u'];\n\n\nvowels.push('y'); // Ok\n\n\nvowels.push(7);\n// Error: Argument of type 'number' is not assignable to parameter of type 'string'.\n\nArrays can also be defined with the “generic” type of its elements already preset in two ways:\n\nconst vowels: string[] = ['a', 'e', 'i', 'o', 'u'];\n\n\n// alternate way using Array class\nconst altVowels: Array<string> = ['a', 'e', 'i', 'o', 'u'];\n\nMore than one type can be prescribed in the array definition with the “or” | operator:\n\nconst numbers: (string | number)[] = [1, '2', 3, 'four'];\n\n\n// Alternative syntax\n// const numbers: [string, number] = [1, \"2\", 3, \"four\"];\n\nAs long as each element in numbers is of type string or number, it is valid.\n\nArray Types\n\nAn array type consists of the type of values inside the array followed by square brackets [].\n\nArrays without any initial contents may be declared as that type to tell TypeScript what will later go into them.\n\nIn this example, dates doesn’t initially include a value, so declaring it as Date[] tells TypeScript what’s allowed in it:\n\nconst dates: Date[] = [];\n\n\ndates.push(new Date('2021-12-1994')); // Ok\n\n\ndates.push(10241995);\n// Error: Argument of type 'number' is not assignable to parameter of type 'Date'."},{"title":"Classes","description":"With TypeScript, class objects can use type annotation to describe the relationship between class members and their static types. Classes are a core part of the JavaScript language that TypeScript respects. In addition to type annotations, TypeScript adds a few new syntaxes to help write classes in a type-safe manner.\n\nMembers\n\nClass member types work similarly to parameter and variable types.\n\nIf an initial value exists, the member’s type is inferred to be that type.\nIf no initial value exists, the member is implicitly of type any unless a type annotation exists on its name.\n\nIn the following Box class, count is inferred to be of type number because its initial value is 0, while value is explicitly declared as type string.\n\nclass Box {\n  count = 0;\n  value: string;\n\n\n  constructor(value: string) {\n    this.value = value;\n  }\n}\n\nTherefore, asking for the count of a Box instance is of type number, and the value is of type string:\n\nconst myBox = new Box('stuff');\nmyBox.count; // Type: number\nmyBox.value; // Type: string\nMember Visibility\n\nJavaScript has a # syntax to mark a member as private, meaning it can only be accessed inside its class:\n\nclass Secret {\n  #value: string;\n\n\n  constructor(value: string) {\n    this.#value = value;\n  }\n\n\n  getValue() {\n    return this.#value;\n  }\n}\n\n\nconst mySecret = new Secret('shhh');\n\n\nmySecret.getValue(); // Ok\n\n\nmySecret.#value;\n// Error: Property '#value' is not accessible outside\n// class 'Secret' because it has a private identifier.\nPublic, Private, or Protected\n\nSeparately, TypeScript also supports adding public, protected, or private in front of a class member to indicate whether the member may be used outside that class.\n\npublic (default): anybody may access that member, anywhere.\nprotected: only the class or its derived classes may access that member.\nprivate: only the class itself may access that member.\n\nThe key difference between JavaScript’s # syntax and TypeScript’s privacy keywords are that:\n\nJavaScript’s # syntax changes the name of the member.\nTypeScript’s privacy keywords exist only in the type system; the member’s name is not changed.\n\nIn this example, the Base class sets up five variables:\n\nThe first two, first and second, are publicly accessible.\nThe third, third, is protected and only accessible in the class or a derived class.\nThe fourth and fifth, fourth and fifth, are set to private with private and #, respectively.\nclass Base {\n  // These two are functionally equivalent\n  first = '';\n  public second = '';\n\n\n  protected third = '';\n\n\n  private fourth = '';\n  #fifth = '';\n}\n\nThe Derived class uses the extends keyword to become a child of the Base class. In the example below, a .test() method is used to borrow from members of the parent Base class:\n\nclass Derived extends Base {\n  test() {\n    this.first; // Ok: public\n    this.second; // Ok: public\n\n\n    this.third; // Ok: protected\n\n\n    this.fourth;\n    // Error: Property 'fourth' is private\n    // and only accessible within class 'Base'.\n\n\n    this.fifth;\n    // Error: Property '#fifth' is not accessible outside\n    // class 'Base' because it has a private identifier.\n  }\n}\n\nNotice how first, second, and even the protected third, are all accessible within the Derived class definition. With fourth and fifth, however, they are both private members of Base. Therefore, they are not accessible inside of Derived.\n\nThe example below shows how some members of Dervied can be invoked through an instance variable, derived, while others are not as accessible. While third can be used within the actual Derived classs, as a protected member, it cannot be used outside of the class with an instance variable.\n\nconst derived = new Derived();\n\n\nderived.first; // Ok: public\nderived.second; // Ok: public\n\n\nderived.third;\n// Error: Property 'third' is protected\n// and only accessible within class 'Base'.\n\n\nderived.fourth;\n// Error: Property 'fourth' is private\n// and only accessible within class 'Base'.\n\n\nderived.fifth;\n// Error: Property '#fifth' is not accessible outside\n// class 'Base' because it has a private identifier.\nImplementing Interfaces\n\nClasses can use the TypeScript interface keyword to further define the “shape” of the class object. This means that instances of the class are assignable to a given interface type.\n\nTo use interfaces with classes, we use the implements keyword between the class name and name of the interface followed by the opening curly bracket {.\n\nIn this example, the Speaker interface has a single speak() method, so the SpeechGiver class may be marked as implementing it:\n\ninterface Speaker {\n  speak(): string;\n}\n\n\nclass SpeechGiver implements Speaker {\n  constructor(speech: string) {\n    this.speech = speech;\n  }\n\n\n  increaseEmphasis() {\n    this.speech += '!';\n  }\n\n\n  speak() {\n    return this.speech;\n  }\n}\n\nClasses can implement more than one interface, as well, by a comma-separated (,) list of any number of interfaces.\n\nMarking a class as implementing an interface doesn’t change anything about the class itself; it won’t change the types of any members or implicitly add them to the class. It’s purely a way to make sure the class implements the interface properly where it’s declared, rather than when instances of the class happen to not match up with an interface."},{"title":"Function","description":"In TypeScript, type aliases create type definitions that can be reused throughout the code. This is unlike type unions and intersections, where the explicit type information is used repetitively.\n\nSyntax\n\nType aliases require the type keyword and a name. They can be created in two ways.\n\nTHey can be set as an object that describes the members and their respective types.\ntype myType = {\n  memberOne: string;\n  memberTwo: number;\n}\n\n\nlet favoriteNum: myType = {\"my favorite number is \", 42}\nThey can also refer to other known types, like a union type.\ntype myType = string | number;\n\n\nlet favoriteNum: myType = '42';\n\nLater on, whenever the name is used, TypeScript will assume this refers to the aliased value. Type aliases are similar to interfaces in terms of syntax and behavior. However, a key difference is that an interface can have members added later on whereas type aliases can’t be changed after being defined.\n\nType Aliases with Type Guards\n\nIn this example, the StringsIsh type alias can be used in place of the type union with several members. When applied to the logAllStrings() function:\n\ntype StringsIsh = string | string[] | null | undefined;\n\n\nfunction logAllStrings(values: StringsIsh) {\n  if (values === null || typeof values === 'undefined') return;\n\n\n  if (typeof values === 'string') {\n    console.log(values);\n  } else {\n    values.forEach(logAllStrings);\n  }\n}\n\n\nlogAllStrings('hello'); // Ok\nlogAllStrings(['hello', 'world']); // Also Ok\n\nThe first type guard checks to see if values matches either null or undefined in the StringIsh type alias. Next, the if/else-statement checks for a base case of values being of type string. Otherwise, it recursively invokes logAllStrings again.\n\nType Aliases as Generics\n\nType aliases may be generic and may contain any type description, including:\n\nPrimitives\nLiterals\nObject types\n\nThe following Result<T> type may contain a value, T, or an object containing the value, { value: T }:\n\ntype Result<T> = T | { value: T };\n\n\nlet value: Result<string> = 'hello'; // Ok\nlet other: Result<string> = { value: 'world' }; // Also Ok"},{"title":"Functions","description":"With functions, TypeScript infers the types of its parameters as well as any return value.\n\nFunction Parameters\n\nThe types of function parameters work similarly to variable declarations. If the parameter has a default value, it will take on the type of that value. Otherwise, we may declare the type of that parameter by adding a type annotation after its name.\n\nHere, the logAgeAndName() function explicitly declares age to be of type number, while name is inferred to be of type string from its default value:\n\nfunction logAgeAndName(age: number, name = '(anonymous)') {\n  console.log(`${name}, age ${age}`);\n}\n\n\nlogAgeAndName(16, 'Mulan'); // ok: Mulan, age 16\n\n\nlogAgeAndName(0); // also ok: (anonymous), age 0\n\n\nlogAgeAndName('Mulan', 16);\n// Argument of type 'string' is not assignable to parameter of type 'number'\n\nThe last use of logAgeAndName() shows that the order of the parameters passed to the function matter. The first agrument is expected to be of type number while the second is inferred to be of type string.\n\nOptional Parameters\n\nFunction parameters can be made optional by adding a ? question mark after their name, before any type annotation. TypeScript will understand that they don’t need to be provided when the function is invoked. Additionally, their type is a union that includes undefined. This means that if a given function does not use the optional parameter, its value is set to undefined.\n\nThe following logFavoriteNumberAndReason() function indicates favorite as a required number and reason as an optional string, so the function must be called with at least one number parameter:\n\nfunction logFavoriteNumberAndReason(favorite: number, reason?: string) {\n  console.log(`Favorite: ${favorite}!`);\n\n\n  if (reason) {\n    console.log(`Because: ${reason}!`);\n  }\n}\n\n\nlogFavoriteNumberAndReason(7, 'an esoteric video game reference'); // Ok\nlogFavoriteNumberAndReason(9001); // Ok\n\n\nlogFavoriteNumberAndReason();\n// Error: Expected 1-2 arguments, but got 0.\nReturn Types\n\nMost functions are written in a way that TypeScript can infer what value they return by looking at all the return statements in the function. Functions that don’t return a value are considered to have a return type of void.\n\nIn this example, the getRandomFriend() function is inferred to return a string type because all return statements have a value of type string, including the fallback parameter:\n\nfunction getRandomFriend(fallback: string) {\n  switch (Math.floor(Math.random() * 5)) {\n    case 0:\n      return 'Josh';\n    case 1:\n      return 'Sara';\n    case 2:\n      return 'Sonny';\n    default:\n      return fallback;\n  }\n}\n\n\nconst friend = getRandomFriend('Codey'); // Type: string\n\nThe return type of a function can be declared by adding a type annotation after the ) right parenthesis following its list of parameters. Doing so can be useful in two situations:\n\nWe can make sure the function returns that type.\nTypeScript will not attempt to infer the return type of a recursive function.\n\nThe following recursive fibonacci() function needs an explicit : number return type annotation for TypeScript to understand it. This returns type number:\n\nfunction fibonacci(i: number): number {\n  if (i <= 1) {\n    return i;\n  }\n\n\n  return fibonacci(i - 1) + fibonacci(i - 2);\n}\nFunction Types\n\nFunction types may be represented in the type system. They look a lot like an arrow lambda, but with the return type instead of the function body.\n\nThis withIncrementedValue() takes in a receiveNewValue parameter function that itself takes in a number and returns nothing (void).\n\nlet value = 0;\n\n\nfunction withIncrementedValue(receiveNewValue: (newValue: number) => void) {\n  value += 1;\n  receiveNewValue(value);\n}\n\n\nwithIncrementedValue((receivedValue) => {\n  console.log('Got', receivedValue);\n});\n\nFunction parameters’ types may be inferred if their parent function is in a location with a known function type. In the prior example, the receivedValue parameter was inferred to be type number."},{"title":"Generics","description":"In TypeScript, generics are used to assign multiple types to a function or variable without the value losing that specific type information upon return. The any keyword is similar in that it accomodates any and all types. However, it will not retain specific type information.\n\nSyntax\n\nGenerics are defined with < > brackets surrounding name(s) of the generic type(s), like Array<T> or Map<Key, Value>.\n\ninterface MyType<GenericValue> {\n  value: GenericValue;\n}\n\n\nlet myVar: MyType<string> = { value: 'Hello, World!' };\n\nGeneric types can be used with the following:\n\nClasses\nFunctions\nInterfaces\nType aliases\nExample of Using Generics\n\nIn the following snippet, Box<Value> is a generic interface that with a generic Value type within. Next, two variables, numberBox and stringBox, are explicitly declared to be of type Box<number> and Box<string>, respectively:\n\ninterface Box<Value> {\n  value: Value;\n}\n\n\nlet numberBox: Box<number> = { value: 7 };\nlet stringBox: Box<string> = { value: 'Marathon' };\nInferring Generic Types\n\nGenerics can be inferred from usage when not explicitly provided.\n\nHere, logAndReturnValue<Value> is inferred first to have a generic Value of type Date:\n\nfunction logAndReturnValue<Value>(value: Value): Value {\n  console.log(value);\n  return value;\n}\n\n\nconst result = logAndReturnValue(new Date('2021-12-21')); // Type: Date\n\nHere, the KeyValueStore class instance is inferred to have generic <string, number>, and its makePair(), therefore, returns type [string, number]:\n\nclass KeyValueStore<Key, Value> {\n  #key: Key;\n  #value: Value;\n\n\n  constructor(key: Key, value: Value) {\n    this.#key = key;\n    this.#value = value;\n  }\n\n\n  makePair(): [Key, Value] {\n    return [this.#key, this.#value];\n  }\n}\n\n\nconst store = new KeyValueStore('year', 2794);\nconst pair = store.makePair(); // Type: [string, number]"},{"title":"Narrowing","description":"Narrowing is a TypeScript process that refines a value of multiple types into a single, specific type.\n\nUnion types represent entities that may be one of two or more different types. Because they only allow access to members known to be on all possible types, we need to narrow down a value to a more specific type before using non-shared members.\n\nWhere Narrowing Happens\n\nTypeScript recognizes types as being narrowed when it sees branches of JavaScript control-flow logic, including:\n\nif/else conditional statements.\nOther conditionals, like ternaries and switches.\nLooping statments, such as for- and while-loops.\nTruthiness checks for entities that don’t point to false-like values.\n\nIf an area of code can only be reached if a value is of a particular type, TypeScript will infer the value to be of that type in that control flow branch.\n\nExample: Narrowing with if Statement\n\nIn this example, our logValueIfExists() function accepts a value parameter with a union-type of string | undefined. If we want TypeScript to explicitly narrow our value down to a string type, we can use an if statement to act as a “type guard”.\n\nfunction logValueIfExists(value: string | undefined) {\n  if (typeof value === 'string') {\n    console.log(`Yay! ${value}!`);\n  }\n}\n\n\nlogValueIfExists('narrowing');\n// output: Yay! narrowing!\n\nWe invoked logValueIfExists() with a string variable, “narrowing”. Since the value is of type string, the code in the if statement will run and a new string will be logged to the console.\n\nExapmle: Narrowing with truthiness\n\nIn the example below, we changed the if statement slightly to check if value has any value that is “truthy” and doesn’t evaluate to a falsey value such as 0, false, or undefined.\n\nfunction logValueIfExists(value: string | undefined) {\n  value; // Type: string | undefined\n\n\n  if (value) {\n    console.log(`Yay! ${value}!`);\n\n\n    value; // Type: string\n    value.length; // Type: number\n  }\n\n\n  value.length;\n  // Error: Object is possibly 'undefined'.\n}\n\n\nlogValueIfExists('truthiness');\n// output: Yay! truthiness!\n\n\nlet newValue;\nlogValueIfExists(newValue);\n// newValue is \"undefined\"; nothing is logged.\n\nOutside of the if statement, value is a union type (string | undefined) and is not narrowed, meaning that calling value.length won’t work. Inside the if statment, because value was narrowed to a string type, it now has a length property."},{"title":"Interfaces","description":"Interfaces are used to “shape” an object by describing a certain set of members and/or type annotations.\n\nSyntax\n\nInterfaces may be declared by:\n\nStarting with the interface keyword.\nGiving the interface a name.\nCreating an object that contains a set of members and/or type annotations.\ninterface myType {\n  memberOne: string;\n  memberTwo: number;\n};\n\n\nlet myVar: myType = {\"My favorite number is \", 42 };\nDog Interface Example\n\nIn this example, the Dog interface declares fluffy and woof members. Any value declared to be of type Dog is therefore known to have those members:\n\ninterface Dog {\n  fluffy: boolean;\n  woof(): string;\n}\n\n\nfunction interactWithDog(dog: Dog) {\n  dog.woof();\n\n\n  if (dog.fluffy) {\n    console.log('What a floof!');\n  }\n\n\n  dog.bark();\n  // Error: Property 'bark' does not exist on type 'Dog'.\n}\n\nMembers that do not exist in the interface, such as bark(), cannot be accessed and will throw a type error\n\nOptional Members\n\nHere, the Pet interface uses ? to set name as an optional member. The only member that is required is species. Declaring an object of type Pet doesn’t need a name but does need a species:\n\ninterface Pet {\n  name?: string;\n  species: string;\n}\n\n\nlet anonymous: Pet = { // Ok\n  species: \"Dog\";\n};\n\n\nlet named: Pet = {\n  name: \"Emerald\",\n  species: \"Budgie\",\n};\n\n\nlet invalid: Pet = {\n  name: \"My Rock\",\n}\n// Error: Property 'species' is missing in type\n// '{ name: string; }' but required in type 'Pet'.\nInterface Extensions\n\nInterfaces may be marked as extending another interface. Doing so indicates that the derived child interface (the interface extending others) includes all members from the base parent interfaces (the interface being extended).\n\nTo mark an interface as extending other(s), add the extends keyword after its name followed by any number of interfaces to extend, with , commas between interface names.\n\nIn this example, the Cat interface is given a .walk() method by being an extension of the Animal interface. However, instance of type Animal don’t have access to members and methods defined in the Cat interface:\n\ninterface Animal {\n  walk(): void;\n}\n\n\ninterface Cat extends Animal {\n  fluffy: boolean;\n  purr(): string;\n}\n\n\nfunction workWithAnimals(animal: Animal, cat: Cat) {\n  animal.walk(); // Ok: defined on Animal\n  cat.walk(); // Ok: Cat extends Animal\n\n\n  if (cat.fluffy) {\n    // Ok: defined on Cat\n    console.log('Floof!!');\n    cat.purr(); // Ok: defined on Cat\n  }\n\n\n  animal.purr();\n  // Error: Property 'purr' does not exist on type 'Animal'.\n}"},{"title":"Tuples","description":"In TypeScript, tuple types are defined as array-like containers with a fixed sized and the types of each member element already set.\n\nThey have two distinct features:\n\nThey know their size as well as exactly how many elements it contains.\nThey already know the data type of each element.\nSyntax\n\nTuples can have a mix of different data types and look like an array consisting of types as values inside:\n\ntype myTuple: [string, number, boolean] = [\"1\", 2, true];\n\nThey consist of a left square bracket [, comma-separated list of types, and a right square bracket ]. The literal values, “1”, 2, and true, must map to each element’s types, string, number, and boolean, in the correct order.\n\nDestructuring a Tuple\n\nLike arrays and objects, tuples can be deconstructed into new variables that represents each element and their type. For example, here is a variable, popStar, with a given tuple type. One the other line, the popStar is destructured into four separate variables through its tuple type:\n\nconst popStar: [string, number, string, boolean] = [\n  'Lil Nas X',\n  22,\n  'Old Town Road',\n  true,\n];\n\n\nconst [popStarName, age, popSingle, stillActive] = popStar;\n\n\nconsole.log(`${popStarName} is ${age} years old.`);\n\n\nconsole.log(\n  `They are ${\n    stillActive\n      ? 'still active in the industry'\n      : 'no longer active in the industry'\n  }.`\n);\n\n\nconsole.log(`One of their most famous songs is ${popSingle}.`);\n\nDestructuring tuple types allows to be able to better interpolate their values and the output will be:\n\nLil Nas X is 22 years old.\nThey are still active in the industry.\nOne of their most famous songs is Old Town Road\nStoring Returned Values in Tuples\n\nTuples are particularly useful for representing multiple return values from functions, or groups of values that are meant to be used together.\n\nIn this example, the positiveDifference() function is declared as returning an array consisting of a string and a boolean function:\n\nfunction positiveDifference(left: number, right: number): [number, boolean] {\n  return left > right ? [left - right, true] : [right - left, false];\n}\n\n\nconst [difference, isPositive] = positiveDifference(7, 49);\n\n\ndifference; // Type: number, Value: 42\nisPositive; // Type: boolean, Value: false"},{"title":"Primitives","description":"TypeScript supports primitives, which are the basic types in JavaScript that make up data other than functions and objects. TypeScript recognizes the following seven primitive types in JavaScript:\n\nbigint\nboolean\nnull\nnumber\nstring\nsymbol\nundefined\n\nIf a value such as a parameter or variable is declared to be one of these, it is allowed to be assigned any of the literal values that are of that primitive type.\n\nIn this example, the variable decoration is initially declared to be type string. This means that decoration is allowed to be assigned, and reassigned, a plethora of string values:\n\nlet decoration: string;\n\n\ndecoration = 'Cobweb';\ndecoration = \"Jack O'Lantern\";\ndecoration = 'Lights';\n\nIn other words:\n\nA primitive is a basic type of data, such as number or string\nA literal is an example of a primitive with a value, such as 1337 or \"ghost\""},{"title":"Type Annotations","description":"TypeScript uses type annotation to explicitly type things such as variables, functions, and classes.\n\nFor the most part, TypeScript does a good job at inferring types from the codebase at build-time. However, some constructs in TypeScript, such as variables without an initial value or members of interfaces, don’t have an initially inferable type. This is where type annotations can be really useful.\n\nSyntax\n\nType annotations consist of a : colon followed by the name of a type. They exist after the name of the construct they’re declaring the type for.\n\n// Class and interface members\nclass myClass {\n  memberOne: string;\n  memberTwo: string;\n}\n\n\ninterface myInterface {\n  memberOne: string;\n  memberTwo: number;\n  memberThree: boolean;\n}\n\n\n// Function Parameters\nfunction myFunc(memberOne: string, memberTwo: string) {\n  ...\n}\n\n\n// Function Returns\nfunction myFunc(memberOne, memberTwo): string {\n  return memberOne + memberTwo;\n}\n\n\n// Variables\nlet myVar: string = \"Hello, World!\";\nType Annotations and Dates\n\nIn the following code snippet, the date variable doesn’t have an initial value, but with a Date type annotation. Later on, when date is assigned a value, it must receive a value of type Date. The first assignment of a new Date is the right type. However, the second assignment to a number, 10.31, is not:\n\nlet date: Date;\n\n\ndate = new Date('2021-10-31'); // Ok\n\n\ndate = 10.31;\n// Error: type 'number' is not assignable to type 'Date'.\nAfter TypeScript is Compiled\n\nTypeScript type annotations don’t get compiled down to the output JavaScript, as they are a TypeScript syntax and not JavaScript. Removing comments from the above code would make it look roughly like this if run through the TypeScript compiler (tsc):\n\nlet date;\ngenre = new Date('2021-10-31');\ngenre = 10.31;"},{"title":"Unions","description":"Some values may be one of multiple possible types. TypeScript refers to these “either or” types as type unions. This refers to the set theory concept of being a “union” of multiple possible types.\n\nSyntax\n\nA union type is written as a series of other types with a | vertical pipe between them.\n\nlet myVar: number | string = '42';\nUnion Example\n\nFor example, the following logEither() function takes in a value that can be either a number or string:\n\nfunction logEither(value: number | string) {\n  console.log(value);\n}\n\n\nlogEither('Durandal'); // Ok\nlogEither(7777777); // Also Ok\n\n\nlogEither(false);\n// Error: Type 'boolean' is not assignable to type 'number | string'.\n\nOptional values, including optional parameters and members, are implicitly type | undefined.\n\nUnion type Members\n\nWhen a value is a union type, TypeScript will only allow access to members that exist on all possible types.\n\nIn this example, we use a pair of ternary operators to create a value. This set the type of value to boolean | string | string[] and the only shared member is the toString() function. No others, such as length, are allowed since it can’t be applied to a boolean-type value:\n\n// Type: boolean | string | string[]\nconst value =\n  Math.random() > 0.5\n    ? false\n    : Math.random() > 0.5\n    ? 'Leela'\n    : ['Durandal', 'Thoth'];\n\n\nvalue.toString(); // Ok: exists on all three\n\n\nvalue.length;\n/*\n * Error: Property 'length' does not exist\n * on type 'false | \"Leela\" | string[]'.\n * Property 'length' does not exist on type 'false'.\n */\n\nSee Narrowing for how to narrow down union types into their more specific types."},{"title":"Variables","description":"In TypeScript, besides being typed, variables are expected to follow the same rules and guidelines that they do with JavaScript.\n\nSyntax\n\nTypeScript variables are generally inferred to be whatever basic type of value they are initially assigned with. Later in code, only values that are of that same basic type may be assigned to the variable. The term for whether a type is assignable to another type is assignability.\n\nlet myVar: string;\n\n\nmyVar = 'Hello'; // Ok\nmyVar = 'World!'; // Also Ok\nmyVar = 42; // Not Ok: Type 'number' is not assignable to type 'string'.\nExamples with Variables\n\nIn this snippet of code, TypeScript sees that the spooky variable is initially assigned a boolean value, so it believes the spooky variable should always be of type boolean. Assigning a variable of type boolean later on is allowed, as a type is assignable to itself:\n\nlet spooky = true;\n\n\nspooky = false; // Ok\n\nIf a variable is assigned a different type of value, TypeScript will notice and emit a type checking complaint. Those type checking complaints can be surfaced as:\n\nErrors on the command-line.\nSyntax highlights in the code editor.\n\nIn this code snippet, the scary variable is initially assigned the value \"skeletons\", which is a string type. Later, assigning the decimal number 10.31 is not allowed because a number type is not assignable to a variable of type string:\n\nlet scary = 'skeletons';\n\n\nscary = 10.31;\n// Error: Type 'number' is not assignable to type 'string'"}],"General":[{"title":"Aaron Swartz","description":"Aaron Swartz (1986-2013) was an American programmer, writer, entrepreneur, and internet activist. He was involved in the development of the RSS web feed format, Markdown language, Creative Commons organization, and Python web framework web.py.\n\nHe was a co-founder of a startup called Infogami, which later became the social news site Reddit. In his later years, he co-founded an activist organization, Demand Progress, and led the charge fighting the Stop Online Piracy Act (SOPA).\n\nWriting\n\nIn 2008, Swartz published an essay called Guerilla Open Access Manifesto, which can be found on the internet and in the The Boy Who Could Change the World book published posthumously in 2016:\n\nSharing isn’t immoral — it’s a moral imperative. Only those blinded by greed would refuse to let a friend make a copy.\n\nUnited States v. Aaron Swartz\n\nIn 2011, Swartz was arrested by Massachusetts Institute of Technology (MIT) police on state breaking-and-entering charges, after connecting to the campus network in an unlocked closet, to massive download academic journal articles.\n\nFederal prosecutors later charged him with wire fraud and violations of the Computer Fraud and Abuse Act, carrying a maximum penalty of $1 million in fines, 35 years in prison, asset forfeiture, and supervised release.\n\nSwartz declined a plea bargain under which he would have served six months in federal prison. Two days after the prosecution rejected a counter-offer by Swartz, he was found dead in his Brooklyn apartment, where he committed suicide. He was 26 years old."},{"title":"Abstract Factory Pattern","description":"The abstract factory pattern utilizes a common interface for multiple factories without defining their concrete model classes. It is often thought of as a factory of factory patterns where object composition is used to separate instantiation logic from application logic.\n\nUML Design\n\nJava Example\n\nTo illustrate the abstract factory pattern, below is a real-world example, written in Java, that explores potential considerations for a banking account system. A new customer will request either a current or savings account. The customer may also be entitled to different privileges depending on their credit score. Below is a table of accounts and their privileges:\n\nCustomer Type\tCurrent\tSaving\nGold\tMax overdraft limit of 3500\tInterest rate of 5%\nSilver\tMax overdraft limit of 1200\tInterest rate of 3%\nBronze\tMax overdraft limit of 500\tInterest rate of 1.5%\nBuilder\tNo overdraft\tInterest rate of 1.5%\n\nTo simulate requesting and receiving a customer’s credit score, a gateway has been mocked below. When given a customer’s name, theCreditAgencyGateway class should return an appropriate Customer object. We can later use this class to see the different paths through our abstract factory.\n\npublic class CreditAgencyGateway {\n  // Depending on which name is searched for, a different customer object is returned\n  public Customer getCustomer(String name) {\n    return switch (name) {\n      case \"Harry\" -> new Customer(\"Harry\",\n                                   \"Potter\",\n                                   LocalDate.of(1980, 7, 31),\n                                   \"4 Privet Drive, Little Whinging\",\n                                   795);\n      case \"Ron\" -> new Customer(\"Ron\",\n                                 \"Weasley\",\n                                 LocalDate.of(1980, 3, 1),\n                                 \"The Burrow, Devon\",\n                                 379);\n      case \"Hermione\" -> new Customer(\"Hermione\",\n                                      \"Granger\",\n                                      LocalDate.of(1979, 9, 19),\n                                      \"Hampstead Garden Suburb, London\",\n                                      843);\n      default -> throw new IllegalArgumentException(\"Could not return the credit history for \" + name);\n    };\n  }\n}\n\nThe CreditAgencyGateway class uses a switch statement to query a provided name. If the name is recognized, a new customer is returned. Otherwise, an exception is thrown.\n\nOne of the main advantages of factory patterns is they allow for a large amount of model classes and enforce a common interface between them. In the code below, an abstract model CurrentAccount class works as an extension for its concrete sub-classes to be based on:\n\npublic abstract class CurrentAccount {\n  private final String accountUID = UUID.randomUUID().toString();\n  private final Customer accountHolder;\n  private int balance;\n  private int agreedOverdraftLimit;\n\n\n  public CurrentAccount(Customer accountHolder, int initBalance, int agreedOverdraftLimit) {\n    this.accountHolder = accountHolder;\n    this.balance = initBalance;\n    this.agreedOverdraftLimit = agreedOverdraftLimit;\n  }\n\n\n  public void addFunds(final int amount) {\n    balance += amount;\n  }\n\n\n  public void withdrawFunds(final int amount) {\n    if (amount < balance + agreedOverdraftLimit) {\n      balance -= amount;\n    } else {\n      System.out.println(\"Insufficient funds. Unable to withdraw \" + amount);\n    }\n  }\n\n\n  // Enforces concrete classes to override this method\n  public abstract void increaseOverdraft(int requestedLimit);\n\n\n  // Getters below\n}\n\nThe parent CurrentAccount class above, as well as providing the common fields and constructor, requires its children to implement the .increaseOverdraft() method. This is the differentiating feature described between each current account.\n\nThe code snippets below are the concrete implementations of CurrentAccount. The first is the Gold-level:\n\npublic class GoldPersonal extends CurrentAccount {\n  // The Gold Personal has a high max overdraft limit\n  public static final int MAX_OVERDRAFT = 3500;\n\n\n  public GoldPersonal(Customer accountHolder, int initBalance, int agreedOverdraftLimit) {\n    super(accountHolder, initBalance, agreedOverdraftLimit);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void increaseOverdraft(int requestedLimit) {\n    if (requestedLimit < MAX_OVERDRAFT) {\n      this.setAgreedOverdraftLimit(requestedLimit);\n    }\n  }\n}\n\nNext is the Silver-level implementation of the CurrentAccount:\n\npublic class SilverPersonal extends CurrentAccount {\n  // The Silver Personal has a mid max overdraft limit\n  public static final int MAX_OVERDRAFT = 1200;\n\n\n  public SilverPersonal(Customer accountHolder, int initBalance, int agreedOverdraftLimit) {\n    super(accountHolder, initBalance, agreedOverdraftLimit);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void increaseOverdraft(int requestedLimit) {\n    if (requestedLimit < MAX_OVERDRAFT) {\n      this.setAgreedOverdraftLimit(requestedLimit);\n    }\n  }\n}\n\nHere is the Bronze-level implementation:\n\npublic class BronzePersonal extends CurrentAccount {\n  // The Bronze Personal has a low max overdraft limit\n  public static final int MAX_OVERDRAFT = 500;\n\n\n  public BronzePersonal(Customer accountHolder, int initBalance, int agreedOverdraftLimit) {\n    super(accountHolder, initBalance, agreedOverdraftLimit);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void increaseOverdraft(int requestedLimit) {\n    if (requestedLimit < MAX_OVERDRAFT) {\n      this.setAgreedOverdraftLimit(requestedLimit);\n    }\n  }\n}\n\nAnd finally, the Credit Builder:\n\npublic class CreditBuilder extends CurrentAccount {\n  // The Credit Builder does not allow for an overdraft\n  public static final int MAX_OVERDRAFT = 0;\n\n\n  public CreditBuilder(Customer accountHolder, int initBalance, int agreedOverdraftLimit) {\n    super(accountHolder, initBalance, agreedOverdraftLimit);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void increaseOverdraft(int requestedLimit) {\n    if (requestedLimit < MAX_OVERDRAFT) {\n      this.setAgreedOverdraftLimit(requestedLimit);\n    }\n  }\n}\n\nIn each concrete current account, a static variable (MAX_OVERDRAFT) has been provided and constructed with the correct value. This is then used in the .increaseOverdraft() method to ensure this limit is not exceeded.\n\nBelow provides an abstract model SavingAccount class for its concrete sub-classes to be based on:\n\npublic abstract class SavingAccount {\n  private final String accountUID = UUID.randomUUID().toString();\n  private final Customer accountHolder;\n  private final LocalDate dateOpened;\n  private double balance;\n\n\n  public SavingAccount(Customer accountHolder, LocalDate dateOpened, double initBalance) {\n    this.accountHolder = accountHolder;\n    this.dateOpened = dateOpened;\n    this.balance = initBalance;\n  }\n\n\n  public void addFunds(final int amount) {\n    balance += amount;\n  }\n\n\n  public void withdrawFunds(final int amount) {\n    balance -= amount;\n  }\n\n\n  // Enforces concrete classes to override this method\n  public abstract void addInterest();\n\n\n  // Getters below\n}\n\nMuch like CurrentAccount, SavingAccount provides the common fields and constructor and requires its children to implement the .addInterest() method. This is the differentiating feature described between each savings account.\n\nBelow provides the concrete implementations of SavingAccount for this example. The first is the Gold-level:\n\npublic class GoldSaver extends SavingAccount {\n  // The Gold Saver has a high interest rate\n  public static final double INTEREST_RATE_MULTIPLIER = 1.05;\n\n\n  public GoldSaver(Customer accountHolder, LocalDate dateOpened, double initBalance) {\n    super(accountHolder, dateOpened, initBalance);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void addInterest() {\n    if (LocalDate.now().getMonth() == this.getDateOpened().getMonth()\n            && LocalDate.now().getDayOfMonth() == this.getDateOpened().getDayOfMonth()) {\n      this.setBalance(this.getBalance() * INTEREST_RATE_MULTIPLIER);\n    }\n  }\n}\n\nThen the Silver-level:\n\npublic class SilverSaver extends SavingAccount {\n  // The Silver Saver has a mid interest rate\n  public static final double INTEREST_RATE_MULTIPLIER = 1.03;\n\n\n  public SilverSaver(Customer accountHolder, LocalDate dateOpened, double initBalance) {\n    super(accountHolder, dateOpened, initBalance);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void addInterest() {\n    if (LocalDate.now().getMonth() == this.getDateOpened().getMonth()\n            && LocalDate.now().getDayOfMonth() == this.getDateOpened().getDayOfMonth()) {\n      this.setBalance(this.getBalance() * INTEREST_RATE_MULTIPLIER);\n    }\n  }\n}\n\nAnd finally the Bronze-level implementation:\n\npublic class BronzeSaver extends SavingAccount {\n  // The Bronze Saver has a low interest rate\n  public static final double INTEREST_RATE_MULTIPLIER = 1.015;\n\n\n  public BronzeSaver(Customer accountHolder, LocalDate dateOpened, int initBalance) {\n        super(accountHolder, dateOpened, initBalance);\n  }\n\n\n  // Concrete overridden method\n  @Override\n  public void addInterest() {\n    if (LocalDate.now().getMonth() == this.getDateOpened().getMonth()\n            && LocalDate.now().getDayOfMonth() == this.getDateOpened().getDayOfMonth()) {\n      this.setBalance(this.getBalance() * INTEREST_RATE_MULTIPLIER);\n    }\n  }\n}\n\nIn each concrete savings account, a static variable, the INTEREST_RATE_MULTIPLIER, has been provided and constructed with the correct value. It is then used to calculate interest in the .addInterest() method.\n\nThe purpose of the AccountFactory is to return one of its concrete factories. Below provides the example of the abstract factory AccountFactory.\n\npublic abstract class AccountFactory<T> {\n  // Returns different concrete factory depending on AccountType\n  public static AccountFactory<?> getAccountFactory(AccountType accountType) {\n    return switch (accountType) {\n        case SAVINGS -> new SavingAccountFactory();\n        case CURRENT -> new CurrentAccountFactory();\n        default -> throw new IllegalArgumentException(\"Unknown account type: \" + accountType);\n      };\n  }\n\n\n  // Enforces concrete factories to override this method\n  public abstract T getAccount(Customer customer);\n\n\n  // Returns CustomerType depending on creditScore property. Put in the abstract to reduce duplicate code\n  protected CustomerType getCustomerType(Customer customer) {\n    if (customer.getCreditScore() > 700) {\n      return CustomerType.GOLD;\n    } else if (customer.getCreditScore() > 400) {\n      return CustomerType.SILVER;\n    } else if (customer.getCreditScore() > 200) {\n      return CustomerType.BRONZE;\n    } else {\n      return CustomerType.BUILDER;\n    }\n  }\n}\n\nThe AccountFactory enforces its concrete sub-classes to implement its abstract .getAccount() method. A .getCustomerType() is included to reduce duplication. The same logic for returning a CustomerType is used in CurrentAccountFactory and SavingAccountFactory. We might expect this logic to be in the concrete classes below as they use this logic, but in this example it doesn’t matter.\n\nFinally, the .getAccountFactory() method uses a switch statement to return a concrete factory depending on an AccountType, with the enum provided below:\n\npublic enum AccountType {\n  SAVINGS,\n  CURRENT\n}\n\nThe following factories, CurrentAccountFactory and SavingAccountFactory, are responsible for returning the correct concrete model class when called:\n\npublic class CurrentAccountFactory extends AccountFactory<CurrentAccount> {\n  // Concrete overridden method\n  @Override\n  public CurrentAccount getAccount(Customer customer) {\n    final CustomerType customerType = getCustomerType(customer);\n\n\n    return switch (customerType) {\n      case GOLD -> new GoldPersonal(customer, 0, 0);\n      case SILVER -> new SilverPersonal(customer, 0, 0);\n      case BRONZE -> new BronzePersonal(customer, 0, 0);\n      case BUILDER -> new CreditBuilder(customer, 0, 0);\n      default -> throw new IllegalArgumentException(\"Unable to create account.\");\n    };\n  }\n}\npublic class SavingAccountFactory extends AccountFactory<SavingAccount> {\n  // Concrete overridden method\n  @Override\n  public SavingAccount getAccount(Customer customer) {\n    final CustomerType customerType = getCustomerType(customer);\n\n\n    return switch (customerType) {\n      case GOLD -> new GoldSaver(customer, LocalDate.now(), 0);\n      case SILVER -> new SilverSaver(customer, LocalDate.now(), 0);\n      case BRONZE, BUILDER -> new BronzeSaver(customer, LocalDate.now(), 0);\n      default -> throw new IllegalArgumentException(\"Unable to create account.\");\n    };\n  }\n}\n\nAn implementation has been provided for the .getAccount() method. The CustomerType is worked out using its parent’s getCustomerType method and captured before being used in a switch statement that returns the appropriate objects.\n\nThe Main class below starts the program and acts as the client in this example. It begins by getting a customer from the CreditAgencyGateway and gets an appropriate factory by using the .getAccountFactory() method. Changing the name in the .getCustomer() method or changing the AccountType in the .getAccountFactory() method will yield different results. A specific CurrentAccount or SavingAccount can then be returned by the getAccount method.\n\npublic class Main {\n  public static void main(String[] args) {\n    final CreditAgencyGateway creditAgencyGateway = new CreditAgencyGateway();\n\n\n    // Get customer. Change name to change outputted account types.\n    final Customer customer = creditAgencyGateway.getCustomer(\"Hermione\");\n\n\n    // Capture correct concrete factory\n    AccountFactory<?> accountFactory = AccountFactory.getAccountFactory(AccountType.CURRENT);\n\n\n    // Get correct account\n    final CurrentAccount currentAccount = (CurrentAccount) accountFactory.getAccount(customer);\n    System.out.println(currentAccount.getClass());\n\n\n    // Capture correct concrete factory\n    accountFactory = AccountFactory.getAccountFactory(AccountType.SAVINGS);\n\n\n    // Get correct account\n    final SavingAccount savingAccount = (SavingAccount) accountFactory.getAccount(customer);\n    System.out.println(savingAccount.getClass());\n  }\n}"},{"title":"Ada Lovelace","description":"Ada Lovelace (1815-1852) was an English writer and mathematician and is often considered to be the first computer programmer.\n\nLovelace is known for her work on Charles Babbage’s Analytical Engine, the first programmable general-purpose computer. This machine included many features that are still cornerstones of today’s computers such as an arithmetic logic unit, control flows, and integrated memory.\n\nWhile this machine was revolutionary, the Analytical Engine’s capabilities were misunderstood at the time. However, Ada Lovelace’s excellent implementation for calculating Bernoulli numbers on the conceptual machine became the first published algorithm and aided in legitimizing the practically of such a device.\n\nFun fact: One of the main conference rooms at Codecademy’s old office was named after Ada Lovelace."},{"title":"Abstract Syntax Tree","description":"An abstract syntax tree (AST) is a language-agnostic, hierarchical representation of the elements comprising the source code of a computer program. With a given AST, it is possible to reproduce code that is functionally identical to the source code that originally generated it. In other words, the code can be reproduced in any language. This is why the generation of ASTs is a critical internal step in compiling, as it allows the compiler to interpret the source code in a way that allows it to translate the original language into equivalent machine code.\n\nTokens\n\nTokenization is the process of breaking source code into an array of fundamental elements, or tokens. The AST is a graph of these tokens, specifically arranged to preserve the context of each element.\n\nFor example, the = symbol is both a comparison operator and an assignment operator in some languages. Therefore, tokenization will represent the symbol = but not communicate its function in the program. In an AST, the token’s position in the tree, along with its relation to other tokens, is also represented. So, examining the tree indicates the difference between assigning a to b with a = b on a line by itself and comparing a and b using an if conditional, if a = b then ..., even when = is represented by the same token in both cases.\n\nIf we look at the following pseudocode:\n\nif a = b\n  then\n    return \"equal\"\n  else\n    return a + \" not equal to \" + b\n\nA graphical representation of the AST would look like this:\n\nLike pseudocode, there are many ways to represent an AST. The output for an AST will vary based on the language and tool used to create it. However, all ASTs should have the property of completely representing the source code in a reproducible manner.\n\nUses of an AST\n\nASTs have many uses in different situations, including:\n\nBy compilers to translate source code into equivalent binary forms.\nIn code reviews for identifying redundant elements in a codebase or detecting possible vulnerabilities.\nEfficient refactors such as changing variable names with respect to their scope in the program.\nIsolating a particular method and identifying all sections of the code that refer to that particular method."},{"title":"Algorithm","description":"An algorithm is a formal process used to solve a problem. Algorithms can be represented in a number of formats but are usually represented in pseudocode in order to communicate the process by which the algorithms solve the problems they were created to tackle. Ultimately algorithms are implemented in programming languages which allow them to manipulate data in the ways that the algorithms are intended to. Algorithms are measured in “Big O notation”.\n\nThe word algorithm comes from “Algorismus” which is a latinized name of the influential 10th century polymath Muhammad ibn Musa al-Khwarizmi.\n\nThere are many ways to classify algorithms but one of the best ways to do so is by analysis of its complexity.\n\nTime Complexities\n\nAlgorithms can be categorized by their time complexities:\n\nExponential time: If the time is an exponential function of the input size.\nBrute-force search.\nPolynomial time: If the time is a power of the input size.\nBubble sort has quadratic time complexity.\nLinear time: If the time is proportional to the input size.\nThe traverse of a list.\nLogarithmic time: If the time is a logarithmic function of the input size.\nBinary search algorithm.\nConstant time: If the time needed by the algorithm is the same, regardless of the input size.\nAn access to an array element.\nExample of an Algorithm\n\nThis is a sorting algorithm implemented in Python:\n\n# Python implementation of Bubble Sort\n\n\ndef bubbleSort(_array):\n  n = len(_array)\n\n\n  for i in range(n-1):\n    for j in range(0, n-i-1):\n      if _array[j] > _array[j + 1]:\n        _array[j], _array[j + 1] = _array[j + 1], _array[j]\n\n\n_array = [3, 9, 12, 12, 100, 90]\n\n\nbubbleSort(_array)\n\n\nprint (\"Print sorted data:\")\n\n\nfor i in range(len(_array)):\n  print(\"% d\" % _array[i]),"},{"title":"Alan Turing","description":"Alan Turing (1912-1954) was an English mathematician and computer scientist best known for his work on algorithms, computation, and creating the foundations of theoretical computer science through the development of the Turing machine.\n\nShortly after becoming a Fellow at King’s College in Cambridge, Turing published a paper describing the Turing machine, an abstract machine that can simulate any algorithm’s logic. Turing used this to prove that it is not possible to create an algorithm to determine if a program will ever stop running.\n\nDuring the Second World War, Alan Turing was a key component in breaking the Enigma cipher encrypting all of Nazi Germany’s secret communication. Turing’s work is considered fundamental to deciding the outcome of the war with the information the code-breaking provided.\n\nTuring Test\n\nIn 1950, Turing published a paper in Mind called “Computing Machinery and Intelligence”. It is a seminal paper on the topic of artificial intelligence (AI). The paper was the first to introduce his concept of what is now known as the Turing test (originally called imitation game) to the general public.\n\nI propose to consider the question, “Can machines think?” - Alan Turing, 1950\n\nThe paper questioned whether or not a computer is capable of thinking like a human being. Turing proposed that a computer can be said to possess artificial intelligence if it can mimic human responses under specific conditions.\n\nFun fact: Our main conference room was named after Alan Turing at Codecademy’s old office."},{"title":"Angular","description":"Angular is a free, open-source framework that is TypeScript-based and used for building single-page applications. It was created in 2016 by developers at Google and serves as the second, revamped version of the orginal, JavaScript-based AngularJS.\n\nUnlike React, which is technically a JavaScript library, Angular is a full-fledged framework.\n\nFrom AngularJS to Angular\n\nAngularJS was released in 2010 as one of the first modern front-end frameworks. It came to market in 2010 and rapidly grew popular with developers. Among the features that grew popular with developers were dependency injection, routing, and two-way data binding. It significantly changed how front-end developers wrote code.\n\nLater in 2016, a new version was released that turned out to be a complete revamp of the original framework. Unlike AngularJS, which was written in JavaScript, this version, just called Angular, is written in TypeScript.\n\nSupport by Google for AngularJS (1.x) was discontinued in January 2022 and migrating to the newer Angular (2.x) is highly recommended.\n\nThe MVC Pattern\n\nAngular uses the model-view-controller (MVC) pattern for structuring the code into the following three sections:\n\nThe model represents the data that may eventually be stored in a database and used to populate a web page.\nThe view represents the model data in an interface to be seen and interacted with by the user.\nThe controller contains the logic for the web application and connects the model data with the views.\nRouting and Binding\n\nSingle page applications (SPAs) are built with Angular and feature a URL that doesn’t require a page reload to function. Angular uses routing to map the URL in the web browser to a specific state in the web application.\n\nAngular also uses two-way data binding to inherently link the views and model data with one another. Updates in one causes updates in the other. This allows for data to be readily shared between components throughout the application."},{"title":"API","description":"API stands for Application Programing Interface and is a term used to describe specifications that allow applications to communicate with one another.\n\nAPIs enable exchange of information, and can be a major source of value (utility, market dependence and revenue) to organizations. APIs are significant components in the evolution of applications because the technical ecosystem is built on top of APIs and leverages them to function and provide many services in use today.\n\nCategories\n\nAPIs can be divided into three groups:\n\nPublic APIs, also known as a Open APIs, are available to users with minimal restrictions. An example of this API is Google Maps, which allows users to take advantage of Google’s expansive and detailed map software in a number of ways. Developers can leverage this software and integrate with it in their applications by following the Google Maps API documentation.\n\nPrivate APIs, also known as Internal APIs, are used primarily within a company to share resources and facilitate the business (e.g. Company Warehouse API for managing inventory with code).\n\nPartner APIs require rights or specific licenses for use. These APIs are popular in software-as-a-service platforms (e.g. AWS API).\n\nBenefits and Risks of Using APIs\n\nThe main benefits of using APIs are:\n\nCost savings through the elimination of the need to build and maintain local physical infrastructure and services.\n\nOpportunities to leverage the expertise of other vendors instead of having to reinvent solutions for common problems (authentication, payment processing, maps, etc.).\n\nPossibilities to build new businesses and products based on the exchange of data between users and various online services offering API access to independent developers.\n\nThe main risks associated with using APIs are:\n\nLittle to no control over the impact of vendor-only changes including business infrastructure, version updates, and data collection.\n\nNonsecure APIs can become gateways to hacker attacks. As soon as they are breached, other dependent systems become vulnerable. It is commonly predicted that API abuses will become the most frequent vector of attack in the coming years.\n\nAPIs can be abused by the clients themselves. One example is excessive requests to the API, which is what rate limits are meant to prevent."},{"title":"Array","description":"An array is a collection of stored data that can hold values of various data type. Arrays themselves are considered to be a composite data type. Python uses lists as an equalivalent type.\n\nSyntax\n\nArrays are often created by using square brackets [] with a comma-separated list of individual elements inside:\n\narray = [element0, element1, element2, element3]\n\nNested arrays (arrays within arrays) are also possible:\n\nnested = [elementB, elementC]\nouter = [elementA, nested, element4]\n\nThe length of the outer array is 3 elements-long because the inner nested array counts as an individual element. By itself, the nested array is 2 elements-long.\n\nIndex Number\n\nArray elements are usually referenced by an index number, which represents their position in the sequence.\n\nThe indices of most arrays start with 0:\n\ngroceryList = [\"milk\", \"cookies\", \"berries\", \"carrots\"]\n// index:        0         1          2          3\nThe first element \"milk\" is at index 0.\nThe second element \"cookies\" is at index 1.\n…and so on.\nArrays in Different Languages\nC++\nJavaScript\nJava\nPHP\nPython\nTypeScript\nSwfit\nRuby"},{"title":"Argument","description":"An argument is the actual value of a variable (aka. the parameter) passed into a function.\n\nExample\n\nSuppose we have a function called tripleThis():\n\nfunction tripleThis(x) {\n  return x * 3;\n}\n\n\ntripleThis(6);\n\nThe parameter is x since it is the variable. The argument is 6 since it is the actual value."},{"title":"Augmented Reality","description":"Augmented Reality (AR) is a digitally enhanced real world experience provided through hardware. In many instances, AR provides an additional sensory experience to natural settings. A popular example of AR in mobile applications is the video game Pokémon Go.\n\nAn augogram is the computer generated image that is used to create an Augmented Reality experience. The term for this science and software practice is called augography.\n\nAugmented Reality vs. Virtual Reality\n\nThe difference between augemented reality (AR) and virtual reality (VR) is that augmented reality utilizes the current physical setting of the user while introducing a layer of synthetic digital, sonic or somatic presentation to enhance the user experience whereas VR involves use of a headset to facilitate an experience rooted in the graphic and sonic presentation within the VR setup as opposed to using the individuals more broad physical surroundings for interaction.\n\nAugmented reality is poised to grow substantially in use during the 21st century as it has many potential uses that range from entertainment, medical, commercial, military, fashion and design etc.\n\nAugmented Reality Examples\nViewing merchandise/goods without trying them on at retail stores and shopping platforms (IKEA, Neiman Marcus, etc.)\nFlight/Combat simulation (military, commercial aviation)\nPhysical markers for direction and navigation\n3D commercial/residential design and architecture\nTraining for medical procedures for nurses and doctors"},{"title":"Artificial Intelligence","description":"Artificial Intelligence (AI) refers to both the study of intelligent agents and to the intelligent agents themselves. An “intelligent agent” is any device designed to achieve some goal, receive information from its environment as input and output a response that maximizes success of achieving said goal.\n\nCurrently, AI can be categorized into three groups: narrow, general, and super artificial intelligences.\n\nAI Categories\n\nArtificial Narrow Intelligence (ANI) or Weak AI, are systems that are considered the least computationally potent AI. These systems include much of the contemporary machine learning and deep learning models with singular and narrowed functions such as Object Classification and Speech Recognition.\n\nArtificial General Intelligence (AGI) or Strong AI, are systems that would pass the Turing Test, with an intelligence that produces outputs that are indistinguishable from that of an adult human being. As of publication, no publicly known AGI have been developed.\n\nArtificial Super Intelligence (ASI) or Superintelligence, is another form of AI yet to be developed that contains an intelligence that can produce outputs that would vastly surpass the capacity of a human being.\n\nHistory\n\nThe first true instance of AI is arguable, with some determining the mechanism used to produce Ars generalis ultima (The Ultimate General Art), published by Ramon Llull in 1308 was an artificial intelligence with the mechanical means to create new knowledge from logic and complex mechanical techniques.\n\nIn 1914, Spanish engineer Leonardo Torres y Quevedo demonstrates the first chess-playing machine in Paris, capable of receiving information about a chess game and playing a king and rook endgame against king from any position without the aid of human intervention.\n\nIn 1950, Alan Turing publishes Computing Machinery and Intelligence, introducing with it the concept of the “imitation game”. This would later be known as the Turing Test, which tests a machine’s ability to display behavior and produce output that is indistinguishable from that of an adult person.\n\nThe years ranging from 1956-1974 are considered the renaissance period of artificial intelligence with developments such as semantic nets, allowing machines to solve algebra word problems, and search algorithms that allowed machines to approach solving problems much like solving a maze.\n\nFollowing this period the field of AI experienced a sequence of years in lulls and bursts in progress between the years 1974 and 2011 where computing power and amounts of available data would be considerable bottlenecks. This period ends around 2011 where the advents of machine learning and deep learning have demonstrated great leaps in the field, producing agents such as Deep Blue and AlphaGo, computer programs that are able to beat some of the best human board game players in the world.\n\nEthics\n\nThe ethical implications of artificial intelligence have been explored in philosophy, industry, and culture. Current leaders in AI research with ethics in mind often follow charters that promote inclusion and safety for humanity."},{"title":"Back-End","description":"The back-end of a program or web application serves data to the front-end from sources like a database.\n\nRestaurant Analogy\n\nA common analogy for the relationship of the front-end and back-end are customers at a restaurant (on the “front-end):\n\nThey place their order (or “request”) with the waiter/waitress (or server).\nThe order is then taken to the kitchen (on the “back-end”).\nThere, the order is prepared (or “processed”) with the necessary ingredients (or “data”) to produce the expected food item (or “response”).\nFinally, the food item is brought back out to the dining area for the customer.\nCommon Tasks\n\nBack-end web development can involve a variety of tasks, including:\n\nCreating, integrating, and managing databases.\nUsing back-end frameworks to build server-side software.\nValidating data to make sure it’s formatted correctly before being sent to the database.\nIntegrating user-facing elements with server-side elements to make sure that information is being sent to the right place so the server can retrieve it.\nBack-End Tools\n\nBack-End Developers use a range of technology and software, many of which fall into three categories: databases, programming languages, and frameworks.\n\nDatabases\n\nDatabases are used to storing important data such as user information. Popular database management systems and relational databases include:\n\nMySQL\nMongoDB\nOracle\nPostgreSQL\nLanguages\n\nBack-End Developers normally query their databases with various programming languages such as the following:\n\nSQL, which is ideal for working in relational databases.\nRuby is a beginner-friendly language that has an enthusiastic programming community behind it.\nPython is a great choice with a concise, human-readable syntax.\nPHP is an open-source language that is great for server-side scripting.\n[Node.js], which brings back-end work to JavaScript.\nJava is a popular choice still widely used today.\nFrameworks\n\nFrameworks intend to make all aspects of web development more smooth and seamless, including back-end. This save developers time they would otherwise spend writing code. Popular frameworks include:\n\nSinatra, a lightweight Ruby framework for building web apps.\nRuby on Rails, a more robust Ruby framework that follows the model-view-controller standard.\nDjango, a Python framework that offers dynamic HTML pages.\nFlask, a ligher Python framework meant for rapid development.\nExpress, a framework for building back-end APIs with JavaScript."},{"title":"Big Data","description":"Big data involves working with and developing insights from large datasets.\n\nThe key distinctions between regular data and big data are volume, velocity, and variety. Generally, big data is more extensive information with more individual components that are collected in a shorter period of time. Big data sources are often new but can encompass older data streams as well.\n\nExamples\n\nBig data is utilized across multiple industries and applied in many ways, including the following:\n\nMarketing departments use this data for targeted advertising, promoting products, and services that align with company interests.\nHealthcare professionals may track data such as heart rate and sleep habits to improve health surveillance and assist people with performing ADLs (activities of daily living).\nThe transportation and automobile industries may use big data to improve road safety and navigation, as well as take prevetative measures against inclement weather.\nProcessing Big Data\n\nBecause big data is so vast and comprehensive, it needs to be processed before being analyzed for insights. This involves collecting and comparing data from multiple sources, cleaning it to remove any errors or duplicates, and more.\n\nAfter processing, data scientists go through the data to find any relevant patterns in the big data. This often involves the use of machine learning algorithms and data visualization methods for creating insights. Statistics also play a key role in data analysis as it seeks to explain the relationships between the data and probable outcomes.\n\nProgramming Languages\n\nThere are several programming languages used to collect, process, analyze, and visualize big data, including the following:\n\nC and C++ still hold up as solid choices.\nJava has big data tools that are open-source, flexible, and free to use.\nJavaScript is ideal for building interactive web pages that share big data-generated information.\nPython features many libraries that specialize in working with statistical anlysis and big data.\nR excels at using statistical analysis and visualization to draw insightful and actionable conclusions.\nSQL was developed for handling large databases with relationships between different variables from different datasets."},{"title":"Binary","description":"Binary is a number system of 1’s and 0’s which serves as a textual representation method for giving instructions to a computers CPU.\n\nIn computing and telecommunications, binary codes are used for various methods of encoding data such as turning the character strings of source code, into bit strings or instruction sets for the CPU to execute.\n\nA device called a clock sends out regular pulses, and components such as transistors switch on (1) or off (0) to pass or block the pulses. In a transistor:\n\n“0” represents no flow of electricity or “off”.\n“1” represents electricity being allowed to flow or “on”.\n\nBinary digits can be grouped together into bytes. Binary codes activate the CPU, and the processor executes the binary. Bit is short for binary digit.\n\nThe Binary system was created by Gottfried Leibniz in 1689."},{"title":"Bitwise Operator","description":"Bitwise operators are typographic characters used to represent objects that describe operations which can be performed on the most granular level of computing instructions: binary digits. Bitwise operators are used to manipulate these bits in order to facilitate the performance of applications.\n\nBitwise operators give programs greater control over applications by providing detailed implementation of algorithms (e.g., encryption, compression, etc.) and the ability to control physical state to a greater degree via manipulation of individual bits.\n\nThey are widely used in the embedded systems where we need to set/clear/toggle single bits of a specific register without modifying the other contents and also extensively used in areas of graphics, especially XOR (exclusive OR) operations.\n\nBitwise Operator Table\nOperator\tExample\tMeaning\n&\ta & b\tBitwise AND\n|\ta | b\tBitwise OR\n^\ta ^ b\tBitwise XOR (exclusive OR)\n~\t~a\tBitwise NOT\n<<\ta << n\tBitwise left shift\n>>\ta >> n\tBitwise right shift\nExample in Python\nx = 7\ny = 9\n\n\n# Bitwise OR operation\nprint(\"x | y =\", x | y)\n\n\n# Bitwise AND operation\nprint(\"x & y =\", x & y)\n\n\n# Bitwise XOR operation\nprint(\"x ^ y =\", x ^ y)\n\n\n# Bitwise NOT operation\nprint(\"~x =\", ~x)"},{"title":"Bjarne Stroustrup","description":"Bjarne Stroustrup is a Danish computer scientist and principle designer of C++, an extension of the C programming language.\n\nStroustrup has authored several computer programming books focused on C++, including The C++ Programming Language, and is currently a Visiting Professor in Computer Science at Columbia University.\n\nAs the principle designer of C++, Bjarne Stroustrup’s goal was to add object-oriented programming into C, a language well-respected for its portability and low-level functionality, and to do so efficiently. Stroustrup’s continued work in maintaining C++ is associated with improvements in performance and efficiency for a great number of applications including AI/ML, RDBMS, video games, financial systems, and graphics.\n\nDr. Stroustrup played a key role in the development of Codecademy’s Learn C++ course. Here’s an insightful interview called Talking C++ that took part in the last segment of the production."},{"title":"Boolean","description":"Booleans hold a true or false value and are mostly used in conditional statements to control a program’s flow of execution. This data type is named after George Boole, a 19th century English logician.\n\nSome languages use comparison operators such as:\n\n>= and <=, for “greater than” and “less than”, respectively.\n== and is or != and not to test for equality and inequality, respectively.\n\nOther languages may use a combination of “falsy” values (e.g. \"\", null, or 0) and “truthy” values such as 1.\n\nJavaScript Example\n\nThe following example uses a comparison operator to return true or false based on the evaluation of the given statement. Then, a JavaScript conditional is used to determines whether the if or else code block will run:"},{"title":"Bootstrap","description":"Bootstrap is an open source CSS framework created to help style web pages with mobile-first considerations in mind. It was created internally at Twitter in 2011 as a way to solve issues with design consistency across their engineering team. Since its creation, Bootstrap has become one of the most commonly used tools on web pages today.\n\nBootstrap utilizes web technologies like HTML, CSS, and JavaScript to provide aesthetic improvements to the Document Object Model (DOM) elements on a web page. Additional user interface elements such as dialog boxes, tooltips, and carousels are also available to users.\n\nInstallation\n\nThere are several ways to install Bootstrap and its source files.\n\nFor JavaScript, Bootstrap can be used with a package manager like npm or Yarn:\n\n## npm\nnpm install bootstrap\n\n\n## yarn\nyarn add bootstrap\n\nFor Ruby applications, it can be installed as a gem with a dependency tool like Bundler:\n\ngem 'bootstrap', '~> 5.0.2'\n\nAnother way to install Bootstrap for Ruby, but without a tool like Bundler, is with the following command:\n\ngem install bootstrap -v 5.0.2\n\nInstead of being downloaded, Bootstrap’s source files can be linked directly into an HTML file via CDN:\n\n<link\n  href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css\"\n  rel=\"stylesheet\"\n  integrity=\"sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC\"\n  crossorigin=\"anonymous\"\n/>\n<script\n  src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js\"\n  integrity=\"sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM\"\n  crossorigin=\"anonymous\"\n></script>\nThemes\n\nAs its popularity grew, people started creating templates based on Bootstrap in order to accelerate the web development process even further. There are many websites out there dedicated to sharing and buying custom templates based on Bootstrap.\n\nHere are the official themes built or reviewed by Bootstrap’s creators: https://themes.getbootstrap.com\n\nExample: Normal Button vs Bootstrap Button\n\nIn the example below, Bootstrap is linked into an HTML document via CDN and used with jQuery to provide a button for positive actions.\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\n\n    <link\n      rel=\"stylesheet\"\n      href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css\"\n    />\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script>\n    <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js\"></script>\n  </head>\n\n\n  <body>\n    <div class=\"container\">\n      <h2>Button</h2>\n      <p>The .btn-success class indicates a successful or positive action:</p>\n\n\n      <button type=\"button\" class=\"btn btn-success\">\n        Bootstrap Styled Button\n      </button>\n      <button type=\"button\">Normal Button</button>\n    </div>\n  </body>\n</html>"},{"title":"Bot","description":"Bots are software applications which perform automated services. Bots perform tedious and repetitive tasks quicker and more efficiently than it would take humans.\n\nOn the internet, servers use robots.txt files to state the rules for bot behavior on the server. It is estimated that up to half of all internet traffic is made up of computer bots performing tasks on the web. Networks of zombie computers are called botnets… scary.\n\nUse Cases for Bots\nTo index web content (e.g. Google’s web crawlers)\nTo moderate or monitor forums for undesirable content (e.g. Twitch’s moderator bots)\nTo provide round the clock customer service support (e.g. Shopify’s customer support bot)\nTo simulate human speech patterns or entertain Chat bots (e.g. Apple’s Siri)\n\nMalicious bots can be used to perform actions on servers which do not fulfill the intended desire of the users who maintain the server or attacked application. These bots are often used for denial of service attacks, spam and other nefarious activities.In order to combat malicious bots a number of strategies have been devised. The following are some steps an oganization can take to limit the damage malicious bots can do:\n\nStatic Approach: Analyzes header information to determine a bot’s identity, and blocking it if necessary.\nChallenge-based Approach: Use CAPTCHA or other Turing tests to filter bots from humans.\nBehavioral: Compares behavioral signatures to previous, known signatures of bad bots."},{"title":"Cache","description":"A cache is data stored locally in an application for faster retrieval. Caches work by acting as initial locations for data access when client interfaces make a request for data.\n\nIf the data requested is found we call this a “cache hit” and return the requested data, if the data is not found it is deemed a “cache miss”. Cache misses trigger a process for getting the correct data called a “replacement policy”.\n\nData is transferred between memory and cache in blocks of fixed size called “cache lines” or “cache blocks” after the stale data has been removed. Larger caches have better hit rates but longer latency. To address this trade-off, many computers use multiple layers of caching, with small fast caches backed up by larger, slower caches. If the smaller cache misses, the next fastest cache (level 2, L2) is checked, and so on, before accessing external memory.\n\nThe size of the cache can be calculated as the number of bytes stored in each data block times the number of blocks stored. “Higher-level” caches (i.e. Level 2 and above) have progressively larger numbers of blocks, larger block size and relatively longer access times, but faster than main memory. Effective caching implementations are a major way for applications to improve their performance.\n\nCaching with Hardware vs Software\n\nHardware caching strategies are strategies that utilize part of the hardware in a computing device to store the neccessary data. Often these computing devices offer caching on multiple layers of the hardware parts responsible for caching.\n\nCPU Cache: The Central Processing Unit of a computer contains multiple levels of caching, with L1 being the fastest. Each subsequent cache layer is slower and larger. On multicore chips, the L3 cache is generally shared among all the processing cores.\n\nGPU Cache: A computer’s Graphics Processing Unit (GPU) has a device memory that is independent of the RAM in the host system and can be used as a cache location.\n\nDisk Cache: Disk Cache aka (Disk Buffer) is the embedded memory in a hard disk drive (HDD) acting as a buffer between the rest of the computer and the physical hard disk platter that is used for storage.\n\nSoftware caching strategies are strategies that utilize software to store the neccessary data locally and retrieve it in an efficient and optimized manner.\n\nCDN: Caching in the browser via Content Delivery Network (CDN) retains copies of web content at various points throughout a network and serves them to clients from the closest network location.\n\nMemoization: Memoization is an optimization technique used to speed up applications by storing the results of function calls and returning the cached result when the same inputs occur again.\n\nThat’s all for now. Cache me outside, how about that!"},{"title":"Builder Pattern","description":"The builder pattern decouples the responsibility of object creation from the desired object’s class. It is normally implemented when a class requires many properties to be set during its construction and may be used to ensure immutability.\n\nUML Design\n\nJava Example\n\nTo illustrate the builder pattern, below provides a real-world example in Java, depicting potential considerations for a pizza order. The PizzaOrder class has 5 properties:\n\ntoppings\ncheese\nsauce\npizzaBase\nstuffCrust\n\nDuring construction, both pizzaBase and stuffCrust are required to be set explicitly, and should cheese and/or sauce not be set before .build(), default values will be assigned. Construction of a PizzaOrder object is enforced through the PizzaOrder‘s Builder inner class. After creation, a PizzaOrder object’s properties are immutable.\n\npublic class PizzaOrder {\n  public static class Builder {\n    // Same properties as the outer PizzaOrder class\n    private final List<Topping> toppings;\n    private final Cheese cheese;\n    private final Sauce sauce;\n    private final Base pizzaBase;\n    private final boolean stuffCrust;\n\n\n    public Builder(Base pizzaBase, boolean stuffCrust) {\n      // Enforce required choices\n      this.pizzaBase = pizzaBase;\n      this.stuffCrust = stuffCrust;\n      // Default values\n      this.cheese = Cheese.MOZZARELLA;\n      this.sauce = Sauce.TOMATO;\n    }\n\n\n    // Sets property and returns itself (either for next property to be set, or .build() to be invoked)\n    public Builder toppings(List<Topping> toppings) {\n      this.toppings = toppings;\n      return this;\n    }\n\n\n    public Builder cheese(Cheese cheese) {\n      this.cheese = cheese;\n      return this;\n    }\n\n\n    public Builder sauce(Sauce sauce) {\n      this.sauce = sauce;\n      return this;\n    }\n\n\n    public Builder base(Base pizzaBase) {\n      this.pizzaBase = pizzaBase;\n      return this;\n    }\n\n\n    public Builder stuffCrust(boolean stuffCrust) {\n      this.stuffCrust = stuffCrust;\n      return this;\n    }\n\n\n    // When .build() is called, a new concrete object is returned with the desired properties set\n    public PizzaOrder build() {\n      return new PizzaOrder(this);\n    }\n  }\n\n\n  private final List<Topping> toppings;\n  private final Cheese cheese;\n  private final Sauce sauce;\n  private final Base pizzaBase;\n  private final boolean stuffCrust;\n\n\n  // Removes default constructor and forces object creation through Builder inner class\n  private PizzaOrder(Builder builder) {\n    // Constructs concrete object with builder's property values\n    this.toppings = builder.toppings;\n    this.cheese = builder.cheese;\n    this.sauce = builder.sauce;\n    this.stuffCrust = builder.stuffCrust;\n  }\n\n\n  // Getters below\n}\n\nNote: Setters are negated for immutability. Some Enums have been provided to safely model the choices an order may have.\n\npublic enum Topping {\n  HAM,\n  PINEAPPLE,\n  SWEETCORN\n}\npublic enum Sauce {\n  TOMATO,\n  BBQ\n}\npublic enum Base {\n  THIN_BASE,\n  DEEP_PAN\n}\npublic enum Cheese {\n  NONE,\n  MOZZARELLA\n}\n\nThe Main class below shows how to instantiate a PizzaOrder object through its inner Builder class.\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create concrete object\n    PizzaOrder pizzaOrder = new PizzaOrder.Builder(Base.DEEP_PAN, true).sauce(Sauce.BBQ).build();\n  }\n}"},{"title":"Class","description":"A class is a piece of code within a program that functions as a template or blueprint for creating mulitple instances of a particular object.\n\nThe template provides initial values and behavior for each of these instances. Each instance is an object itself.\n\nExample\n\nSuppose we want to create a Cat class with three instance variables:\n\n@cat_name\n@cat_color\n@cat_age\nclass Cat\n   def initialize(name, color, age)\n      @cat_name = name\n      @cat_color = color\n      @cat_age = age\n   end\nend\n\nNow we can create a bunch of objects based off of the Cat class:\n\nmochi = Cat.new(\"Mochi\", \"Gray\", 2)\n\n\nbean = Cat.new(\"Bean\", \"Black/Gray\", 6)\n\n\nfemi = Cat.new(\"Femme en Noir\", \"Black/White\", 9)"},{"title":"CDN","description":"Content Delivery Network (CDN) is a method of implementing a cache in the browser which retains copies of web content at various points throughout a network and serves them to clients from the closest network location. This is done by geographically distributed group of servers which work together to provide fast delivery of Internet content.\n\nCDN’s are among recent innovations in technology which have improved the availability and speed with which we are able to access information on the internet because content that would normally have to travel long distances in order to be consumed by the client are now stored in local hubs geographically close in order to serve it to the user much faster.\n\nCDN Benefits\nImproving website load times: Pages load much quicker because the resources do not have to retrieve data from long distances. Data is cached locally and served therefore much quicker.\nReducing bandwidth costs: Due to proximity to the server, data transfer is done with less bandwidth requirements.\nIncreasing content availability and redundancy: Having cached details in servers across the globe allows users to consume the data locally and therefore quicker.\nImproving website security: Properly configured CDN’s can prevent Denial of Service attacks by distributing the load to servers that can serve the desired resources without being overwhelmed."},{"title":"Cloud Computing","description":"Cloud computing is the distribution of technology services over the internet, particularly data storage (cloud storage) and computational power without direct active management by the user. Users have to pay only for the services they use. Instead of buying, owning, and maintaining physical data centers and servers, users can access technology services such as computing power, storage, and databases on an as-needed basis from a cloud provider. There are many cloud providers in the market providing different services with different pricing models.\n\nHistory of Cloud Computing\n\nIn 1963, the Defense Advanced Research Projects Agency (DARPA) awarded MIT a $2 million grant for Project MAC. The funding required MIT to develop technology that would allow a computer to be used by two or more people at the same time. In this case, one of those massive, archaic computers that used reels of magnetic tape for memory and were the precursor to what is now collectively known as the cloud computing.\n\nHow does Cloud Computing work?\n\nIt is divided into two sections, i.e., frontend and backend. They are connected through the Internet. The frontend consists of the client’s computer or computer network. Also, the application is essential to access the cloud system. Not all cloud computing systems need to have the same user interface. On the backend, the cloud is made of the following:\n\nComputers\nServers\nData Storage Systems\n\nA cloud computing system could include any computer program, from data processing to video games. Generally, each application will have its dedicated server.\n\nTypes of Cloud\nPublic cloud\n\nPublic clouds are owned and operated by third-party cloud service providers that deliver their computing resources like servers and storage over the Internet. Examples include Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure.\n\nPrivate cloud\n\nPrivate cloud refers to cloud computing resources used exclusively by a single business or organization. A private cloud can be physically located on the company’s on-site data center. Some companies also pay third-party service providers to host their private cloud.\n\nHybrid cloud\n\nHybrid clouds are a combination of both private and public clouds. Data and applications are allowed to be shared between the private and public clouds. Allowing data and applications to move between private and public clouds provides businesses greater flexibility, more deployment options, and helps optimize existing infrastructure, security and compliance.\n\nBenefits of Cloud Computing\n1. Cost\n\nCloud computing eliminates the capital expense of purchasing hardware and software, establishing and operating on-site datacenters, around-the-clock electricity for power and cooling, and IT experts that manage infrastructure. Users, on the other hand, only need to pay for the resources or services they use.\n\n2. Speed\n\nMost cloud providers provide on-demand services, so even large amounts of computing resources can be provisioned in minutes, typically with just a few mouse clicks, giving businesses a lot of flexibility and taking the pressure off capacity planning.\n\n3. Security\n\nData security is a concern for every business, regardless of size and industry. Cloud Computing offers many advanced security features which guarantee that data is securely stored and handled. Cloud providers implement baseline protections for their platforms and the data they process such as authentication, access control, and encryption.\n\n4. Reliability\n\nCloud computing makes data backup, disaster recovery, and business continuity simple and affordable because data can be mirrored at multiple redundant sites on the cloud provider’s network.\n\n5. Scalability\n\nUsers do not have to over-provision resources for future peak levels of business activity with cloud computing. Instead, users are only provided the resources that they require. Users can instantly grow and shrink capacity by scaling these resources up or down as your business needs change.\n\nWho is using Cloud Computing?\n\nA wide spectrum of enterprises have move to the cloud. Some big names include Netflix, Instagram, Apple, and more. The Codecademy team uses plenty of cloud computing serverces as well, such as AWS, Google Drive, and Notion."},{"title":"Code Editor","description":"A code editor is a program designed for writing software. Developers writing code using a code editor utilize human-readable text which makes code easier to parse and understand.\n\nCode editors have built-in knowledge of programming languages, which allow different elements of the code (ie. variables, keywords, functions, etc.) to appear in different colors making the code easier to analyze for developers. Code editors can compile and run code. In addition to being able to print a code’s output, these programs can also identify where and why a particular line of code fails to execute.\n\nNotable Examples\n\nThere are numerous code editors available, such as:\n\nVisual Studio Code\nSublime Text\nAtom\nNotepad++\nVim\n\nWhich code editor program to use is really up to the individual developer according to their tastes!"},{"title":"Comment","description":"A comment is a note or explanation in the source code of a computer program. They are added with the purpose of making the code easier for ourselves or other developers to understand in the future, and they are generally ignored by compilers and interpreters.\n\nComments are typically formatted as either:\n\nSingle-line comments, which start with a comment delimiter and continue until the end of the line.\nMulti-line comments, which start with a start delimiter and end with an end delimiter and can span multiple lines.\n\nSome programming languages support only one type of comment. For example, Python comments are single-line comments: They start with # and continue to the end of the line.\n\nOther languages employ both single-line and multi-line comments. For example, C and C++ have single-line comments that start with // and multi-line comments between /* and */ that can span multiple lines.\n\nUses\n\nHow best to make use of comments is subject to dispute. Here are some common ways comments are used:\n\nCode Description\n\nComments can be used to summarize code or to explain the programmer’s intent. They can provide additional information to aid in understanding the code.\n\nDebugging\n\nWhen an error is encountered in the program, a common debugging practice is to comment out some code, meaning to add comment syntax causing that block of code to become a comment, so that it will not be executed in the program. This may be done to exclude certain pieces of code from the program.\n\nBy strategically commenting out and running only parts of the program, the source of the error can be determined through process of elimination.\n\nMetadata\n\nComments in a computer program often store metadata about a program file.\n\nIn particular, many software maintainers put submission guidelines in comments to help people who read the source code of that program to send any improvements they make back to the maintainer.\n\nOther metadata includes:\n\nThe name of the creator of the original version of the program file\nThe date when the first version was created\nThe names of other people who have edited the program file so far\nThe URL of documentation about how to use the program\nThe name of the software license for the program file"},{"title":"CPU","description":"Central Processing Unit (CPU) is used to describe the electrical circuitry in a computer responsible for executing instruction sets derived from programs that have been converted into machine code.\n\nCPU’s sit at the heart of the system of a computer and are connected to the motherboard. They also have caches which act as memory units capable of temporary storage and quick retrieval of files by the computer.\n\nThe performance or speed of a processor depends on, among many other factors, the clock rate (usually measured in hertz) and the instructions per clock (IPC), which together are the factors that make up the instructions per second (IPS) which measures CPU performance. CPU’s can have multiple cores which allow them to perform operations in parallel to one another which greatly increases the speed and efficiency of the computer.\n\nMajor Components\n\nTwo major components of the CPU are:\n\nControl Unit (CU): The control unit is a component of the CPU that directs the operation of the processor. It controls the response to the instructions that have been sent to the processor via machine code by directing the flow of data between the CPU and the other devices.\n\nArithmetic Logic Unit (ALU): The arithmetic logic unit is a digital circuit within the processor that performs integer arithmetic and bitwise logic operations."},{"title":"Creational Design Patterns","description":"Creational design patterns concern themselves with the instantiation of objects. At the time of creation, additional logic may be needed to decide what or how object types need to be created.\n\nFive main creational design patterns are outlined below:\n\nSingleton: Ensures a class has only one object instantiated during the programs lifecycle.\nBuilder: Decouples the responsibility of object creation from the desired object’s class. It is normally implemented when a class requires many properties to be set during its construction.\nPrototype: Adds cloning functionality to an objects class.\nFactory: Creates objects without specifying the specific class.\nAbstract Factory: Groups object factories based on a common theme."},{"title":"CSV","description":"Comma-Seperated Values (CSV) is a text file format where individual values are seperated by commas. It is normally used to store tabular data and is favored for its simple structure allowing for straightforward parsing and data exchange.\n\nTo store tabular data, CSV files usually represent each line as a new row within the table and the values delimited by commas as the cells within each row. However, this practice is not formalized so the interpretation of the cell’s contents is normally application-specific.\n\nFor example, some applications use quotation marks (\") or a backslash (\\) to denote literal characters that allow the cells themselves to also contain the comma character.\n\nExample CSV with Corresponding Tabular Representation\n\nAn example CSV file containing data about large animals and a common rendering of its tabular form can be found below:\n\nAnimal,Average Length (Feet),Average Weight (Tons)\nAfrican Bush Elephant,19.7,5.4\nIndian Rhinoceros,13.8,2.1\nHippopotamus,16.5,2.0\nGiraffe,16.9,1.1\nGaur,12.5,1.0\nAnimal\tAverage Length (Feet)\tAverage Weight (Tons)\nAfrican Bush Elephant\t19.7\t5.4\nIndian Rhinoceros\t13.8\t2.1\nHippopotamus\t16.5\t2.0\nGiraffe\t16.9\t1.1\nGaur\t12.5\t1.0"},{"title":"Cyberattack","description":"Cyberattacks are attempts to disrupt or disable computer systems or steal valuable data. They can compromise sensitive data, including:\n\nPersonal information such as birthdates, government-issued documents, or medical information.\nFinancial information such as credit card numbers, and bank account numbers.\n\nThis can lead to consequences like identity theft, which is time-consuming, frustrating, and expensive to resolve.\n\nTypes of Cyberattacks\n\nThere are several types of cyber attacks. Some of the most common include:\n\nMalware that can either install and go unnoticed (spyware) or hijack entire systems (ransomware).\nPhishing scams where an email, text, or link could trick a user into sharing sensitive, private information.\nA “man-in-the-middle” attack involving the attacker intercepting a connection between mutliple users.\nDistributed Denial of Service (DDoS) attacks that overload a system’s resources and bandwidth.\nSQL injections that corrupt and collect data from servers and databases.\nZero-day vulnerabilities that exploit software vulnerabilities before they’re patched.\nDNS tunneling that hides and removes the data of other programs in DNS queries and responses without being detected.\nPreventing Attacks\n\nOrganizations and individuals can and should take steps to prevent cyber attacks.\n\nAlong with self-directed learning, organizations should educate employees on common cyber threats, including phishing and social engineering.\nPerimeter defenses, such as firewalls, should be installed and kept up to date.\nState-of-the-art antivirus software and malware detectors should be in place and continually updated to address threats.\nWhile patch management might seem tedious, it can help prevent vulnerabilities from being exploited.\nUser-access, such as strong passwords and multi-factor authentication, should be utilized.\nBusinesses should especially have a response plan to deal with security breaches."},{"title":"Cybersecurity","description":"Cybersecurity is the practice of protecting computer systems and networks from bad actors who disrupt services or steal sensitive information. The responsibilities of professionals in this field may include:\n\nEducating a company’s stakeholders on the importance of cyber and information security.\nPlanning in disaster recovery and responses to cybersecurity breaches.\nClosing gaps in network security and mitigating vulnerabilities.\nDefending against various cyberattacks.\n\nAs a concept, cybersecurity covers everything from network and application security to operational security and business continuity.\n\nProgramming Languages\n\nCybersecurity work involves the following programming languages:\n\nPython features tools for common tasks such as malware analysis.\nC and [C++] are low-level and can directly access RAM and system proceses.\nSQL and its features in database security.\nPHP protects against DDoS (distributed denial of service) attacks."},{"title":"Data Science","description":"Data Science is a multidisciplinary field of study that utilizes data collection, data analysis, data visualization to extract insight from data. It incorporates skills from a long list of computer science, statistical, mathematical, and visual design disciplines.\n\nApplication\n\nSince the beginning of the 21st century, data science has been used in generally every field of industry to extract insight from data for finding new efficiencies in business decision-making and product development. These applications are largely related to fields of study rooted in data science, including:\n\nData Visualization\nData Engineering\nMachine Learning & Deep Learning\nArtificial Intelligence\nCloud and Distributed Computing\nBusiness Intelligence and Strategy\nLanguages and Tools\nPython (Matplotlib, Pandas, Scikit-learn, TensorFlow, NLTK)\nR (ggplot2)\nExcel\nTableau\nSQL\nJupyter Notebook\nMATLAB\nHistory\n\nMany statisticians have argued that data science is not a new field, but rather another name for statistics. Considering this perspective, the history of data science would date as far back as 5th century B.C., demonstrated by the Athenians who estimated the height of ladders needed to scale the walls of Platea by counting the bricks of the wall vertically in several areas, then multiplying the most frequent count by the height of a brick.\n\nIn 1662, John Graunt produced Natural and Political Observations Made Upon the Bills of Mortality in which he estimated the population of London by using annual funeral records, familial death rates, and average family size.\n\nWithout the correlation to statistics involved, many consider John Tukey to be the inventor of data science where in March 1962 he published The Future of Data Analysis where he described a field he called “data analysis,” which resembles modern data science. With advents in data processing and storage, applications of data science have accelerated in both complexity and popularity."},{"title":"Data Types","description":"Data is foundational in programming and is classified into different types to indicate how it can be interpreted, compiled, and used in software. For the most part, data types are categorized into two groups: primitive or composite values.\n\nPrimitive Data Types\n\nPrimitive data types are the building blocks for any variable or data structure in a program. They usually contain a single value such as a character, byte, or digit. A few examples of primitive types are listed below:\n\nData Type\tDescription\nNumber\tIncludes -1, 0, 1, and 3.14(numbers with decimals treated as a separate type in some languages).\nString\tSequences of characters surrounded by single quotes (''), double quotes (\"\"), and/or backticks (``), depending on the language (e.g. \"Codecademy is awesome! 🖥️⌨️\" ).\nBoolean\tHolds a logical value of true or false.\nComposite Data Types\n\nComposite data types can be composed of multiple of the same or different primitive data types, sometimes referred to as members, elements, or items. The following are examples of well known composite types:\n\nData Type\tDescription\nArray\tCollections of values that are usually defined with [] brackets and referenced by index starting at 0.\nObject\tGroups of related data that are usually organized as property-value pairs.\nClass\tTemplates for objects that may contain properties or methods.\nOther Common Data Types\n\nData types have gone beyond just composites and primitives and include ones with unique qualities such as the following:\n\nData Type\tDescription\nNull\tnull or nil represents the absence of a value.\nUndefined\tRepresents a value that has not yet been defined.\nFunction\tDepending on the language, functions can be utilized as variables and arguments for other functions.\nVoid\tSets a function to have side effects but return no specific result. Common in C-based languages.\nComplex Number\tType representation for complex numbers, sometimes with i or complex.\nData Types in Different Languages\n\nThe way that data types look and work may vary from one programming language to another:\n\nC++ data types\nGo data types\nJavaScript data types\nJava data types\nPython data types\nR data types\nRuby data types\nSwift data types"},{"title":"Database Index","description":"A database index is a data structure that improves the speed of data retrieval in the database. Indexes on a table consist of one or more columns of ordered data with links back to specific rows in a table.\n\nBy matching the values in the index, the database management system can quickly retrieve the corresponding row without having to search every row in the table. Tables are indexed on their primary key columns, and many database systems require an index on a foreign key column as well. During database design indexes are typically also placed on columns that will be most often queried on.\n\nExample\n\nIndex creation can vary from database to database, but in standard SQL it consists of the statement CREATE INDEX followed by a name for the index, ON the table name, followed by a list of the columns to indexed. So adding an index on the region field of a sales table looks like this:\n\nCREATE INDEX sales_by_region\nON sales (region);"},{"title":"Database","description":"A database is a collection of structured information stored so it can be easily accessed and updated. In a computer system, a database is typically accessed through a database management system, referred to as a DBMS.\n\nTypes of Databases\n\nThere are many different ways for database systems to structure and organize data. The type of database used is dependent on the type of data being stored, and the intended use for it.\n\nRelational Databases\n\nRelational Databases structure their data in tables made up of rows and columns. Multiple tables can have relationships to each other based on the values in key columns. They provide an efficient and flexible way to access structured information. Data is typically queried and manipulated through some form of Structured Query Language (SQL) implemented by the DBMS.\n\nObject Databases\n\nObject Databases structure their data in the form of objects (as used in object-oriented programming) rather than tables. This is useful in software development where the application using the data, and the DBMS manipulating the data, can both use the same model of the data.\n\nObject-Relational Databases\n\nA hybrid of the above two models. Unlike pure object databases where the database is primarily a persistent store for objects created by a program written in an object-oriented programming language, object-relational databases are manipulated via a query language as in relational databases. Yet they still support objects, classes and inheritance like a pure object database.\n\nNoSQL Databases\n\nNoSQL Databases are also known as Nonrelational Databases. They are a wide variety of databases that use different structures for data rather than the tables used in relational databases. They are implemented using various different structures for different purposes. For example:\n\nKey–Value Store: Stores data in an associative array where data is stored as a collection of key-value pairs where any possible key only appears once in the collection.\nDocument Store: Stores data as documents in some standard format such as XML, TAML or JSON. Documents are stored in the database with a unique key representing that document.\nGraph Database: Stores data as elements connected by a finite number of relations, such as a subway map or a network of friends on Facebook."},{"title":"Dictionary","description":"A dictionary is an unordered set of (key, value) pairs. It provides a way to map pieces of data to each other, and allows for quick access to values associated to keys.\n\nSyntax\n\nThe syntax of a dictionary is as follows:\n\ndictionary = {\n  key1: value1,\n  key2: value2,\n  key3: value3\n}\n\nFor example:\n\ncoffee_shop = {\n  \"cold brew\": 3.50,\n  \"latte\": 4.25,\n  \"cappucino\": 3.99\n}"},{"title":"Dennis Ritchie","description":"Dennis Ritchie was an American computer scientist, the creator of the computer programming language C, and co-creator of the Unix operating system.\n\nRitchie, along with Ken Thompson and others at Bell Laboratories, began working on Unix in 1967 as a replacement operating system for the Digital Equipment Corporation’s PDP-7 mini computer.\n\nWithin this same time, Ken Thompson also developed the B computer programming language with Ritchie’s contribution, and in 1971, Ritchie began developing C as an extension of B.\n\nToday, C is one of the most commonly used languages for embedded and operating system development, such as macOS and Android. There have been several languages developed as extensions of C including C#, C++, and Java."},{"title":"Encapsulation","description":"Encapsulation is one of the four principles of object-oriented programming (OOP) which emphasize modularity and hiding away of complexities in order to better maintain and reason about code.\n\nMost of the time encapsulation can be achieved by creating classes and naming private and public methods (or getters and setters) for our systems to interact.\n\nExamples of Encapsulation\nclass Robot(object):\n def __init__(self):\n   self.__version = 22\n\n\n def getVersion(self):\n   print(self.__version)\n\n\n def setVersion(self, version):\n   self.__version = version\n\n\nobj = Robot()\n\n\nobj.getVersion()\nobj.setVersion(23)\nobj.getVersion()\n\n\nprint(obj.__version)"},{"title":"DNS","description":"The Domain Name System (DNS) protocol converts domain names to IP addresses. Think of it as a phonebook for the Internet. It’s hard to remember an exact IP address when we want to access a website.\n\nWhen we request the URL codecademy.com, our computer sends a DNS request to a DNS server. The server then returns the correct IP addresses like 104.20.25.250 to route data to and from Codecademy.\n\nDomain Name\n\nEach domain name is made up of three parts:\n\nthird-level-domain . second-level-domain . top-level-domain\n\nTop level domain: There are a limited set of top level domains, and many websites use the most common ones like “.com”, “.org”, and “.edu”.\nSecond level domain: The second level domain is unique to the company or organization that registers it, like “codecademy” or “wikipedia”.\nThird level domain (subdomain): It’s owned by the same group and that URL often directs you to a subset of the website.\n\nFor example: shop.codecademy.com (Codecademy’s merch shop):\n\nTop level domain: “.com”\nSecond level domain: “codecademy”\nThird level domain: “shop”"},{"title":"Express","description":"Express is a back end web framework for Node.js applications. It is primarily used to build web applications and APIs and provide network request functionality. In order to use Express, Node.js must be installed.\n\nPopularity with tech stacks\n\nSince it is popular choice for a back end tool, Express belongs to popular tech stacks including:\n\nMERN (MongoDB + Express + React + Node)\nMEAN (MongoDB + Express + Angular + Node)\nMEVN (MongoDB + Express + Vue + Node)"},{"title":"Error","description":"An error is a mistake that causes a program to perform in unexpected ways or to fail outright. The mistakes could be from the slip of a keyboard stroke - like mispelling a variable or from forgetting a closing bracket; or a misunderstanding of requirements - like using imperial units of measurement instead of metric.\n\nUnderstanding different types of errors and how to debug them are crucial towards becoming a productive programmer.\n\nHistory\n\n“First actual case of bug being found.”\n\nThe story goes that on September 9th, 1947, computer scientist Grace Hopper found a moth in the Harvard Mark II computer’s logbook and reported the world’s first literal computer bug. However, the term “bug,” in the sense of technical error, dates back at least to 1878 and with Thomas Edison.\n\nSyntax Errors\n\nEvery language has rules regarding the structure of words and phrases in a sentence. The rules that define this structure are known as syntax. If you texted your friend “The at will meet. pub I you in 10”, your friend would be confused, and you would need to re-type the text.\n\nSimilarly to the English language, programming languages expect keywords, symbols, and values to be arranged in a certain, logical order according to syntax, otherwise the compiler will throw a syntax error.\n\nLogic Errors\n\nNearly every piece of code you write is an expression of some meaningful logic. This logic is the core of what you are intending to accomplish with your code. Sometimes you might write code in such a way that is syntactically correct but isn’t what you intended to express. This can be seen in any language, including English.\n\nExample\n\nSuppose we have a JavaScript program:\n\nfunction sayHello(name) {\n   alert(\"Hello ${name});\n}\n\n\nsayHello(\"Joe\");\n\nBecause of a missing closing quotation mark, there’s an error message:\n\n/home/script.js:2\n\n   alert(\"Hello ${name});\n         ^^^^^^^^^^^^^^^^\n\nSyntaxError: Invalid or unexpected token\n\nThis error says that in the file script.js, on line 2, there’s a SyntaxError."},{"title":"Firebase","description":"Firebase is a cloud computing and app development platform hosted by Google.\n\nIt was founded in 2011 as Envovle, a startup which developed APIs for embedded chat services in websites. Google acquired Firebase in 2014 and has further developed the services offered by the platform, some of which now include:\n\nAuthentication\nML Kit\nRealtime Database\nFirebase Hosting\nPerformance Monitoring\nAnalytics\n\nThese services are designed to allow developers to build and maintain apps with many backend services accessed directly by Firebase SDK’s."},{"title":"Factory Pattern","description":"The factory pattern defers instantiation logic of a parent abstract class to its concrete sub-classes. At time of object creation, the specific class type may not be known, in which a creator class’ factory method is used to decouple this identifying logic. This is typically done through the methods, parameters, and a switch statement.\n\nUML Design\n\nJava Example\n\nTo illustrate the factory pattern, below provides a real-world example, in Java, depicting potential considerations for a taxi and food delivery booking application.\n\nA user of the app will need to send a request for either a standard taxi, a large taxi, a mini bus, or wish to have food delivered from a restaurant. However, before the program understands their needs, the needed request needed remains unknown. When a request object is created, an estimated price is calculated and returned.\n\nBelow provides a parent abstract class of a taxi request:\n\npublic abstract class TaxiRequest<T> {\n  protected T pickUpLocation;\n  protected String destination;\n  protected double distance;\n  protected double estimatedPrice;\n\n\n  public TaxiRequest(final T pickUpLocation, final String destination, final int distance) {\n    this.createTaxiRequest(pickUpLocation, destination, distance);\n  }\n\n\n  public abstract void createTaxiRequest(final T pickUpLocation, final String destination, final int distance);\n\n\n  // Getters and setters\n}\n\nNote: As the .pickUpLocation property may be an address or a restaurant, generics are used when modeling the TaxiRequest. The other properties’ object types are known.\n\nThe constructor of TaxiRequest calls an abstract method .createTaxiRequest(). This enforces TaxiRequest‘s subclasses to override the method with instantiation logic. Although the constructors of the base class’ may make use of the abstract super’s constructor, instantiation logic remains in the concrete subclass.\n\nBelow provides the concrete subclasses of StandardTaxiRequest, SevenSeaterTaxiRequest, and MiniBusTaxiRequest that all extend the abstract TaxiRequest class above.\n\nStandardTaxiRequest:\n\npublic class StandardTaxiRequest extends TaxiRequest<String> {\n  private static final double FARE_MULTIPLIER = 1.5;\n\n\n  public StandardTaxiRequest(final String pickUpLocation, final String destination, final int distance) {\n    super(pickUpLocation, destination, distance);\n  }\n\n\n  @Override\n  public void createTaxiRequest(final String pickUpLocation, final String destination, final int distance) {\n    this.pickUpLocation = pickUpLocation;\n    this.destination = destination;\n    this.distance = distance;\n    this.estimatedPrice = distance * FARE_MULTIPLIER;\n    System.out.println(\"A taxi is on its way. The estimated fare is £\" + estimatedPrice + \".\");\n  }\n}\n\nSevenSeaterTaxiRequest:\n\npublic class SevenSeaterTaxiRequest extends TaxiRequest<String> {\n  private static final double FARE_MULTIPLIER = 2;\n\n\n  public SevenSeaterTaxiRequest(String pickUpLocation, String destination, int distance) {\n    super(pickUpLocation, destination, distance);\n  }\n\n\n  @Override\n  public void createTaxiRequest(String pickUpLocation, String destination, int distance) {\n    this.pickUpLocation = pickUpLocation;\n    this.destination = destination;\n    this.distance = distance;\n    this.estimatedPrice = distance * FARE_MULTIPLIER;\n    System.out.println(\"A large taxi is on its way. The estimated fare is £\" + estimatedPrice + \".\");\n  }\n}\n\nMiniBusTaxiRequest:\n\npublic class MiniBusTaxiRequest extends TaxiRequest<String> {\n  private static final double FARE_MULTIPLIER = 3.4;\n\n\n  public MiniBusTaxiRequest(final String pickUpLocation, final String destination, final int distance) {\n    super(pickUpLocation, destination, distance);\n  }\n\n\n  @Override\n  public void createTaxiRequest(final String pickUpLocation, final String destination, final int distance) {\n    this.pickUpLocation = pickUpLocation;\n    this.destination = destination;\n    this.distance = distance;\n    this.estimatedPrice = distance * FARE_MULTIPLIER;\n    System.out.println(\"A minibus is on it's way. The estimated fare is £\" + estimatedPrice + \".\");\n  }\n}\n\nAs these model classes inherit their properties from the base class, they each automatically have pickUpLocation, destination, and distance as fields. The pickUpLocation in these cases is an address, and therefore, pickUpLocation is of type String.\n\nThe constructors for these concrete models, call super() which in turn calls the overridden method .createTaxiRequest().\n\nThe overridden method createTaxiRequest() handles the instantiation logic of the class. The properties .pickUpLocation, .destination, and .distance are set, with the .estimatedPrice programmatically calculated using the static property FARE_MULTIPLIER. A print statement has been added to help illustrate the pattern.\n\nBelow provides the concrete subclass FoodDeliveryRequest that extends the abstract class, TaxiRequest:\n\npublic class FoodDeliveryRequest extends TaxiRequest<Restaurant> {\n\n\n  private static final double FARE_MULTIPLIER = 0.7;\n\n\n  private double foodBill;\n\n\n  public FoodDeliveryRequest(Restaurant pickUpLocation, String destination, int distance) {\n    super(pickUpLocation, destination, distance);\n  }\n\n\n  @Override\n  public void createTaxiRequest(Restaurant pickUpLocation, String destination, int distance) {\n    this.pickUpLocation = pickUpLocation;\n    this.destination = destination;\n    this.distance = distance;\n    this.foodBill = pickUpLocation.getPrice();\n    this.estimatedPrice = distance * FARE_MULTIPLIER + this.foodBill;\n\n\n    System.out.println(\"Your food from \"\n                     + this.pickUpLocation.toString().toLowerCase()\n                     + \" is on its way! The total bill (including delivery) is £\"\n                     + this.estimatedPrice\n                     + \".\");\n  }\n}\n\nThe FoodDeliveryRequest differs from the other concrete model classes in two important ways. Firstly, the estimatedPrice is calculated to include the cost of food from the restaurant, and secondly, the pickUpLocation is a restaurant not an address.\n\nBelow provides an enum modeling the restaurant choice and its associated price:\n\npublic enum Restaurant {\n  MCDONALD(5.30),\n  KFC(4.99),\n  BURGER_KING(8.20),\n  DOMINOS(10.99);\n\n\n  private final double price;\n\n\n  Restaurant(double price) {\n    this.price = price;\n  }\n\n\n  // Getter\n}\n\nNote: When the restaurant type is chosen, the constructor provides the property price with the correct value.\n\nThe factory class gives us an opportunity to think how the client may need to instantiate different objects and what information may be required. In this example, if little information is provided, a StandardTaxiRequest is returned. If the pickUpLocation is a restaurant then a FoodDeliveryRequest is returned. A taxi can be ordered based on the amount of passengers. And finally a specific TaxiType can be explicitly requested.\n\nBelow provides the creator class to determine and instantiate request objects:\n\npublic class TaxiCreator {\n\n\n  // Creates a default taxi request should little information be provided\n  public static TaxiRequest<?> getTaxiRequest(final String pickUpLocation, final String destination, final int distance) {\n    return new StandardTaxiRequest(pickUpLocation, destination, distance);\n  }\n\n\n  // Creates a food pick up request should a Restaurant order be the pick up location\n  public static TaxiRequest<?> getTaxiRequest(final Restaurant pickUpLocation, final String destination, final int distance) {\n    return new FoodDeliveryRequest(pickUpLocation, destination, distance);\n  }\n\n\n  // Creates taxi request based on the number of passengers\n  public static TaxiRequest<?> getTaxiRequest(final int numOfPassengers, final String pickUpLocation, final String destination, final int distance) {\n    if (numOfPassengers <= 0 || numOfPassengers >= 30) {\n      throw new IllegalArgumentException(\"Unable to create TaxiRequest for \" + numOfPassengers + \" passengers\");\n    }\n\n\n    switch (numOfPassengers) {\n      case 1: case 2: case 3: case 4 :\n        return new StandardTaxiRequest(pickUpLocation, destination, distance);\n      case 5: case 6:\n        return new SevenSeaterTaxiRequest(pickUpLocation, destination, distance);\n      default:\n        return new MiniBusTaxiRequest(pickUpLocation, destination, distance);\n    }\n  }\n\n\n  // Creates taxi request based on TaxiType\n  public static TaxiRequest<?> getTaxiRequest(final TaxiType taxiType, final String pickUpLocation, final String destination, final int distance) throws Exception {\n    switch (taxiType) {\n      case STANDARD_TAXI:\n        return new StandardTaxiRequest(pickUpLocation, destination, distance);\n      case SEVEN_SEATER:\n        return new SevenSeaterTaxiRequest(pickUpLocation, destination, distance);\n      case MINI_BUS:\n        return new MiniBusTaxiRequest(pickUpLocation, destination, distance);\n      default:\n        throw new IllegalArgumentException(\"TaxiType \" + taxiType + \" not recognised\");\n    }\n  }\n}\n\nThe factory method .getTaxiRequest() has been overloaded using four different signatures.\n\nThe first .getTaxiRequest(String, String int) that returns a StandardTaxiRequest object as the pickUpLocation is of type String and both numberOfPassingers and TaxiType have been negated from the method call.\n\nThe second .getTaxiRequest(Restaurant, String, int) that returns a FoodDeliveryRequest object as the pickUpLocation is of type Restaurant.\n\nThe third .getTaxiRequest(int, String, String, int) that returns a taxi request is based on the number of passengers provided and is determined by a switch statement. Should the number of passengers exceed or fall below the required amount, an exception is thrown.\n\nFinally, the fourth .getTaxiRequest(TaxiType, String, String, int) that returns a taxi request based on the TaxiType is specified and determined by a switch statement. Should the TaxiType not be recognized, an exception is thrown.\n\nBelow provides the enum TaxiType for requesting a specific taxi:\n\npublic enum TaxiType {\n  STANDARD_TAXI,\n  SEVEN_SEATER,\n  MINI_BUS\n}\n\nThe Main class below, starts the program and acts as the client in this example. It asks the creator to instantiate different taxi request objects by calling the overloaded methods. The print statement in each of the model classes should be outputted to the console respectively.\n\npublic class Main {\n\n\n  public static void main(String[] args) throws Exception {\n    System.out.print(\"Standard taxi (default) - \");\n    TaxiCreator.getTaxiRequest(\"1 Charming Av\", \"49 GoodFeeling Ln\", 5);\n\n\n    System.out.print(\"Food Delivery (Restaurant) - \");\n    TaxiCreator.getTaxiRequest(Restaurant.MCDONALD,\"49 GoodFeeling Ln\", 5);\n\n\n    System.out.print(\"Seven seater (passengers) - \");\n    TaxiCreator.getTaxiRequest(6, \"1 Charming Av\", \"49 GoodFeeling Ln\", 5);\n\n\n    System.out.print(\"Mini bus (TaxiType) - \");\n    TaxiCreator.getTaxiRequest(TaxiType.MINI_BUS, \"1 Charming Av\", \"49 GoodFeeling Ln\", 5);\n\n\n    System.out.print(\"Error - \");\n    TaxiCreator.getTaxiRequest(345, \"1 Charming Av\", \"49 GoodFeeling Ln\", 5);\n  }\n}"},{"title":"Framework","description":"Frameworks are softwares that provide reusable boilerplate code and functionality for building applications. They are commonly associated with a specific programming language and are suited to different types of tasks.\n\nUsing frameworks can save time and reduces the risk of hard-to-find errors. Plus, frameworks have already been tested, so there’s less to worry about. Other advantages include:\n\nBoilerplate code that is clean, secure, and scalable.\nBetter tests and debugging methods.\nThe ability to customize the code for a specific project.\n\nUnlike libraries, which are pieces of reusable code, frameworks provide supporting structures that the code must follow.\n\nTypes of Frameworks\n\nFrameworks can be used for developing many types of software including the following.\n\nWeb Application Frameworks\n\nThese frameworks are used for developing any softwares for the Web, including websites, web applications, and Web APIs. A few common examples of web frameworks include:\n\nAngular, an open-source TypeScript-based framework.\nDjango, a Python-based framework that is fast, secure, and has a great admin interface.\nRails, a full-stack framework written in Ruby.\nGatsby, a React-based framework used for building static websites like landing pages, portfolios, and blogs.\nMobile Development Frameworks\n\nThese frameworks are used for building applications that can be used on various mobile devices including phones, tablets, and wearables. A few common examples of mobile frameworks include:\n\nFlutter is an open-source framework supported on iOS and Android and features customizable widgets.\nReact Native, a framework that is cross-platform and written in JavaScript.\nNativeScript, an JavaScript framework that features robust backend-end support."},{"title":"Front-End","description":"The front-end of a website includes elements that the end user interacts with directly. A lot goes into front-end development, including:\n\nStyling for the overall look of the website such as buttons, layouts, inputs, text, and images.\nAccessibility features like text-to-speech, voice recognition, simple user flows, and more make websites easier to use and provide a better user experience.\nImprovements to performance and speed for a better user experience.\nCommon Tasks\n\nFront-end web development can involve a variety of tasks, including:\n\nCreating and updating webpages.\nBuilding HTML emails for email campaigns.\nMaking sure webpages are responsive and work well on phones or tablets.\nImproving website performance by cleaning and splitting code.\nAdding and improving accessibility features.\nFront-End Technologies\n\nThe following are the three core techologies used in front-end development:\n\nHTML, the “skeleton” of a webpage, is used to structure the content’s layout and general behavior on the browser.\nCSS, the “skin and clothes” of the webpage, gives browsers more specific information on styling content, like the size and color of text or the look and layout of a group of elements.\nJavaScript is executed on both the client-side and server-side to bring interactivity to elements such as maps and animated graphics.\n\nFront-End Developers also use other tools, ranging from content management systems (CMSs) like WordPress and Drupal to libraries and frameworks like React, Angular, and Vue. Libraries and frameworks allow you to use a blueprint to create web elements like buttons rather than creating a new one every time.\n\nCareers in Front-End\n\nWhile there are various roles and titles in the world of front-end development, the two primary roles are front-end design and front-end engineering.\n\nFront-End Designers\n\nSometimes to known as a Front-End Interface Developer, this role usually takes static media such as drawings or images and translates them into webpages. This is important, since all webpages for the same site should have matching designs and be responsive to various screen sizes.\n\nFront-End Engineers\n\nThis role is more focused on a webpage’s functionality and scalability. Some Front-End Engineers also work on design if their workplace uses the two roles interchangeably."},{"title":"Functional Programming","description":"Functional Programming (FP) is a declarative software development paradigm that encourages constructing programs by composing pure functions and evaluating expressions instead of statements. The functions are isolated and independent of the state of the application.\n\nIn FP, dependencies such as variables or objects needed for a function, are always declared explicitly by passing them into the function as arguments. Any operation inside the function is therefore bound to the arguments passed, instead of depending on global objects or variables. This makes the function:\n\nSuitable for testing and debugging.\nPredictable, reusable, and stable when refactoring code.\n\nFP helps make code more modular and understandable.\n\nCore Principles of FP\n\nFP revolves around a few fundamental concepts that are important to discern in order to understand what makes it a popular approach to software development.\n\nFirst-class entities\n\nIn FP, functions are considered to be first-class entities. This means that functions can be:\n\nAssigned to a variable\nPassed as arguments into other functions\nReturned from other functions, just as any other data type can.\n\nHigher-order functions are a type of first-class functions, as they can take functions as arguments and/or return a function.\n\nPure Functions\n\nPure functions are the bread and butter of FP. They are functions that always produce the same output for the same set of inputs and do not cause any side effects. The application state is not impacted apart from the return value of the pure functions and no data is altered. This aspect is known as referential transparency: pure functions can be replaced with their returned value without changing the behavior of a program.\n\nImmutability\n\nThat latter property of pure functions can further be defined as immutability. This means that variables or objects outside of the function are unaffected. Instead, copies are created and returned from the function if needed.\n\nGenerally speaking, FP is about avoiding a shared mutable state, which is when different parts of the program are able to access data that can be modified and that exist in a shared scope.\n\nFunction Composition\n\nThe process of composing functions can be described by chaining two or more function calls; once the first function is called, its return value is passed to a second function as an argument.\n\nRecursive Functions\n\nIn FP, iteration is implemented through recursion as opposed to for and while loops. Recursive functions repeatedly call themselves until a specified base case is met. Conceptually, this technique breaks down a problem into smaller pieces, contributes to the removal of side effects, and improves readability."},{"title":"Function","description":"Functions hold a distinct place among the data types. They are blocks of code that yield results or perform a specific task. In some programming languages, they are processed as objects of data. This is because in some languages they are derived from objects and its closest classification is with composite data types.\n\nMany languages treat functions as first-class objects, which means:\n\nThey can be assigned to variables.\nThey can be passed as arguments to or returned by other functions.\nFunctions in Different Languages\nC\nC++\nJavaScript\nPHP\nPython\nRuby\nTypeScript"},{"title":"Git","description":"Git is a distributed version control system that allows a developer to track changes made to files in their projects. Teams of developers can use Git to collaborate on a single project at scale. This is made possible by branching, which allows developers to make specific changes to eventually be merged into the main branch of the codebase (or Git repository).\n\nAt it’s core, Git is a command line tool that comes with built-in commands for performing a variety of tasks.\n\nCommon Commands\ngit --version\n\nRun this command to see version running on local machine.\n\n$ git --version\ngit version 2.26.0\ngit init\n\nThis command initializes a new Git repository or reinitializes one that already exists.\n\n$ git init\nInitialized empty Git repository in /Path/to/current/working/directory/.git/\ngit branch\n\nThis command has a few applications. Some of its main functions include:\n\nListing Branches\n$ git branch\n * branch-1\n * branch-2\n * main\nCreating a Branch\n$ git branch branch-3\n$ git branch\n * branch-1\n * branch-2\n * branch-3\n * main\nDeleting a Branch\n$ git branch -d branch-2\nDeleted branch branch-2 (was 670d2ed).\n$ git branch\n * branch-1\n * branch-3\n * main"},{"title":"GitHub","description":"GitHub (GH) is a UI-based version control platform that runs on Git. It offers many services including version control, static website hosting, open-source software (OSS) projects, and much more.\n\nGithub Pages\n\nGithub Pages is a service offered by GH for hosting static websites for free with an unlimited amount of visits. It automatically has encryption with HTTPS. GitHub Pages also supports custom domains."},{"title":"Grace Hopper","description":"Grace Hopper was an American computer scientist who led a decorated career in the United States Navy, becoming one of the first female rear admirals in U.S. history.\n\nGrace Hopper began her career in service in the United States Navy Reserve, and was assigned to work on the Bureau of Ships Computation Project at Harvard in 1944. There she served on the computer programming staff that developed the Automatic Sequence Controlled Calculator (ASCC) also known as Mark I used in the war effort during the last part of World War II.\n\nHopper went on to contribute to the development of the UNIVAC I (UNIVersal Automatic Computer I), the first computer designed for general business application in the U.S. at Eckert-Mauchly Computer Corporation.\n\nHopper is also recognized as the originator of the theory of machine-independent programming languages with her first paper on compilers, in 1952. With the notion that code should be able to be written in English, Hopper as the director of automatic programming and her team developed FLOW-MATIC & MATH-MATIC.\n\nHopper then served as the technical consultant to the Conference on Data Systems Languages (CODASYL) committee that developed COmmon Business-Oriented Language (COBOL) in 1959.\n\nThe Grace Hopper Celebration of Women in Computing Conference was designed in honor of Hopper’s legacy in the field of computer science to facilitate more opportunities for women in the field.\n\nFun fact: The cafeteria room was named after Grace Hopper in Codecademy’s old office."},{"title":"GraphQL","description":"GraphQL is an open-source query language that allows developers to consume, construct, and create APIs in their own unique way.\n\nHistory of GraphQL\n\nGraphQL was developed by Facebook in 2012 to address internal issues with their mobile applications. As an alternative to typical REST architecture, GraphQL became open-source in 2015. Consequently, because GraphQL makes data transfers more efficient, it reduced network usage for Facebook’s mobile applications drastically. Since then, GraphQL has attracted a large number of developers and is becoming increasingly popular for client-server communication.\n\nWhy adopt GraphQL?\n\nBefore discussing GraphQL, developers should be familiar with REST. One of REST’s disadvantages is that it can result in an excessive number of HTTP queries or too much data being fetched. GraphQL aims to improve upon REST philosophy by allowing developers to ask for a specific data instead of fetching a whole giant object. There is no room for errors like underfetching and overfetching with GraphQL. Finally, GraphQL allows developers to easily integrate with databases, JSON files, REST APIs and cloud services.\n\nHow GraphQL works under the hood?\n\nA common GraphQL workflow can be seen below:\n\nFirst, a specific data is requested from the client via a query to GraphQL server.\nIn order to get data, a function on the GraphQL server is invoked.\nLastly, GraphQL server return the specific data requested by the client.\nWho is using GraphQL?\n\nGraphQL is used by a wide range of businesses, from large to small. Some bigger names include Airbnb, Lyft, GitHub, Twitter, Paypal, and Shopify. For more information, feel free to check out “Who’s using GraphQL?”."},{"title":"HTTP","description":"Hypertext Transfer Protocol (HTTP) is used for fetching HTML documents and other web-based resources. It follows a model where a client (most commonly a browser) requests content stored on a server.\n\nHTTP/HTTPS\n\nInstead of HTTP, a more secure version, HTTPS, should be used in order to encrypt information sent between the client and server. This encryption is done with Transport Layer Security (or TLS, formerly SSL). Some benefits of HTTPS include:\n\nFinancial data, like credit card information or bank account numbers, are protected from interception.\nDomain-ownership can be better verified by users.\nA growing standard of trust around sites that use HTTPS.\n\nWebsites can be certified with HTTPS so that browsers “know” the official site for a person, business, etc. These certifications are approved and signed by a trusted certificate authority (CA).\n\nRequests\n\nHTTP requests are stateless, meaning that all requests are independent and have no knowledge of one another. Requests contain the following parts:\n\nThe HTTP method being used (more information shortly).\nThe requested URL along with any queries or parameters.\nThe HTTP version, such as 1.1 or 2.0.\nAny header information such as:\nThe referer that tells the URL where the request came from.\nAny user agent information about the requesting client.\nA unique host name that is ideal for many pages on one server.\nCookie data about the request.\nA response-like body that contains the resource to be sent (common with the POST method).\n\nAn HTTP client requests information specific URLs using four primary methods:\n\nMethod\tDescription\nGET\tRequests data, content, or other resources from the server.\nPOST\tSends data, content, or other resources to the server.\nPUT\tSends updates for existing content on the server.\nDELETE\tDeletes specific content from the server.\nResponses\n\nIf the server is able to connect with the client and fulfill its request, it will send back a response that includes the following parts:\n\nThe version of HTTP being used.\nHeaders similar to the ones used for HTTP requests.\nA body that contains the successfully requested resource.\nA status code with a message explaining why the request succeeded or failed.\n\nA breakdown of response status codes is shown below.\n\nInformational\nStatus Code\tName\tDescription\n100\tContinue\tThe request should continue or be ignored if finished.\n102\tProcessing\tThe server is currently processing the request; no response yet.\nSuccessful\nStatus Code\tName\tDescription\n200\tOK\tThe request is successful and a response was sent.\n202\tAccepted\tProcessing not yet finished but request was accepted.\nRedirection\nStatus Code\tName\tDescription\n301\tMoved Permanently\tThe resource URL was changed and the new one was sent in the response.\n304\tNot Modified\tUsed by caches for serving the same, unmodified content.\nClient Errors\nStatus Code\tName\tDescription\n400\tBad Request\tInvalid request based on client-side error (invalid syntax, URL, etc.).\n401\tUnauthorized\tInvalid client credentials, such as an API key.\n404\tNot Found\tServer couldn’t find resource (e.g. invalid URL).\nServer Errors\nStatus Code\tName\tDescription\n500\tInternal Server Error\tError occurred on the server-side.\n502\tBad Gateway\tInvalid response from a gateway or proxy server.\nCaches and Proxies\n\nHTTP can be used for improving web performance with caches and proxy servers.\n\nClient browsers can use caches for serving content instead of making repeated requests for the same content. Examples of caches include:\n\nCDNs that retain copies of web content and serve from close network connections.\nProxy browser caches, like ones used in progressive web apps that allow a single user to cache and access content offline.\nShared proxy caches that store resources for multiple users (internet service provider, company staff network, etc.).\n\nProxies are used to mask a client’s IP address by assigning one to a proxy server and have requests sent from there."},{"title":"Hacking","description":"Hacking involves using technical skills to break into computer systems and access sensitive data. By itself, hacking is neither “good” or “bad”. It depends on many factors, including the intentions of the hacker.\n\nTypes of Hackers\n\nHackers can be split into three distinct types: black hats, grey hats, and white hats.\n\nBlack Hat Hackers\n\nThese are the hackers that are notoriously regarded as “the bad guys” that infiltrate systems either for personal gain or to impress other hackers. Generally, a black hat hacker use malware, viruses, and ransomware attacks to do the following:\n\nSteal credit card and/or bank account information.\nLeak sensitive information to the public.\nTake one company’s sensitive data and give/sell it to another.\nSteal large amounts of personal information and sell it to third parties\nCripple a company’s computer system by taking control of it and then holding it for ransome.\nSteal and sell the login information for large amounts of users.\nGrey Hat Hackers\n\nGrey hat hackers also commit malicious digital acts, but on a relatively smaller scale. They will still usually hack a system for personal gain or respect. The sort of actions a grey hat hacker may take include:\n\nAttacking and identifying vulnerabilities within a system.\nReaching out to offer their help (for a fee) without explaining the underlying issue(s).\n\nThis puts system maintainers in a tough position as to whether it would be wise to accept the hacker’s assistance with little to no information.\n\nWhite Hat Hackers\n\nWhite hackers hack for the benefit of others, particularly organizations trying to discover (and close) security vulnerabilities in their system. They always obtain permission before penetrating an organization’s system.\n\nA white hat hacker will normally engage directly with a company and listen to their concerns. Next, they will attempt to hack areas of their network to spot weaknesses. After they finish, they provide a report to the company and potential next steps.\n\nGenerally, white hat hacking involves:\n\nTesting the strength of firewalls meant to detect malicious activity.\nFinding vulnerabilities in the codebase of web applications.\nDiscovering weaknesses in databases that could leave a company susceptible to SQL injections, which target database codes and structures.\nChecking if an organization is resilient against cyberattacks such as distributed denial of service (DDoS) attacks.\nSeeing how well a company can recover after a ransomware attack.\nTesting backup systems for vulnerabilities.\nProtection From Hacking\n\nWhile not a 100%-guaruntee, steps can be taken to protect against malicious hacks, including:\n\nCreating complex, hard-to-guess passwords for all online accounts.\nNever leaving login credentials exposed in a public place.\nUsing password protection for all devices.\nAvoiding public Wi-Fi networks, such as ones at coffee shops or airports, because they have lax security measures.\nConnecting to services with a VPN, which encrypts all data you send and receive while connected.\nUsing an internet firewall to help filter out malicious data.\nLearning to recognize and avoid phishing attacks and other types of social engineering.\nOnly installing software from trusted sources.\nAvoiding websites that might host malicious code.\nHacking Tools\n\nLearning how hackers think, as well as the tools they often use, can be invaluable. This involves the following programming languages and tools:\n\nPHP\nPython\nR\nBootstrap"},{"title":"Inheritance","description":"Inheritance is one of the most important principles of object-oriented programming (OOP). It allows for one class (child class) to inherit the fields and methods of another class (parent class).\n\nAn inherited class is also called a subclass of its superclass (parent class).\n\nInheritance is considered one of the four pillars of OOP, along with abstraction, and encapsulation, and polymorphism.\n\nExample\n// Parent Class\nclass Machine {\n  // Machine class member\n}\n\n\n// Child Class\nclass Car extends Machine {\n  // Car inherits traits from Machine\n\n\n  // Additional Car class members, functions, etc.\n}"},{"title":"IDE","description":"An IDE, or Integrated Development Environment, enables programmers to consolidate the different aspects of writing a computer program.\n\nIDEs increase programmer productivity by combining common activities of writing software into a single application: editing source code, building executables, and debugging.\n\nEditing Source Code\n\nWriting code is an important part of programming. We start with a blank file, write a few lines of code, and a program is born! IDEs facilitate this process with features like syntax highlighting and autocomplete.\n\nSyntax Highlighting\n\nAn IDE that knows the syntax of your language can provide visual cues. Keywords, words that have special meaning like class in Java, are highlighted with different colors.\n\nCompare these two code samples:\n\n// Without syntax highlighting\n\npublic class NiceDay {\n  public static void main(String[] args) {\n    System.out.println(\"It's a nice day out!\");\n  }\n}\n// With syntax highlighting\n\n\npublic class NiceDay {\n  public static void main(String[] args) {\n    System.out.println(\"It's a nice day out!\");\n  }\n}\n\nSyntax highlighting makes code easier to read by visually clarifying different elements of language syntax.\n\nAutocomplete\n\nWhen the IDE knows your programming language, it can anticipate what you’re going to type next!\n\nWe’ve seen statements with System.out.println() quite a bit so far. In an IDE, we might see System as an autocomplete option after only typing “Sy”. This saves keystrokes so the programmer can focus on logic in their code.\n\nBuilding Executables\n\nLanguages like Java and C++ are compiled languages. Before programs run, the source code of a .java or .cpp file must be transformed into an executable like .class or .exe by the compiler. Once compiled, the program can be run from the terminal.\n\nThis compilation process is necessary for every program, so why not have the IDE do it for us? IDEs provide automated build processes for languages, so the act of compiling and executing code is abstracted away, like in Codecademy lessons.\n\nDebugging\n\nNo programmer avoids writing bugs and programs with errors.\n\nWhen a program does not run correctly, IDEs provide debugging tools that allow programmers to examine different variables and inspect their code in a deliberate way.\n\nIDEs also provide hints while coding to prevent errors before compilation.\n\nNotable Examples\n\nThere are numerous IDEs available, such as:\n\nIntelliJ IDEA\nXcode\nAndroid Studio\nMicrosoft Visual Studio\n\nThe IDE you decide to use depends on what area of computer programming you wish to pursue. Some IDEs, like Android Studio and Xcode, are dedicated solely for building mobile applications."},{"title":"IoT","description":"Internet of Things (IoT) is a term used to describe hardware which can be connected to the internet in order to provide a service.\n\nIoT devices primarily work through the use of sensors associated with devices that communicate data to a server. These devices communicate over a network to determine and provide information on the devices current state. Due to the extensive number of sensors and chips neccessary for IOT devices there is a need for efficient and ecologically sustainable practices when it comes production of IoT appliances.\n\nHistory\n\nThe very first IoT devices were vending machines connected to ARPANET in 1982. These connected devices reported inventory and temperature of individual drinks. Today IoT has expanded to a myriad of use cases and promises to be a lucrative sector as more and more devices become connected.\n\nExperts predict that in the the year 2033 there will be more devices connected to the internet than human beings, but due to the limits of IPV4 (number of unique IP addresses) the adoption of IPV6 will be needed to support connectivity for the increasing number of IoT devices.\n\nTwo of the major challenges associated with IoT are security and privacy. While there are various competing standards for securing IoT devices, these standards have yet to become adopted across the board and therefore the spectrum of security of devices range with some devices being more secure than others. As a result application security varies from provider to provider depending on their respective security and privacy practices."},{"title":"John Carmack","description":"John Carmack is an American video game developer, and the lead programmer of Commander Keen, Wolfenstein 3D, Doom, and Quake.\n\nIn 1990, John Carmack and a small team developed the first Commander Keen game, a now classic side-scrolling video game.\n\nAfter the success of Commander Keen, Carmack co-founded id Software, with the other developers: John Romero, Tom Hall, and Adrian Carmack. Their first release would be a genre-founding Wolfenstein 3D, which introduced several advancements in graphical fidelity and the first-person shooter (FPS) genre.\n\nThis genre was further explored by Carmack and his team in the Doom and Quake series, some of the most successful franchises in the video game industries history.\n\nTo develop some of the techniques present in these titles, Carmack has developed a number of algorithms including the Carmack’s Reverse algorithm, which was used in Doom 3 to add shadows to a rendered scene.\n\nFollowing his work with id Software, in 2013 John Carmack continued his game development career with Oculus VR as Chief Technical Officer."},{"title":"Jupyter Notebook","description":"Jupyter Notebook (sometimes called IPython Notebook) is a popular way to write and run Python, R, or Julia code, especially for data analysis, data science and machine learning. Jupyter Notebooks are easy-to-use because they let you execute code and review the output quickly. This iterative process is central to data analytics and makes it easy to test hypotheses and record the results (just like a notebook).\n\nIntegrated Development Environment (IDE)\n\nJupyter Notebook is a type of Integrated Development Environment (IDE). IDEs are places to write code that offer some supportive features. Almost all IDEs provide syntax highlighting, debugging, and code completion. Jupyter Notebook also offers embedded help documentation and introspection (i.e., you can check each command’s parameters) and in-line display of charts and images.\n\nFront-end and Back-end\n\nA Jupyter Notebook has two parts:\n\nThe front-end interface\nThe back-end kernel\n\nThe front-end interface loads in a web browser and consists of “cells” where you enter your code. The browser is just for display, so you do not need to be connected to the internet.\n\nJupyter Notebook uses a back-end kernel called IPython. The ‘I’ stands for ‘Interactive’, which means that a program or script can be broken up into smaller pieces, and those pieces can be run independently from the rest of the program.\n\nUses\nData Cleaning and Transformation\nNumerical Simulation\nStatistical Modeling\nData Visualization\nMachine Learning\nAnd more!\nPrivacy\n\nWhile users interactively author .ipynb notebooks in their preferred browser, standard install instructions allow Jupyter to run on one’s local machine, not on the web. By default, a notebook server runs locally at http://localhost:8888."},{"title":"Ken Thompson","description":"Ken Thompson is an American computer scientist, known for creating many significant works in the field, such as the Unix and Plan 9 operating systems, the B (1969) and Go (2019) programming languages, the grep command line utility, and UTF-8 encoding.\n\nKen Thompson is best known for working alongside Dennis Ritchie and others at Bell Laboratories, where they began working on Unix in 1967 as a replacement operating system for the Digital Equipment Corporation’s PDP-7 mini computer.\n\nDuring this time, Ken Thompson developed the B programming language, which would become the precursor for the incredibly popular and influential C programming language."},{"title":"Machine Code","description":"Machine code (also known as machine language or native code) is a low level programming language in the form of hexadecimal or binary instructions that execute computer programs on the computers’ CPU. Machine code is the lowest level of code which means that it communicates the programs instructions in the form of software directly to the hardware of the computer via the Central Processing Unit (CPU).\n\nIn the early days of programming, applications were written directly in machine code, but as that method of developing applications is tedious and inefficient, programmers developed new higher level programming languages like C, Java and Python to be processed by compilers and turned into machine code for execution in the CPU.\n\nEvery computer processor has its own instruction set designed to process machine code. These instruction sets make up a sort of class for the interpretation of machine code. Due to the distributed market and competition, CPU creators lack a universal machine code standard to rule them all, which means special attention is required to ensure new processors are able to support (without bugs) pre-existing and current programs when they are ultimately converted into machine code.\n\nThe ASCII value for the letter “A” in machine code is 01000001, but this data is displayed as “A” on the screen. Everything visually represented in computers is based on output of machine code processed by the CPU.\n\nWhat Machine Code looks like\n\nAn easy way to visualize how machine code is stored is to look at some in a hex editor, which shows the binary data represented by hexidecimal numbers.\n\nFor example, take the instruction:\n\n0xEB 0xFE\n\nThis could also be written as 11101011 11111110 in binary.\n\nThis instruction represents an infinite loop on a x86 CPU. It can be coded in assembly language like this:\n\nj:\njmp j"},{"title":"Linus Torvalds","description":"Linus Torvalds is a Finnish-American computer scientist, the creator of the operating system kernel Linux, and the distributed revision control system Git.\n\nThe Linux kernel is an open source, Unix-inspired operating system kernel publicly released in Version 1.0 by Linus Torvalds in 1994. Today, the Linux operating system manages the hardware and resources of a great number of applications in the Linux distribution, Android, and Chrome OS.\n\nGit was later created by Torvalds in 2005 out of a need for a replacement free distributed system for continued development of the Linux kernel. To support the needs of the Linux kernel team, Torvalds needed a free distribution system that would patch in no more than three seconds, and protect users against accidental or malicious corruption."},{"title":"Memoization","description":"Memoization is a technique that improves the speed of a program by storing any new inputs for future reference, if needed. This cuts down on any repeated computations in the program where the same inputs are being used to return the same result.\n\nThis technique gets its name from the Latin word, “memorandum”, which means to be remembered. Memoization can be applied to many contexts in computer programming, including:\n\nMaking calls to recursive or pure functions where some calculations use the same inputs and return the same outputs.\nFetching from the server with the same base API endpoints.\n\nMemoization can be implemented in most programming languages, including JavaScript and Python. However, while memoization saves performance time, it comes with a cost in memory space since it is caching results that were already calculated."},{"title":"Machine Learning","description":"Machine learning (ML) is a discipline of computer science that relates to the use of data and algorithms to develop computer programs that improve their performance at tasks without being explicitly programmed to do so. Machine Learning is considered a branch of Artificial Intelligence as some machine learning algorithms are designed to imitate the way that humans learn and interact with their environment.\n\nBranches of Machine Learning\nSupervised Learning\n\nMachine Learning algorithms that receive labeled data as input and produce a prediction as output.\n\nRegression: Predicts a continuous-valued output.\nLinear regression: Plots the line or plane of “best fit” of optimal values for prediction tasks.\nLogistic regression: Classifies elements in a data set into discrete categories.\nClassification: Categorizes data points into discrete groups.\nNaïve-Bayes classifier: Uses Bayes’ theorem of probability to perform classification of elements.\nSupport vector machine (SVM): Margin classifiers that define hyperplanes to separate data points into discrete categories.\nArtificial Neural Networks (ANN): Classifiers modeled after biological neural networks with relatively high performance capabilities in regression and classification tasks.\nUnsupervised Learning\n\nMachine Learning algorithms that receive unlabeled data as input and produce a grouping or clustering as output.\n\nClustering: Recognize patterns and structures in unlabeled data by grouping them into clusters.\nK-Means: Categorizes data points into clusters based on their proximity to cluster centroids.\nHierarchical Agglomerative Clustering: Groups data points into clusters based on various measures of similarity such as smallest average distance between all points, minimal variance between data points, or smallest maximum distance between data points.\nDimensionality Reduction: Scale down the amount of dimensions in the dataset from a high-dimensional space into a low-dimensional space, while maintaining the maximum amount of relevant information.\nPrincipal Component Analysis (PCA): Reduces the dimensionality of a dataset to the ‘n’ number of principal dimensions that contain the most valuables information.\nReinforcement Learning\n\nMachine learning algorithms that act as agents in an environment, which receive a current state, environment, reward, and goal as input and produce a policy of best action relative to the stated goal as output.\n\nModel-Free: Act as trial-and-error algorithms that use only real samples of the environment to calculate optimal actions instead of the transition probability distribution to create a model of the environment.\nModel-Based: Create models of the environment to generate predictions of the next state and reward to calculate optimal actions.\n\nSome methods used in reinforcement learning include:\n\nMarkov Decision Processes (MDPs): Use a model of the environment based on their state transition probability and reward functions to create a policy of optimal action and satisfy the Markov property.\nMonte-Carlo methods: Model-Free randomized algorithms that learn from episodes of experience whether continuous or terminal to calculate the value for a state based on the average return from those experiences.\nQ-Learning/Deep Q-Learning: Model-Free algorithms that focus on maximizing the expected value of reward using q-tables, or artificial neural networks.\nMachine Learning vs. Deep Learning\n\nDeep Learning is the subset of machine learning that focuses on artificial neural networks. The “deep” component of the name is in reference to the many hidden layers that typically are embedded within neural networks that simulate the function of a biological brain.\n\nThe relatively high performance of neural networks in human-like tasks such as speech and object recognition distinguish deep learning from other machine learning algorithms.\n\nEvaluation\n\nThere are several methods to accurately evaluate the performance of ML algorithms. Methods vary based on which algorithm is being evaluated, and for which purpose. For classifiers such as Logistic Regression, confusion matrices inform analysts of the number of true and false positives as well as negatives to calculate values such as recall, precision, and F1 scores.\n\nThese values help analysts understand if their models are underfitting or overfitting, which is critical to improving and maintaining their performance."},{"title":"Method","description":"Classes can be broken into two core parts:\n\nThe data that is attributed to a class’s members or properties.\nThe behaviors that are defined or inherited in the class.\n\nMethods are the “behavior” part of the class. When an instance variable is created from a class, it has access to the class’s associated methods. Methods can accept parameters (sometimes they’re called “arguments”) and can return a result.\n\nIn object-oriented programming, methods promote reusability and keep functionality encapsulated inside an object.\n\nExample\n\nIn the Python example below, a class for a character in a game, Character, is defined with certain behaviors. The character can:\n\nIntroduce themselves via .introduceSelf().\nMove left given an integer amount via .moveLeft().\nMove right given an integer amount via .moveRight().\nclass Character:\n  def __init__(self, name, movex):\n    self.name = \"Player\"  # Character's name\n    self.movex = 0        # Character's starting position\n\n\n  def introduceSelf(self):\n    # Print out an introduction phrase\n    print(f\"Hello! I'm {self.name}.\")\n\n\n  def moveLeft(self, x):\n    # Move the character left by x pixels\n    self.movex -= x\n\n\n  def moveRight(self, x):\n    # Move the character right by x pixels\n    self.movex += x\n\nNow, when an instance of Character is created, the game character can introduce themselves, move left, or move right.\n\nMethods in Different Langauges\nMethods in C++\nMethods in Java\nMethods in JavaScript\nMethods in Python"},{"title":"Middleware","description":"Middleware is software that connects applications together. The term “middleware” comes from the fact that this software sits between the front-end, or client-side, of an application and the back-end, or server-side, where the resources are being requested.\n\nTypes of Middleware\n\nData, APIs, software tools, and other applications are connected by middleware in order to bring a complete or bundled application to the end user. There are many types of middleware software depending on the use cases. Some of the most commonly used middleware are listed below.\n\nMessage Oriented Middleware\n\nA message oriented middleware, or MOM, allows applications to exchange messages and communicate with one another. This middleware offers ease of use but can be costly at larger scales.\n\nExamples\nRabbitMQ\nIBM MQ\nAmazon SNS\nDatabase Middleware\n\nThis type of middleware gives access to databases and provides points of interaction between a variety of databases. This middleware improves efficiency however it can be language specific which can create limitations.\n\nExamples\nODBC\nJDBC\nAPI Middleware\n\nThis type of middleware provides developers with the tools to create and manage APIs used in applications. While it offers scalability, connections can be slow when dealing with different servers.\n\nExamples\nAPI management platforms\nAPI gateways"},{"title":"Moore's Law","description":"Moore’s Law is a prediction made in 1965 by Gordon Moore (the then CEO of Intel) stating that twice as many transistors would be able to fit onto a computer chip every two years. This idea has served as a guiding principle and goal for the semiconductor industry in order to make sure that progress is being made consistently towards greater computing power in devices.\n\nMoore’s law is more of an economic law than it is one based on physics. There are natural limitations to Moore’s Law such as the fact that computer chips can only get so small before reaching the atomic barrier(we can not currently make chips smaller than an atom) which have logically led to the conclusion that though Moore’s Law has guided most of the industry for over 50 years, it perhaps will not forever hold true as an accurate description of the state of things technologically, still it has been a concept that has proved to be a great driving force in the world of computing."},{"title":"Modulo","description":"Modulo is a mathematical operation that returns the remainder of a division of two arguments. It is available in every programming language.\n\nSyntax\n\nThe remainder is what is left over after dividing the first argument, the dividend, by the second, the divisor or modulus:\n\nremainder = dividend % divisor\n\nMost programming languages use the % symbol to represent the modulo operation, though some may use mod or other variations.\n\nExamples\n\nThe following is an example of the modulo operator in Python:"},{"title":"Next.js","description":"Next.js is an open-source development framework that brings the best of React’s client-side functionality to the server-side when building web applicatons.\n\nAdditionally, Next.js comes with built-in features including the following:\n\nA page-based routing system that supports dynamic routes.\nEvery page is pre-rendered for improved site performance and SEO.\nAny page can either be statically generated (SSG) ahead of time or rendered on the server-side (SSR) upon request.\nFaster page loads enables automatic code splitting or “lazy-loading”.\nAn in-house Link component is used for client-side routing with optional pre-fetching.\nThere is vast styling support including built-in CSS, Sass, and CSS-in-JS libraries.\n\nNext.js was originally authored by Guillermo Rauch on GitHub in 2016 and due to its functionality, large companies such as Netflix, Starbucks, Uber, GitHub, and Ticketmaster have all used Next.js for their website development. It is currently owned and maintained by the company Vercel.\n\nFun Fact: Codecademy Docs is built with Next.js."},{"title":"NFT","description":"A non-fungible token (NFT) acts as a digital representation to prove ownership for a digital good backed by blockchain technology.\n\nThe term “token” in the phrase “non-fungible token” refers to this digital representation. “Non-fungible” simply means “non-replaceable”. It can’t be replaced, is one of a kind, and is always unique.\n\nFor example, a single U.S. Dollar note of $1 is fungible because it is able to be replaced with another $1 note. However, each NFT is always unique and cannot be simply swapped for another different NFT, even if both are a representation of the same general good. This means that non-fungible items can be far more valuable than fungible items.\n\nMinting an NFT\n\nCreating an NFT is known as “minting”. Minting an NFT is the process of taking a piece of content and putting it on a digital registry, or the blockchain. During this process, some critical information such as owner name, date, and time is placed on the blockchain. The most common blockchain for minting NFTs is Ethereum. A person can manage any NFTs that the person mints or owns through a crypto wallet.\n\nA crypto wallet is a digital wallet used to store cryptocurrencies and NFTs. They are the only place where NFTs can be minted or purchased. The ownership history of an NFT is easily traceable, verifiable, and can be seen by anyone using the blockchain.\n\nAs of now, NFTs are most often used to prove ownership over a digital good, but they have many other potential uses yet to be explored in an ever-growing market.\n\nEnvironmental Impact\n\nThe amount of electricity consumed for regulating and verifying blockchain transactions leads to massive carbon emissions. It’s estimated that a single NFT transaction (minting or selling) can emit an average of 40kg of CO2."},{"title":"Node.js","description":"Node.js is a JavaScript runtime for building server-side or desktop applications. It is free and open-sourced.\n\nJavaScript and Node.js\n\nJavaScript has existed since 1995 and has since taken over as the dominant language for web development. For much of its life, JavaScript was used mainly for client-side scripting inside <script> tags executing in web browsers. This limitation meant that developers were often working in many different languages and frameworks between the frontend (client-side) and backend (server-side) aspects of a web application.\n\nAlthough there were other projects to bring JavaScript to server-side applications, the functionality took off with the launch of Node.js in 2009. Node allows developers to write JavaScript code that runs directly in a computer process itself instead of in a browser. Node can, therefore, be used to write server-side applications with access to the operating system, file system, and everything else required to build fully-functional applications.\n\nNode.js is written in C, C++, and JavaScript, and it is built on the open-source V8 JavaScript engine which also powers JavaScript in browsers such as Google Chrome. As V8 supports new features in JavaScript, they are incorporated into Node.\n\nNode-Specific Functionality\nGlobals\n\nNode provides access to several important global objects for use with Node program files. When writing a file that will run in a Node environment, these variables will be accessible in the global scope of your file.\n\nmodule is an object referring to the functionality that will be exported from a file. In Node, each file is treated as a module.\nrequire() is a function used to import modules from other files or Node packages.\nprocess is an object referencing to the actual computer process running a Node program and allows for access to command-line arguments and much more.\nModules\n\nNode has a many built-in modules to aid in interactions with the command line, the computer file system, and the Internet. These include:\n\nHTTP and HTTPS for creating web servers.\nFile System, OS, and Path for interacting with the file system, operating system, and file/directory paths.\n\nYou can view the full docs to see more of Node’s built-in features.\n\nWhy Node?\n\nPer the Node.js homepage, Node “uses an event-driven, non-blocking I/O model.” In practice, this means that Node is built well to handle asynchronous JavaScript code to perform many asynchronous activities such as reading and writing to the file system, handling connections to database servers, or handling requests as a web server.\n\nTo handle asynchronous code, Node uses a callback-based system. Node functions and methods that will implement some asynchronous activity take a callback function. This callback will be called whenever the asynchronous operation has resolved. By convention, the first argument of this callback is an error placeholder. If an error occurred in the asynchronous operation occurred (trying to read a non-existent file, for example), the error argument will be an Error object, but it will be null if no error occurs.\n\nconst fs = require('fs');\n\n\nfs.readFile('./script.js', function (error, data) {\n  // Error is null if no error occurred, but an Error object if it did\n  if (error) {\n    throw error;\n  }\n  // The file data will be passed into the callback if no error was thrown\n  console.log(data);\n});\n\nIn this example, we are using Node’s built-in fs module to read a script.js file. The callback function is called after the file-reading operation is completed. If an error occurred, it will be passed in as error and thrown. If it doesn’t exist, the retrieved data from the file reading operation is logged to the console.\n\nHow to Use Node\n\nThis video will show you how to download and install Node.\n\nTo begin, download and install Node.js for your operating system.\nTo run JavaScript files in Node, the node command followed by a file path will execute the program file.\n\nFor example, if we have the following saved in a script.js file:\n\nconsole.log('I am a Node program');\n\nWe can run the terminal command in the same folder as script.js:\n\nnode script.js\n\nThis will start Node, print I am a Node program to the terminal window, and then exit, as the script file has finished execution.\n\nNode as a REPL\n\nNode can also be used in a terminal window as a Read-Evaluate-Print-Loop, or REPL. This functionality allows you execute JavaScript commands from the command line.\n\nWith Node installed, you can launch the REPL by running the node command in a terminal and pressing Enter. You are now in an interactive JavaScript environment and can run any valid JavaScript code such as 4 + 5. After executing a command, Node will always print the result of that evaluation.\n\n$ node\n> 4 + 5\n9\n> function nodeIsGreat() {\n... console.log('Node is great!');\n... }\nundefined\n> nodeIsGreat()\nNode is great!\nundefined\n> .exit\n$\n\nIn this example, the user launches node on line one with the node terminal command.\n\nOn line 2 the user types 4 + 5 and evaluates with the Enter key. 9 prints to the output terminal.\n\nOn line 4, the user opens a function declaration of nodeIsGreat(). Because this function declaration takes multiple lines, Node REPL will print ... at the beginning of a line to show that it is still reading the user’s input statement and has not evaluated yet. After the function declaration is closed on line 6, undefined prints to the output terminal, as the function declaration itself does not evaluate to any value.\n\nWhen the function is invoked on line 8, Node is great! logs to the console, and undefined logs after, because nodeIsGreat() returns undefined.\n\nTo exit the Node REPL, use the .exit command at any point and return to the system shell. Pressing Ctrl + C twice will also exit.\n\nLoading Existing Files\n\nNode REPL can also load existing JavaScript files. If we had the following code saved into script.js:\n\nvar a = 'Node REPL is fun!';\n\nWe can use .load to load it into the REPL. .load takes a path argument, so to load script.js we would use .load ./script.js.\n\n$ node\n> .load ./script.js\nvar a = 'Node REPL is fun!';\n\n\n> a\n'Node REPL is fun!'\n\nAfter the script file is loaded, the variables are accessible in the REPL, so when we evaluate the a variable, it’s value has been set by loading script.js, and ‘Node REPL is fun!’ prints to the console.\n\nTry it out yourself by running node in a terminal or check out the REPL docs for more functionality.\n\nPackage Management\n\nNode packages are a convenient way to share modules between Node developers. The service npm is the default package manager for Node, and it ships with an installation of Node.\n\nnpm allows access to the hundreds of thousands of open-source packages available.\n\nIn addition to npm, yarn is gaining popularity as another JavaScript package manager.\n\nFor more information and to see npm in action take our Browser Compatibility and Transpilation course.\n\nNode Versions\n\nNode’s major releases aim to support the latest JavaScript features including ES6/ES2015 and beyond without transpilation.\n\nTo see a list of supported JavaScript features in different versions, visit node.green.\n\nVersion Management\n\nAs with any major release of software, top-level Node releases (8.x, 7x, etc.) sometimes introduce breaking changes in applications built in older versions of the environment. A version manager can be used to switch between multiple versions of Node on a single computer.\n\nThere are two version managers that provide this functionality: nvm (Node Version Manager) and n. N can be installed very easily as an npm package!"},{"title":"Number","description":"Numbers include -1, 0, 1, and so on. Depending on the language, numbers with decimals are of a different type. In floating-point arithmetic, there is a trade-off in precision for range. The amount of bits allocated for floating-point representation affects the range in values that can be used.\n\nArithmetic Accuracy\n\nLanguages such as JavaScript and Python yield interesting results when arithmetic operations are performed on numeric values. For example, .1 + .2 would evaluate to 0.30000000000000004, whereas adding whole numbers wouldn’t do this. But you need to keep in mind the integer limit. It is the number where the compiler won’t understand the numbers anymore."},{"title":"Object","description":"An object is an instance of a class. It contains the properties and functionalities of its class.\n\nWhen an object is created, memory will be allocated for it.\n\nObject Example in Java\n\nIn Java, an object is created using the new keyword. The new keyword tells the compiler to create a new instance of a class and allocate memory for it.\n\n// Creating the Employee class\nclass Employee {\n  int id;\n  String firstName;\n  String lastName;\n  char middleInitial;\n  float years;\n}\n\n\n// Creating five different objects from the Employee class\nEmployee tina = new Employee();\nEmployee louise = new Employee();\nEmployee linda = new Employee();\nEmployee bob = new Employee();\nEmployee gene = new Employee();\n\nIn the above example, five different objects were created from the class Employee.\n\nObjects in Different Languages\nObjects in C++\nObjects in JavaScript"},{"title":"Object-Oriented Programming","description":"Object-oriented programming (OOP) is a software development paradigm which encourages scultping desired entities with properties and methods in named classes to create applications.\n\nOOP relies on two major concepts: the class and the object - these foundational concepts applied in code enable us to build applications.\n\nClasses that have been instantiated in our code become objects that can interact with one another to perform the desired functions of the application. Object oriented programming was created to guide the creation of better software, by achieving easier maintenance and reusability.\n\nThere are four main principles of Object Oriented Programming: encapsulation, inheritance, polymorphism, and abstraction.\n\nFour Main Principles of OOP\n\nEncapsulation: A desired outcome of organizing code in classes in order to keep things from being mixed with other unrelated bits of code. Encapsulation make it easier to reason about code because of the modularity of code written in object oriented styled classes.\n\nInheritence: A principle which allows an instance of an object to borrow attributes and methods from its parent class.\n\nPolymorphism: The ability of the class to be dynamic in its use of class methods so that objects with the same parent class can make use of these parent class methods.\n\nAbstraction: A principle that highlights the benefit of hiding complex parts of code from other parts in order to make it easier to reason and make decisions about the code."},{"title":"Parameter","description":"A parameter is the name of a variable passed into a function. Parameters allow functions to accept inputs. An argument, on the other hand, is the actual value of the variable (also known as the parameter) passed into a function.\n\nExample\n\nSuppose we have a function called tripleThis():\n\nfunction tripleThis(x) {\n  return x * 3;\n}\n\n\ntripleThis(6);\n\nThe parameter is x since it is the variable. The argument is 6 since it is the actual value."},{"title":"Open Source","description":"The term “open source” refers to software that is freely available for modification and possible redistribution. Open source projects allow the source code to be reused by anyone with the restriction that any derivative projects are released under the same license.\n\nSuch projects are intended to foster open collaboration from a variety of perspectives on problem-solving. The code is reviewed and updated by groups of developers of all sizes. One benefit of this is that it provides a greater opportunity for bugs and security holes to be detected and handled effectively.\n\nOpen source software (OSS) is also thought to be more trustworthy. Since all the code is available to the public, any unwanted or nefarious behavior or activity will be quickly exposed by the development community surrounding the project.\n\nExamples of OSS\nLinux: Ever since the Linux kernel was released by Linus Torvalds in 1991, an endless variety of Linux distributions have been produced, all similarly open source. The majority of software for the Linux operating system is open source as well.\nLibreOffice: A competitor to Microsoft Office, which offers word processing, spreadsheet, presentation, and database software.\nMySQL: A database that is commonly used as a back-end database on many websites."},{"title":"Polymorphism","description":"Polymorphism is one of the four principles of object-oriented programming (OOP). It promotes dynamic inheritance of child classes from their parent class in order to make use of these features themselves in code.\n\nWith polymorphism, child classes are able to inherit methods from their parent class for use. This ability to inherit functionality from parent classes not only speeds up the development process, but also helps us reason and understand our code more intuitively as we can see the correlation between objects for easier understanding and manipulation of source code.\n\nfrom math import pi\n\n\nclass Shape:\n  def __init__(self, name):\n    self.name = name\n\n\n  def area(self):\n    pass\n\n\n  def fact(self):\n    return \"I am a two-dimensional shape.\"\n\n\n  def __str__(self):\n    return self.name\n\n\nclass Square(Shape):\n  def __init__(self, length):\n    super().__init__(\"Square\")\n    self.length = length\n\n\n  def area(self):\n    return self.length**2\n\n\n  def fact(self):\n    return \"Squares have each angle equal to 90 degrees.\"\n\n\nclass Circle(Shape):\n  def __init__(self, radius):\n    super().__init__(\"Circle\")\n    self.radius = radius\n\n\n  def area(self):\n    return pi*self.radius**2\n\n\na = Square(4)\nb = Circle(7)\n\n\nprint(b)\nprint(b.fact())\nprint(a.fact())\nprint(b.area())"},{"title":"Processor","description":"A processor is the electric circuitry found in computer hardware which is responsible for executing instruction sets derived from programs that have been converted into machine code.\n\nProcessors are comprised of components called transistors and capacitors. Transistors and capacitors are made of semiconductor material (silicon, germanium, etc.) which amplify electic currents or turn them off based on the application instructions in the form of binary 0’s and 1’s being fed to the processor as machine code.\n\nMoore’s law which outlines the exponential improvements achieved by the addition of more computing power and smaller processors over time, has led processors to take the form of “microprocessors”, which are implemented on metal-oxide semiconductor integrated circuit chips. Todays processors contain billions of transistors on silicon as small as a fingernail.\n\nOften the generic reference to a processor refers to the Central Processing Unit (CPU), which in addition to computing is a powerful source for caching data.\n\nDifferent Types of Processors\nMicroprocessor\nMicrocontroller\nEmbedded Processor\nDigital Signal Processor"},{"title":"Progressive Web Application","description":"A progressive web application (PWA) is software that is built with common web technologies to provide a consistent, browser-based experience across multiple platforms like mobile and desktop. Browser compatibility for PWAs is various but is generally supported in the following:\n\nGoogle Chrome\nApple Safari\nFirefox (for Android, not desktop)\nMicrosoft Edge\nPWA Principles\n\nRather than being a programming language or separate technology, PWAs are a collection of key principles followed in every application, including:\n\nDiscoverable: The app can be readily found on app stores and search engines.\nInstallable: The app can be installed as a “native-like app” on a device for later use on the browser.\nLinkable: A secure and unique link can be used to visit and share the app.\nNetwork independence: The app provides an offline experience with service workers and other web APIs.\nRe-engagement: The app can update content when not in use and push notifications to the user.\nResponsive design: The app’s user interface is consistent across all resolutions and screen sizes.\nSecure: The app uses HTTPS for secure browsing."},{"title":"Prototype Pattern","description":"The prototype pattern adds cloning functionality to an object’s class. After the instantiation an initial object, the prototype removes the need for the new keyword in creating subsequent objects at run time. New objects are created using the property values of a pre-existing object.\n\nTwo types of copying are associated with the prototype pattern:\n\nShallow copy: Copies the immediate property values.\nDeep copy: Copies the immediate values, plus any referenced object.\nExample: Shallow Copy vs Deep Copy\n\nShown below is a model consisting of two classes: TvSeries and Episode. Cloning functionality has been added to TvSeries by implementing the Cloneable interface.\n\npublic class TvSeries implements Cloneable {\n  private final String name;\n  private final int seriesNo;\n  // Notice one or more properties are a complex type and mutable\n  private final List<Episode> episodes;\n\n\n  public TvSeries(String name, int seriesNo, List<Episode> episodes) {\n    this.name = name;\n    this.seriesNo = seriesNo;\n    this.episodes = episodes;\n  }\n\n\n  // Shallow copy method\n  @Override\n  public TvSeries clone() throws CloneNotSupportedException {\n    // Cast to TvSeries as super returns Object\n    return (TvSeries) super.clone();\n  }\n\n\n  // Deep copy\n  public TvSeries deepCopy() {\n    // New Episode objects are created during the copy\n    final List<Episode> episodes = new ArrayList<>();\n\n\n    for (Episode episode : this.episodes) {\n      episodes.add(new Episode(episode.getName, episode.getEpNo));\n    }\n\n\n    return new TvSeries(this.name, this.seriesNo, episodes);\n  }\n\n\n  // Getters and toString\n}\n\nTvSeries class has a list of complex objects (Episode) as one of its properties. Shallow copying through clone() will only copy the outermost TvSeries object and negate creating new objects to reference for the list of episodes.\n\nThe deepCopy() method, by comparison, iterates through the list of Episode to create a list of new TvSeries objects. This list is then used by the TvSeries constructor when creating a copy. The new TvSeries object references a new or independent list of episodes.\n\nBelow provides a model class for the complex object type Episode described above:\n\npublic class Episode {\n  private String name;\n  private int epNo;\n\n\n  public Episode(String name, int epNo) {\n    this.name = name;\n    this.epNo = epNo;\n  }\n\n\n  // Getters, setters, and toString\n}\n\nNote: The properties of the Episode class are mutable.\n\nThe following code demonstrates a limitation of the shallow copy:\n\npublic class Main {\n  public static void main(String[] args) throws CloneNotSupportedException {\n    // A 'new' TvSeries object is created as seriesOne\n    Episode episodeOne = new Episode(\"Hello Friend\", 13);\n    final Series seriesOne = new Series(\"Mr Robot\", 1, Collections.singletonList(episodeOne));\n\n\n    // A second TvSeries object is created by shallow copying seriesOne\n    final Series seriesTwo = seriesOne.clone();\n    // Change the name of S2ep1\n    seriesTwo.getEpisodes().get(0).setName(\"Unmask\");\n    // S2ep1 name has changed\n    System.out.println(seriesTwo.getEpisodes().get(0).getName()); // Unmask\n    // But, so has S1ep1 :(\n    System.out.println(seriesOne.getEpisodes().get(0).getName()); // Unmask\n  }\n}\n\nOur main method starts by creating two new objects: episodeOne of type Episode and seriesOne of type Series. seriesOne is then cloned using a shallow copy to instantiate seriesTwo, and as a result, our program now has two Series objects (seriesOne and seriesTwo) referencing a single list of episodes in memory. Finally, when we change the name of the episode through its setter method, the name change appears in both Series 1 Episode 1 and Series 2 Episode 1.\n\nBelow is the same example but using the deepCopy() in place of clone():\n\npublic class Main {\n  public static void main(String[] args) throws CloneNotSupportedException {\n    // A 'new' TvSeries object is created as seriesOne\n    Episode episodeOne = new Episode(\"Hello Friend\", 13);\n    final Series seriesOne = new Series(\"Mr Robot\", 1, Collections.singletonList(episodeOne));\n\n\n    // A second TvSeries object is created using a deep copy of seriesOne\n    final Series seriesTwo = seriesOne.deepCopy();\n    // Change the name of S2ep1\n    seriesTwo.getEpisodes().get(0).setName(\"Unmask\");\n    // S2ep1 name has changed\n    System.out.println(seriesTwo.getEpisodes().get(0).getName()); // Unmask\n    // And s1ep1 name remains correct :)\n    System.out.println(seriesOne.getEpisodes().get(0).getName()); // Hello Friend\n  }\n}\n\nRather than instantiating two TvSeries objects that reference a single list of episodes in memory, the deepCopy() creates a list of new episodes in memory by iterating over the old. There are now two TvSeries objects referencing two Episode objects in memory, and the name of each Episode object can be changed independently.\n\nUML Design\n\nExample: Prototype\n\nTo illustrate the prototype pattern, below provides a real-world example, in Java, depicting potential considerations for a video streaming service. For some reason, returning Film or TvSeries objects is considered to be expensive. When providing the user with their watch history, the UserRepository can be used to set the needed properties from cloned objects provided by a registry.\n\nA UserRepository has been created with two methods: getUserFilmHistory() and getUserTvSeriesHistory(). Both simply return a list of Strings representing a user’s watch history.\n\npublic class UserRepository {\n  // Returns a list of film titles\n  public List<String> getUserFilmsHistory() {\n    return Arrays.asList(\n      \"Army of the Dead\",\n      \"King Arthur: Legend of the Sword\",\n      \"Total Recall\",\n      \"Friday the 13th\",\n      \"The General's Daughter\",\n      \"American Gangster\",\n      \"Replicas\",\n      \"Army of Thieves\",\n      \"21 Jump Street\",\n      \"The Harder They Fall\"\n    );\n  }\n\n\n  // Returns a list of Tv show titles\n  public List<String> getUserTvSeriesHistory() {\n    return Arrays.asList(\"Maya and the Three\",\n      \"The Thundermans\",\n      \"Riverdale\",\n      \"Locke and Key\",\n      \"Catching Killers\",\n      \"Cocomelon\",\n      \"Maid\",\n      \"Colin in Black and White\",\n      \"Squid Game\",\n      \"You\"\n    );\n  }\n}\n\nTo model the object types to be returned, Film and TvSeries have been outlined. They both extend an abstract parent class of Show. This allows us to use generics in clone(), making the returned object automatically cast to the correct type.\n\npublic abstract class Show<T> implements Cloneable {\n  // Implements clone in abstract class to make use of generics\n  @Override\n  public T clone() throws CloneNotSupportedException {\n    return (T) super.clone();\n  }\n}\n// Film extends Show<Film>, so its clone method will return a Film instance\npublic class Film extends Show<Film> {\n  private String title;\n  private String format;\n  private String thumbnailLocation;\n\n\n  // Getters, setters, and toString\n}\n// TvSeries extends Show<TvSeries>, so its clone method will return TvSeries instance\npublic class TvSeries extends Show<TvSeries> {\n  private String title;\n  private String format;\n  private String thumbnailLocation;\n\n\n  // Getters, setters, and toString\n}\n\nFinally, ShowCache has been made to add an object registry to the program. When .loadCache() is called, two template objects are created using the new keyword and placed in a static map. When getShow() is called by a client, the correct clone (taken from showMap) is returned, ready for its properties to be set. If the requested showId is not recognized, an exception is thrown.\n\npublic class ShowCache {\n  // A HashTable that contains the initial model object from which we clone from\n  public static Hashtable<String, Show<?>> showMap = new Hashtable<>();\n\n\n  // Instantiates the initial objects from which we clone from\n  public static void loadCache() {\n    final TvSeries tvSeries = new TvSeries();\n    final Film film = new Film();\n    showMap.put(\"Tv Series\", tvSeries);\n    showMap.put(\"Film\", film);\n  }\n\n\n  // Returns clone of object stored in showMap to client\n  public static Show<?> getShow(String showId) throws CloneNotSupportedException, ShowIdNotRecognisedException {\n    // Switch statement to find out which clone is needed\n    switch (showId) {\n      case \"Film\":\n        Film cashedFilm = (Film) showMap.get(showId);\n        return cashedFilm.clone();\n      case \"Tv Series\":\n        TvSeries cashedTvSeries = (TvSeries) showMap.get(showId);\n        return cashedTvSeries.clone();\n      default:\n        throw new ShowIdNotRecognisedException(\"Unable to get show: \" + showId);\n    }\n  }\n}\npublic class ShowIdNotRecognisedException extends Throwable {\n  private static final long serialVersionUID = 1;\n\n\n  public ShowIdNotRecognisedException(final String message) {\n    super(message);\n  }\n} f\n\nThe Main class below, starts the program and acts as the client in this example. It asks the registry to instantiate the initial objects to clone from before using the UserRepository‘s data and the getShow method to return a list of Film and TvSeries objects representing a user’s previously watched shows.\n\nNote: After the instantiation of initial objects in the registry’s .loadCache(), all other Film and TvSeries objects are created through cloning functionality. The new keyword is absent.\n\npublic class Main {\n\n\n  public static void main(String[] args) {\n    // Create initial objects\n    ShowCache.loadCache();\n    final UserRepository userRepository = new UserRepository();\n    // For each film title, clone Film object and set appropriate properties. Return list\n    final List<Film> filmHistory = userRepository.getUserFilmsHistory().stream().map(entry -> {\n      Film film = null;\n\n\n      try {\n        film = (Film) getShow(\"Film\").clone();\n        film.setTitle(entry);\n        film.setFormat(\".mp4\");\n        film.setThumbnailLocation(\"films/assets/\" + entry.toLowerCase().replace(\" \", \"_\") + film.getFormat());\n      } catch (CloneNotSupportedException | ShowIdNotRecognisedException e) {\n        e.printStackTrace();\n      }\n\n\n      return film;\n    }).collect(Collectors.toList());\n\n\n    // For each tv show title, clone TvSeries object and set appropriate properties. Return list\n    final List<TvSeries> tvSeriesHistory = userRepository.getUserTvSeriesHistory().stream().map(entry -> {\n      TvSeries tvSeries = null;\n\n\n      try {\n        tvSeries = (TvSeries) getShow(\"Tv Series\").clone();\n        tvSeries.setTitle(entry);\n        tvSeries.setFormat(\".mp4\");\n        tvSeries.setThumbnailLocation(\"tv-shows/assets/\" + entry.toLowerCase().replace(\" \", \"_\") + tvSeries.getFormat());\n      } catch (CloneNotSupportedException | ShowIdNotRecognisedException e) {\n        e.printStackTrace();\n      }\n\n\n      return tvSeries;\n    }).collect(Collectors.toList());\n\n\n    // Print filmHistory and tvSeriesHistory to the console\n    System.out.println(filmHistory);\n    System.out.println(tvSeriesHistory);\n  }\n}"},{"title":"Proxy Server","description":"Proxy servers are intermediary computers that allows a client to connect with a web server while maintaining privacy.\n\nEvery computer needs a unique IP address to connect with the server(s) of a network. The IP address sends a request to the server for a response with data such as the web page for this entry. Proxy servers come with their own IP address that is used to direct the client’s request to the server.\n\nDepending on the setup, use-cases for a single proxy server include the following:\n\nIt can serve as a common “exit point” for the client and the network to access the internet.\nIt can be an “entry point” for clients outside of the network to access multiple internal servers.\n\nUnlike VPNs, which offer a secure connection that is system-wide, proxy servers only offer privacy protection while web browsing.\n\nForward Proxy Servers\n\nForward proxy servers are used to manage how a person or organization communicates with and accesses external web servers. If an unauthorized user tried to visit a restricted page on the network, the forward proxy server would step in and send a message back saying that the user was denied access.\n\nDepending on the specific needs, forward proxy servers come in the following forms and configurations:\n\nTransparency proxies are commonly used by institutions (schools, libraries, etc.) to enforce acceptable use policies and cache content for improved performance.\nAn anonymous server uses its own IP address for web requests while identifying itself as a proxy (ideal for avoiding ads).\nHigh anonymity proxies usually change their IP address after each request, maximizing privacy.\nReverse Proxy Servers\n\nReverse proxy servers are used by people and organizations for managing incoming web traffic and housing data on multiple servers. With this server in place, all website requests are directed to a single proxy server that can then fetch the requested data and send it back to the computer.\n\nIn this setup, the reverse proxy server acts as a traffic cop to ensure that no website server is overloaded with requests. It also serves as a security buffer that prevents people from directly communicating with company servers."},{"title":"Pseudocode","description":"Pseudocode is a method of describing the steps in an algorithm or other computed process written in plain language. It does not rely on any particular implementation of a programming language, and instead is intended for a human audience. It omits the portions required for machine implementation of the algorithm, such as variable declarations, and includes natural language description details.\n\nPseudocode is a compact machine-independent way of communicating an algorithm and is used in teaching, scientific papers, and in program development. There is no particular standard for psudocode syntax. However, guidelines may exist in certain situations, such as in an academic environment, or for publication.\n\nPseudocode may borrow format and syntax for control structures from some conventional programming languages, while things like function calls and blocks of code within a loop may be replaced by natural language descriptions. Therefore, implementations of psudocode may vary widely, from a close approximation to a finished program, to a block of formatted prose.\n\nExample 1\n\nThe following is a pseudocode description of a basic bubble sort algorithm using C++ formatting:\n\nfunction bubbleSort(A : list of sortable items) {\n  n = length(A);\n  do {\n    swapped = false\n    for (i = 1; i <= n-1; i = i + 1) {\n      // If this pair is out of order\n      if (A[i-1] > A[i]) {\n        // Swap them and remember something changed\n        // swap(A[i-1], A[i]);\n        // swapped = true;\n      }\n    }\n  }\n  while (swapped);\n}\nExample 2\n\nThe following is a psudocode description of the above algorithm in more prose-like formatting:\n\nvariable A is a zero-indexed list of sortable items\n\nset n = the number of items in A\n\nloop\n  set swapped = false\n  for i = 1 to n-1\n    if A[i] is less than prior element then swap A[i] with prior element\n    set swapped = true\n  end for\n  if swapped is false then exit loop\nend loop"},{"title":"RAM","description":"RAM is an acronym for Random Access Memory, which is a mechanism for storing and retrieving information in random memory units as opposed to other formats that store data in specific memory locations. RAM is considered a volatile place for storage of information due to the fact that data can be lost if power is suddenly unavailable.\n\nThe Two Types of RAM\n\nStatic RAM (SRAM): A form of random access memory which does not need to periodically refresh its memory. Static RAM is more expensive and more complex to manufacture than DRAM due to the fact that SRAM can contain multiple transistors in layered architectures within a memory unit. As a result of this more dense architecture it has more processing power and is faster. SRAM is more prevalent in systems requiring substantial computing power. SRAM is primarily used for CPU Caches in processors.\n\nDynamic RAM (DRAM): A form of random access memory which requires the periodic refreshing of data. DRAM is more common than SRAM due to its comparitively simpler mechanical structure. Due to this more simplified structure it is cheaper and easier to manufacture. DRAM is considered main memory in processors."},{"title":"React Native","description":"React Native is an open-source mobile development framework that works across different operating systems like iOS and Android. It was released in 2015 by Facebook (now Meta) and can be used on many smart devices, such as phones, personal computers, and TVs, to provide a consistent interface and user experience.\n\nTraditional mobile app development required multiple codebases for each operating system (iOS, Android, AppleTV, etc.) along with their associated programming languages (Swift, Java, etc.). However, React Native provides a single codebase written in React-based JavaScript and rendered in the device’s native language.\n\nGetting Started\n\nReact Native can be installed, configured, and used in two ways:\n\nThe Expo CLI only requires Node.js to quicky build and troubleshoot an application. This can also be done in-browser with Snack.\nThe React Native CLI requires a few extra dependencies and configurations, depending on the scope of the project."},{"title":"Relational Database","description":"A relational database is a store of data organized in tables made of columns and rows, and the relationships between those tables. The software that controls a relational database is called a relational database management system (RDBMS) and typically allows management and updates to the database through an implementation of the structured query language (SQL).\n\nStructure of a Relational Database\n\nMost tables are defined with a key column that holds a unique value for every row. That column is called a primary key. Columns in a table that reference primary keys in other tables are called foreign keys. Data in different tables are related to each other via matching values in the key columns in those tables.\n\nRows in each table are also called records. Columns can also be called fields or attributes.\n\nGenerally each table represents a particular entity type, such as a user, product, or transaction. Each row or record represents a particular instance of that entity type, and each column/field in that record represents particular values ascribed to that instance, such as name, price, or transaction date.\n\nFor instance, a company may have a sales database with tables called products and sales.\n\nThe product table would have columns for things like name, model, unit cost, and retail price.\nThe sales table would have columns for things like sale date, payment method, and shipping address.\n\nEach entry in the sales table would have a foreign key referring to the primary key of the product table (the product that was bought).\n\nThe relation between the product table to the sales table is referred to as a one-to-many relationship (for each product there can be multiple sales).\n\nExamples of Relational Database Management Systems\nMySQL is a free open-source RDBMS that is used for many database-driven web applications such as Drupal, Joomla and WordPress.\nSQLite is a C library used to embed relational database functionality into software packages.\nPostgreSQL is a free open-source RDBMS that emphasizes extensibility and compliance to the ANSI SQL standards.\nMicrosoft SQL Server is a server-based RDBMS from Microsoft typically used as a back-end for applications running on a network.\nMicrosoft Access is part of the Microsoft 365 suite of applications. It combines an RDBMS with a graphical user interface and programming tools, allowing application development inside the software.\nMicrosoft Azure SQL Database is a managed cloud-based RDBMS provided as part of Microsoft Azure."},{"title":"Routing","description":"Routing is the process of deciding what paths communication signals may take across one or more networks. This process is used in many scenarios related to computer networking, including:\n\nA PC communicating with a printer across a Local Area Network, or LAN.\nA phone’s web browser communicating with a web server over the Internet.\n\nThrough routing, these communication signals, called packets, can take multiple paths from the source to the destination.\n\nRouters\n\nThe process of routing is executed by devices known as routers. They live on the network where there are junctions (nodes) between these various paths. Routers can either be physical pieces of hardware or software based, which tend to be more limited in functionality.\n\nA router always has some default path to send network traffic if no specific destination is specified. For packets with a specific destination, if there is more than one path, the router can make a decision on what path to use based on several criteria, which can include:\n\nHop Count: The number of intermediate devices (routers) between the source and destination.\nBandwidth: The maximum amount of data that can travel a route in a given period of time.\nDelay/Latency: The time between a signal sent on a route, and the response received.\nTypes of Routing\n\nThere are several types of routing, based on the characteristics of the destination:\n\nUnicast Routing: The packet is being sent to a single specified location.\nBroadcast Routing: The packet is sent to all nodes on the network, even nodes that haven’t requested it.\nMulticast Routing: Similar to broadcast routing, but packets are only sent to nodes that want them.\nAnycast Routing: The destination consists of several devices with the same logical address and the packet is routed to the closest of these devices."},{"title":"Runtime","description":"In computer programming, runtime references the period of time during which a program is running, as well as the environment that communicates between the hardware and operating system.\n\nThe runtime environment is specifically any software or instructions that are executed while a program is running. These instructions can include functions for optimization, memory management, debugging, and input/output.\n\nA runtime error is effectively any error a program has after it has been executed. Developers can use runtime environments to test code for debugging runtime errors, before launching the program into production."},{"title":"Ruby on Rails","description":"Ruby on Rails, or “Rails”, is an open-source server-side framework written in Ruby and used for building web applications. Rails provides a pre-built, boilerplate code that can be reused or customized in an application.\n\nWhile particularly popular with startups, some well-known companies that use Rails include Airbnb, Basecamp, Github, Shopify, and SoundCloud.\n\nInstallation\n\nRails can be installed as a Ruby gem. However, the following prerequisites must be installed beforehand:\n\nRuby version 2.7.0 or later, but preferably the latest version.\nSQLite3 is the default database used on Rails.\nNode.js (version 8.16.0 or later) for running JavaScript alongside Rails.\nYarn (version 1 or 2 are both fine) for installing and managing JavaScript packages.\n\nHelp with installing these prerequisites can be found in “Getting Started with Rails”.\n\nLastly, Rails can be installed with the following command:\n\ngem install rails\nThe MVC Pattern\n\nRails uses a common structural pattern known as the Model-View-Controller (MVC) pattern. It categorizes a web application’s code into three interconnected parts:\n\nThe Model that defines the data structure of the application.\nThe Views that use templates to represent the visual parts, like the Model data, of the application.\nThe Controller that works between the Model and Views to perform business logic for the application.\nUse Cases\n\nRuby on Rails is used across many industries for building web apps and services. This includes applications like marketing websites, Content Management Systems (CMSs), eCommerce sites, and custom web applications. Tasks for working with Rails may include:\n\nCreating templates that generate web pages for the front end.\nWriting web services that return JSON for JavaScript-based front-end applications.\nWriting server-side code in Rails and client-side code with HTML/CSS and JavaScript."},{"title":"Serialization","description":"Serialization is the process of translating a complex object into a format, typically a string of characters, that can be deserialized back into a copy of the original object. This is beneficial as it allows the software to save the state of an arbitrary object to a destination that can be completely unaware of its details. Any object can be saved to a simple string variable, database field, external file system, third-party application in the cloud, or even printed out on a sheet of paper.\n\nCommon formats for serialization include XML and JSON, which have the advantage of being human-readable. However, that is not a requirement, and in some cases, serialization uses other formats such as binary which aren’t human-readable. Regardless of the format, the purpose of serialization is that at a later point in time, the serialized data can be read or processed as input and be deserialized back into a copy of the original object.\n\nWhen programming languages implement serialization, they often require special declarations in defined classes to make their associated objects serializable and often require special libraries to implement this functionality.\n\nExample\n\nHere is a simple example of serialization in Python:\n\nimport json\n\n\ndef SerializeDict(input_dict):\n  print(\"Serializing input to JSON\")\n  output_str = json.dumps(input_dict)\n  print(output_str)\n\n\ntest_dict = {\n  \"make\": \"Chevy\",\n  \"model\": \"Silverado\",\n  \"msrp\" : 15000,\n  \"options\": [\"4-wheel-drive\",\"Towing Package\",\"Heated Seats\"],\n  \"year\": 2019\n}\n\n\nSerializeDict(test_dict)\n\nThe output looks like this:\n\nSerializing input to JSON\n{\"make\": \"Chevy\", \"model\": \"Silverado\", \"msrp\": 15000, \"options\": [\"4-wheel-drive\", \"Towing Package\", \"Heated Seats\"], \"year\": 2019}"},{"title":"Server","description":"A server is a hardware or software device used to provide resources to clients or requesting applications. Servers run on an architecture for fulfilling requests called the “Client-Server Model”, which works by the client asking the server for specific data in an agreed upon format and the server readying and providing the data.\n\nThe internet largely runs based on this client-server model. The term server is broad enough to encompass the myriad of specific servers that can be found today such as web servers, game servers, email servers, and proxy servers to name a few.\n\nData Centers\n\nLarge groups of servers can be referred to as data centers. As data center level scale, maintenance of servers requires diligent control of physical environments such as the temperature of locations housing servers, redundancy, etc. Cooling servers is very important at data center level server scale because servers emit heat (especially in close proximity to one another) and therefore need to be cooled down with fans and temperature control measures like air conditioning which at scale can be quite substantial in terms of resources.\n\nVirtualization and Beyond\n\nIn the early days of computing, a single server could be used to provide data to a client resource. Things developed naturally so that a single server could serve several clients and one client could communicate with several servers. These days server technology has advanced so that multiple servers can be placed on a single physical servers using hypervisors. The ability to host multiple servers on a single device is known as virtualization, and has led to exponential leaps in computing power, and efficiency in application deployment."},{"title":"Server-Side Rendering","description":"Server-side rendering (SSR) is rendering the content on the server and presenting it to the client when a request is made.\n\nWhen a request is made in client-side rendering (opposite of server-side rendering), the server sends separate files and content that is rendered in the browser. JavaScript works both on the server and browser, so it is possible for developers to render the content of an application where they want.\n\nWhy SSR is Important\n\nWhen content is rendered on a server, the time required for downloading, parsing, and executing JavaScript code is reduced. This will ensure faster load times for web pages.\n\nSSR helps in improving SEO (search engine optimization) by pre-rendering the page. Thus, search engine crawlers can easily read the generated HTML file. In client-side rendering, crawlers read an empty HTML file with links to JavaScript that reduce the search ranking of the web page. Fast loading of the server-side rendered web page also helps the site rank higher in search results.\n\nDisadvantages\n\nWhen the user clicks on a link for some content, the whole website is rendered again on the server. And if the number of concurrent users increases, the load on the servers increases. At scale, this can be troubling and expensive for SSR.\n\nSSR applications can also be more complex to build. For example, setting up SSR with React can be a little intimidating. This has been made easier in the recent years with the Next.js framework."},{"title":"Singleton Pattern","description":"The singleton pattern ensures a class has only one object instantiated during the program’s lifecycle. It is used to guarantee the control of a resource through its implementation.\n\nUML Design\n\nJava Example\n\nGenerally, singletons are lazily loaded and ensure thread safety. Below is a Java example outlining the most basic form of a singleton. The .getInstance() method creates a new instance (if one does not exist), and the synchronized keyword ensures two threads can not use this method at the same time.\n\npublic class Singleton {\n  // The singleton instance to be returned by getInstance()\n  private static Singleton instance = null;\n\n\n  // Constructor is made private to stop creation through 'new' keyword outside of getInstance()\n  private Singleton() {}\n\n\n  // Returns instance when called\n  public static synchronized Singleton getInstance() {\n    // Creates new instance if none exists\n    if (instance == null) {\n      instance = new Singleton();\n    }\n    return instance;\n  }\n}"},{"title":"Socket.IO","description":"Socket.IO is a JavaScript library that enables real-time, bidirectional, and event-based communication between the browser and the server. It consists of:\n\nServer-side library for Node.js\nClient-side library for the browser (which can be also run from Node.js)\n\nIn simpler terms, Socket.IO enables live communication between computers. It simplifies the process to write messaging applications like video chat, audio chat, and text chat.\n\nSome of the companies that use Socket.IO include Alibaba Travels, PLAID, Trello, and Patreon."},{"title":"Software Testing","description":"Software testing is the process of verifying and evaluating the functionality of a software application or product. It reduces and eliminates bugs, and mitigates the long-term costs for a company in terms of any fixes and updates that would be needed.\n\nTesting Types\n\nThere are several kinds of software testing with varying degrees of specificity, including the following:\n\nUsability tests can be performed on one or a combination of tasks to see how the programming functions in different user-based scenarios.\nAcceptance testing involves checking to make sure the several functions of a system work as expected.\nRegression testing assesses the impact of new features and helps engineers adjust how each feature affects with the program overall.\nIntegration testing aims to figure out how well different components of the app work with each other.\nUnit testing attempts to see how different units of code perform in isolation from the rest of the program.\nThrough functional testing, engineers can see how software accomplishes specific, intended purposes.\nStress tests accesses the performance of programs during worst-case scenarios to understand if and how it breaks.\nPerformance testing reveals how the program will perform in more common, real-world scenarios.\nTesting Strategies\n\nTwo specific techniques are used to assess the stability and performance of software: black-box and white-box testing. Each offers a different perspective into how well the source code holds up.\n\nBlack-box testing involves testing software without looking inside — the coding, systems, and dependencies.\nWhite-box testing aims to examine the structure within the application, or the inner workings of the app, as opposed to its overall functionality.\nLanguages Used in Testing\n\nSome programming languages that are commonly used for testing software include the following:\n\nJava\nPython\nRuby"},{"title":"SSL","description":"SSL stands for Secure Socket Layer, and is a cryptographic protocol for securing computer networks. SSL was deprecated in 1999 and renamed TLS by the Internet Engineering Task Force. TLS is essentially an improved version of SSL (it is SSL 3.1) and features a number of improvements that address security concerns that were discovered in the initial and prior implementations of SSL.\n\nSSL uses a cryptographic mechanism featuring a public and private key to encrypt data communicating over internet networks. SSL uses a protocol known as a ‘handshake’ to determine the authenticity of a server. The main advantage of SSL is the confidence it gives to users that a server has been authenticated by a trusted Certificate Authority (CA). Valid SSL certs can only be issued by accreditted Certificate Authorities which have rigid standards for issuing them.\n\nSSL validation can be instantly recognized on the web by seeing a green padlock in the url portion of a browser, in addition to traffic going over HTTPS.\n\nThese days Google ranks pages higher due to SSL cert verification and many browsers outright discourage or prevent their users from viewing sites that are lacking TLS/SSL validation.\n\nBenefits of SSL include\nE-commerce trust: Users who see a green padlock on e-commerce sites are more likely to go through with the transaction because they trust that the site is secure.\nIt gives users peace of mind that the website is handling data with integrity and that data has not been tampered as its being transfered between networks.\nEncryption of data so that it is not viewable as plain text when being transferred."},{"title":"String","description":"In computer science, sequences of characters are referred to as strings. Strings can be any length and can include any character such as:\n\nLetters\nNumbers\nSymbols\nWhitespace (spaces, tabs, new lines)\n\nThey are usually contained within a pair of 'single quotes' or \"double quotes\".\n\nHere are some examples of strings:\n\nmessage = \"Hello, world!\"\nusername = \"@sonnynomnom\"\nold_password = \"Tr0ub4dor&3\"\nnew_password = \"correcthorsebatterystaple\"\nIndex\n\nLike any other list, each character in a string has an index that denotes a character’s position.\n\nmessage = 'Howdy!'\n           012345\n\nNote: In programming, the index starts from 0, so the index of the first character would be 0.\n\nFinding the Character in a String Given its Index (Python)\n\nIn Python, to provide the index of the string message, add square brackets [ ] to find out the character at that position.\n\nmessage = 'Hello, world'\n\n\nprint(message[0])\n# Output: H\n\n\nprint(message[5])\n# Output: ,\nExample of Concatenation (Python)\n\nIt is also possible to concatenate strings together using + in some languages, such as Python and C++. To add a space between strings, an empty space can be put between quotation marks.\n\nStrings in Different Languages\nStrings in C++\nStrings in Java\nStrings in JavaScript\nStrings in Python\nStrings in Ruby"},{"title":"SVG","description":"Scalable Vector Graphics (SVG) is a XML-based file format for describing two-dimensional vector images. SVG’s description of vector graphics with text allows for infinitely-scalable high-fidelity images with small file sizes.\n\nUnlike the common bitmap image formats of JPEG and PNG, Scalable Vector Graphics files do not describe the location and colors of individual pixels. Instead, SVG files represent basic shapes and curves within a two-dimensional coordinate plane. This provides their scalability as well as straightforward scripting of transformations and animations using JavaScript as is commonly found on the web.\n\nExample\n\nAn example SVG image containing the most common shapes can be found below:\n\n<!-- Describe the two-dimensional plane on which the image will be drawn on -->\n<svg\n  width=\"300\"\n  height=\"300\"\n  viewBox=\"0 0 400 400\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <!-- Create a black rectangle whose upper-left corner is at (25, 25) and a width and height of 200 -->\n  <rect x=\"25\" y=\"25\" width=\"200\" height=\"200\" fill=\"black\" />\n\n\n  <!-- Create a white circle with a center at (125, 125) with a radius of 75 -->\n  <circle cx=\"125\" cy=\"125\" r=\"75\" fill=\"white\" />\n\n\n  <!-- Create a straight blue line from (50, 50) to (200, 200) -->\n  <line x1=\"50\" y1=\"50\" x2=\"200\" y2=\"200\" stroke=\"blue\" stroke-width=\"5\" />\n\n\n  <!-- Create a set of straight red lines going through the points (50, 125), (125, 50), (200, 125), (125, 200), and (50, 125) -->\n  <polyline\n    points=\"50,125 125,50 200,125 125,200 50,125\"\n    stroke=\"red\"\n    stroke-width=\"5\"\n    fill=\"none\"\n  />\n\n\n  <!-- Create a green quadratic Bézier curve from (50, 200) to (125, 125) \n       with a control point at (75, 75) which is then mirrored until (200, 50) -->\n  <path\n    d=\"M 50 200 Q 75 75, 125 125 T 200 50\"\n    stroke=\"green\"\n    stroke-width=\"5\"\n    fill=\"transparent\"\n  />\n</svg>"},{"title":"Subroutine","description":"A subroutine is a set of computer instructions written to perform specific tasks. It is also known as a function or a procedure. A subroutine packages code for an operation or a set of operations, which makes code reusable and readable.\n\nSyntax\n\nEvery programming language has its own syntax for defining and calling a subroutine or function. Often, the basic format of a subroutine will follow the model below:\n\nPseudo code for declaring a subroutine:\n\ndeclare <subroutine_name>\n  # subroutine code\nend\n\nPseudo code for calling a subroutine:\n\ncall <subroutine_name>\n\nIn modern programming languages, we use functions that are similar to subroutines. These functions take in argument(s) and may return some value(s) after execution.\n\nLet’s look at subroutine in JavaScript syntax.\n\nA function, func_name(), is declared and takes in any number of arguments:\n\nfunction func_name(/* var1, var2, var3,... */) {\n  // Function body\n\n\n  // Return statement is optional\n  return return_value;\n}\n\nTo call or invoke the function with any number of arguments:\n\nfunc_name(/* var1, var2, var3,... */);\nCodebyte Example\nSubroutines/Functions in Different Languages\nFunctions in C++\nFunctions in JavaScript\nFunctions in PHP\nFunctions in TypeScript\nFunctions in Ruby"},{"title":"Terminal","description":"A terminal is a program which allows programmers to type commands directly to the internal CPU or another network device. It is a no-frills program where a user simply inputs text, as opposed to a graphical user interface (GUI) where a user interacts with windows, buttons, and icons.\n\nNotable Examples\n\nThe terminal program has a different name according to the operating system you are using.\n\nOn MacOS, the command line is known as the Terminal.\nOn Windows, it is known as cmd.\nOn Linux, there could be gnome-terminal, konsole, xterm, or another."},{"title":"Tim Berners-Lee","description":"Sir Tim Berners-Lee is an English computer scientist popularly known for his development of the World Wide Web in 1989.\n\nWhile working at the European Organization for Nuclear Research (CERN) in the European Particle Physics Laboratory, Berners-Lee saw the need for a system that would share information amongst researchers globally. With this motivation, Tim Berners-Lee facilitated the first transmission between an HTTP client and server. Berners-Lee then developed the first web browser in 1990. With these milestones met, Berners-Lee developed the first ever web site, info.cern.ch.\n\nIn 1993, Berners-Lee wrote the very first version of HTML (HyperText Markup Language), the standard markup language for web pages.\n\nTim Berners-Lee has since been a prominent figure in the further development of the World Wide Web, standing as the director of the World Wide Web Consortium, and co-founder and CTO of Inrupt. Tim’s goal as he states is to continue working toward net neutrality, privacy protection, and the inclusion of the Web.\n\nFun fact: A conference room was named after Tim Berners-Lee in Codecademy’s old office."},{"title":"Tuple","description":"In computer science, a tuple is a data structure consisting of an ordered collection with an arbitrary number of elements. A tuple of “N” elements, where “N” is a positive integer, is generally referred to as an N-tuple. Many computer languages implement a tuple as its own structure or object type.\n\nTypically, a tuple implementation in any programming language has the following characteristics:\n\nIt can contain an object or any other data type in any combination.\nIt allows duplicate entries.\nIt has a specified order, determined by the order of elements during creation.\nIt is immutable and cannot have its elements changed once it is defined.\nIts elements are iterable.\nInstances are not equal unless they consist of the same members in the same order. (i.e. (1,2,3) <> (3,2,1))\n\nSome languages, such as Python, have built-in support for tuples, while other languages, such as Java, don’t have built-in support for tuples and need to define a class, or import a special library to implement them.\n\nLanguages with built-in support for tuples include:\n\nPython\nSwift\nTypeScript\nExample\n\nThe following defines three different tuples in Python:\n\na = (1, 2, 3)\nb = ('x', 23, [0,6,15])\nc = (a, b)"},{"title":"Unit Testing","description":"Unit testing is an important part of coding and software development because it verifies whether individual parts of the source code behave and work as expected.\n\nThese parts, or units, of code can be anything from a class function to a snippet of code that performs a specific task. Testing these units individually allows for finding errors earlier on in the development process.\n\nTypes of Unit Testing\n\nUnit testing is usually categorized into two types:\n\nManual testing\nAutomated testing\nManual Testing\n\nManual testing is when tests are done directly by testers. This can involve actions such as clicking on objects, providing input, or scrolling through items.\n\nDepending on the length of the software, this type of testing can be time-consuming. An alternative to this would be automated testing.\n\nAutomated Testing\n\nAutomated testing is when programs are written specifically to test code. This is optimal when manual testing becomes tedious, frequent testing is needed, or when multiple individuals are adding or making changes to the code.\n\nWriting scripts to test parts of the source code is a way to automate testing. Combined with a testing automation tool, these scripts can run automatically and immediately inform developers if any errors have occurred.\n\nPros and Cons\n\nUnit testing is an important part of the development phase when writing code because it can potentially highlight errors earlier in development. It’s best practice to test parts or units of code to verify its correctness during development or after making changes.\n\nEvery project can benefit from unit testing because:\n\nIt can reduce the chances of having compound errors.\n\nMakes debugging easier.\n\nHelps creators write better code by encouraging them to write in smaller chunks.\n\nMakes it easier to make changes to the source code.\n\nHowever, it is important to note that there are some disadvantages to unit testing including:\n\nOne line of code may need multiple lines of test code to test it.\n\nCan’t test everything; not every execution path can be covered with unit testing.\n\nIt can not catch integration errors or broad system errors.\n\nUnit-testing may seem like a time-consuming process that could take a while to get a handle on. Nevertheless, having a process in place that contributes to the robustness and correctness of the source code can save time in the long-run."},{"title":"UUID","description":"A universally unique identifier (UUID) is a string of 128 bits that is supposed to be unique with little to no chance of clashing with any other UUIDs produced by anybody else in the world. It can be generated on any computer without the use of a centralized authority.\n\nUUIDs are usually used in database tables as unique keys. They are useful any time we need an ID that needs to be unique in an application or system.\n\nFormat\n\nA UUID is usually represented as 32 hexadecimals, separated in five groups by 4 hyphens. For example:\n\n123e4567-e89b-12d3-a456-42661417400\n\nSo a total of 36 characters in the form 8-4-4-4-12.\n\nUUID Example in JavaScript\n\nUUIDs can be used in JavaScript with the uuid package. The package can be installed via npm:\n\nnpm install uuid\n\nThis example shows how to generate a UUID with the uuidv4() function:\n\nconst { v4: uuidv4 } = require('uuid');\n\n\nconsole.log(uuidv4());\n// Output: 7637c099-79c8-4685-ad47-b1b985f7ac2b"},{"title":"User Interface Design","description":"User interface (UI) design is the art and science of maximizing the usability of a digital product or service. With the advent of web applications, responsive design, and mobile development, UI design has grown into a field of its own.\n\nOverall, users have less and less tolerance for a text-heavy UI, especially on smaller devices. Poor UI leads to a poor user experience (UX), and many people flee at the sight of a poorly designed screen. As a result, many sites and apps invest a lot of time and effort into making their UI responsive with visually appealing and easy-to-use functions.\n\nDesign Rules\n\nWhile a cutting-edge discipline, UI design still adheres to rules and principles. Designers strive to increase software usability and reduce the learning-curve. They also ensure all the interfaces within a system or technology are consistent.\n\nBorrowing from Adobe’s Four Golden Rules of Design, users must have the following capabilities when interacting with the UI:\n\nThe user controls the navigation and can undo their actions.\nA minimal amount of steps are needed to perform a task.\nThere is sensible feedback for certain user actions such as gestures, taps, and button clicks.\nIndicators of page loads (progress bars, percentages, etc.) should be present.\nThere should be visible help guides and other functions for users of all skill levels."},{"title":"Void","description":"Several programming languages derived from C use a void type to denote functions that do not return a result and are mostly used for side effects."},{"title":"Vim","description":"Vim is a text editor that is free, open-source, and based on the vi editor that was originally created for the Unix operating system. However, it can be run on other systems such as Windows, Mac, Linux, or Android.\n\nMany plugins are available to add to the many features built into Vim. Developers will find it useful for working on source code or scripting files. Vim is ideal for editing configuration files when working from the terminal.\n\nFeatures\n\nThis section describes some important features of the Vim editor.\n\nIt has text completion for faster editing.\nIt is able to compare differences between files and merge them.\nIt can search for regular expressions.\nUsers can perform complicated tasks using commands.\nUsers can open files in mulitple tabs.\nUsers can create macros of a sequence of commands.\nUsers can save sessions to start where you left off last time.\nLaunching Vim\n\nVim can be launched directly from the terminal by running the vim command. The start screen will look like this:\n\nThe following command is commonly used for exiting Vim on the terminal:\n\n~\n~\n~\n:q!\n\nWhile this will close the current buffer, it will not save any changes made in the file. Here are some recommended safeguards:\n\nCommand\tDescription\n:!wq\tCloses the current file buffer and saves the changes.\n:!xa\tSaves all changes and exits Vim.\n!wqa\tWorks the same as the :!xa command.\n:!qa\tCloses Vim without warning by ending all file buffers and not saving their changes.\n:qa\tWill not close Vim if there are any unsaved changes.\n\nA file named filename.txt can be opened in the Vim editor. If filename.txt does not exist, the file will be created:\n\nvim filename.txt\nVim Graphical User Interface (GUI)\n\nVim is also available as a GUI application:"},{"title":"Webpack","description":"Webpack is a module bundler for JavaScript, HTML, and CSS. Webpack can be run on Linux, macOS, Windows operating systems.\n\nAs a module bundler, Webpack can be used with webpack.config.js to generate dependency graphs, and define rules for tasks performed on a site. Primarily it is used by developers to load, transform, and package modules for in-browser use.\n\nNode.js is required to use webpack, however it is supported by all browsers that are ES5-compliant."},{"title":"WebRTC","description":"WebRTC (Web Real-Time Communication) is a free and open-source collection of APIs that allow peer-to-peer connections between two or more browser clients.\n\nOriginally developed in 2011 and currently maintained by Google, WebRTC has been published as a specification by the W3C and is supported by all major browsers.\n\nWebRTC vs WebSockets\n\nWebRTC is commonly used for video chatting apps because it allows two or more computers to connect and send audiovisual data without needing a server.\n\nConversely, WebSockets allow for a two-way connection between a server and client using the ws:// protocol."}]}